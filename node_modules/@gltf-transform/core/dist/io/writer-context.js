import { ImageUtils } from '../utils';
/**
 * Model class providing writing state to a {@link Writer} and its {@link Extension}
 * implementations.
 *
 * @hidden
 */
export class WriterContext {
    constructor(jsonDoc, options) {
        this.jsonDoc = jsonDoc;
        this.options = options;
        this.accessorIndexMap = new Map();
        this.cameraIndexMap = new Map();
        this.skinIndexMap = new Map();
        this.materialIndexMap = new Map();
        this.meshIndexMap = new Map();
        this.nodeIndexMap = new Map();
        this.imageIndexMap = new Map();
        this.textureDefIndexMap = new Map(); // textureDef JSON -> index
        this.samplerDefIndexMap = new Map(); // samplerDef JSON -> index
        this.imageData = [];
    }
    /**
     * Creates a TextureInfo definition, and any Texture or Sampler definitions it requires. If
     * possible, Texture and Sampler definitions are shared.
     */
    createTextureInfoDef(texture, textureInfo, textureSampler) {
        const samplerDef = {
            magFilter: textureSampler.getMagFilter() || undefined,
            minFilter: textureSampler.getMinFilter() || undefined,
            wrapS: textureSampler.getWrapS(),
            wrapT: textureSampler.getWrapT(),
        };
        const samplerKey = JSON.stringify(samplerDef);
        if (!this.samplerDefIndexMap.has(samplerKey)) {
            this.samplerDefIndexMap.set(samplerKey, this.jsonDoc.json.samplers.length);
            this.jsonDoc.json.samplers.push(samplerDef);
        }
        const textureDef = {
            source: this.imageIndexMap.get(texture),
            sampler: this.samplerDefIndexMap.get(samplerKey)
        };
        const textureKey = JSON.stringify(textureDef);
        if (!this.textureDefIndexMap.has(textureKey)) {
            this.textureDefIndexMap.set(textureKey, this.jsonDoc.json.textures.length);
            this.jsonDoc.json.textures.push(textureDef);
        }
        return {
            index: this.textureDefIndexMap.get(textureKey),
            texCoord: textureInfo.getTexCoord(),
        };
    }
    createPropertyDef(property) {
        const def = {};
        if (property.getName()) {
            def.name = property.getName();
        }
        if (Object.keys(property.getExtras()).length > 0) {
            def.extras = property.getExtras();
        }
        return def;
    }
    createAccessorDef(accessor) {
        const accessorDef = this.createPropertyDef(accessor);
        accessorDef.type = accessor.getType();
        accessorDef.componentType = accessor.getComponentType();
        accessorDef.count = accessor.getCount();
        accessor.getMax((accessorDef.max = []));
        accessor.getMin((accessorDef.min = []));
        accessorDef.normalized = accessor.getNormalized();
        return accessorDef;
    }
    createImageData(imageDef, data, texture) {
        if (this.options.isGLB) {
            this.imageData.push(data);
            imageDef.bufferView = this.jsonDoc.json.bufferViews.length;
            this.jsonDoc.json.bufferViews.push({
                buffer: 0,
                byteOffset: -1,
                byteLength: data.byteLength
            });
        }
        else {
            const extension = ImageUtils.mimeTypeToExtension(texture.getMimeType());
            imageDef.uri = this.imageURIGenerator.createURI(texture, extension);
            this.jsonDoc.resources[imageDef.uri] = data;
        }
    }
}
export class UniqueURIGenerator {
    constructor(multiple, basename) {
        this.multiple = multiple;
        this.basename = basename;
        this.counter = 1;
    }
    createURI(object, extension) {
        if (object.getURI()) {
            return object.getURI();
        }
        else if (!this.multiple) {
            return `${this.basename}.${extension}`;
        }
        else {
            return `${this.basename}_${this.counter++}.${extension}`;
        }
    }
}
