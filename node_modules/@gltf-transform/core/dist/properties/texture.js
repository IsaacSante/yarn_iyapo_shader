import { PropertyType } from '../constants';
import { ImageUtils } from '../utils';
import { ExtensibleProperty } from './extensible-property';
import { COPY_IDENTITY } from './property';
/**
 * # Texture
 *
 * *Texture, or images, referenced by {@link Material} properties.*
 *
 * Textures in glTF-Transform are a combination of glTF's `texture` and `image` properties, and
 * should be unique within a document, such that no other texture contains the same
 * {@link getImage}() data. Where duplicates may already exist, the `dedup({textures: true})`
 * transform can remove them. A {@link Document} with N texture properties will be exported to a
 * glTF file with N `image` properties, and the minimum number of `texture` properties necessary
 * for the materials that use it.
 *
 * For properties associated with a particular _use_ of a texture, see {@link TextureInfo} and
 * {@link TextureSampler}.
 *
 * Reference:
 * - [glTF → Textures](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#textures)
 * - [glTF → Images](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#images)
 *
 * @category Properties
 */
export class Texture extends ExtensibleProperty {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.TEXTURE;
        /** @hidden Raw image data for this texture. */
        this.image = null;
        /** @hidden Image MIME type. Required if URI is not set. */
        this.mimeType = '';
        /** @hidden Image URI. Required if MIME type is not set. */
        this.uri = '';
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        this.mimeType = other.mimeType;
        this.uri = other.uri;
        if (other.image)
            this.image = other.image.slice(0);
        return this;
    }
    /**********************************************************************************************
     * MIME type / format.
     */
    /** Returns the MIME type for this texture ('image/jpeg' or 'image/png'). */
    getMimeType() { return this.mimeType; }
    /**
     * Sets the MIME type for this texture ('image/jpeg' or 'image/png'). If the texture does not
     * have a URI, a MIME type is required for correct export.
     */
    setMimeType(mimeType) {
        this.mimeType = mimeType;
        return this;
    }
    /**********************************************************************************************
     * URI / filename.
     */
    /** Returns the URI (e.g. 'path/to/file.png') for this texture. */
    getURI() {
        return this.uri;
    }
    /**
     * Sets the URI (e.g. 'path/to/file.png') for this texture. If the texture does not have a MIME
     * type, a URI is required for correct export.
     */
    setURI(uri) {
        this.uri = uri;
        return this;
    }
    /**********************************************************************************************
     * Image data.
     */
    /** Returns the raw image data for this texture. */
    getImage() { return this.image; }
    /** Sets the raw image data for this texture. */
    setImage(image) {
        this.image = image;
        return this;
    }
    /** Returns the size, in pixels, of this texture. */
    getSize() {
        let isPNG;
        if (this.mimeType) {
            isPNG = this.mimeType === 'image/png';
        }
        else {
            isPNG = this.uri.match(/\.png$/);
        }
        return isPNG
            ? ImageUtils.getSizePNG(this.image)
            : ImageUtils.getSizeJPEG(this.image);
    }
}
