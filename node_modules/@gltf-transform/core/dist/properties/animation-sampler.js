var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PropertyType } from '../constants';
import { GraphChild } from '../graph';
import { COPY_IDENTITY, Property } from './property';
/**
 * # AnimationSampler
 *
 * *Reusable collection of keyframes affecting particular property of an object.*
 *
 * Each AnimationSampler refers to an input and an output {@link Accessor}. Input contains times
 * (in seconds) for each keyframe. Output contains values (of any {@link Accessor.Type}) for the
 * animated property at each keyframe. Samplers using `CUBICSPLINE` interpolation will also contain
 * in/out tangents in the output, with the layout:
 *
 * in<sub>1</sub>, value<sub>1</sub>, out<sub>1</sub>, in<sub>2</sub>, value<sub>2</sub>, out<sub>2</sub>,
 * in<sub>3</sub>, value<sub>3</sub>, out<sub>3</sub>, ...
 *
 * Usage:
 *
 * ```ts
 * // Create accessor containing input times, in seconds.
 * const input = doc.createAccessor('bounceTimes')
 * 	.setArray(new Float32Array([0, 1, 2]))
 * 	.setType('SCALAR');
 *
 * // Create accessor containing output values, in local units.
 * const output = doc.createAccessor('bounceValues')
 * 	.setArray(new Float32Array([
 * 		0, 0, 0, // y = 0
 * 		0, 1, 0, // y = 1
 * 		0, 0, 0, // y = 0
 * 	]))
 * 	.setType('VEC3');
 *
 * // Create sampler.
 * const sampler = doc.createAnimationSampler('bounce')
 * 	.setInput(input)
 * 	.setOutput(output)
 * 	.setInterpolation('LINEAR');
 * ```
 *
 * Reference
 * - [glTF â†’ Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)
 */
export class AnimationSampler extends Property {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.ANIMATION_SAMPLER;
        this._interpolation = "LINEAR" /* LINEAR */;
        this.input = null;
        this.output = null;
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        this._interpolation = other._interpolation;
        if (other.input)
            this.setInput(resolve(other.input.getChild()));
        if (other.output)
            this.setOutput(resolve(other.output.getChild()));
        return this;
    }
    /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */
    getInterpolation() {
        return this._interpolation;
    }
    /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */
    setInterpolation(interpolation) {
        this._interpolation = interpolation;
        return this;
    }
    /** Times for each keyframe, in seconds. */
    getInput() {
        return this.input ? this.input.getChild() : null;
    }
    /** Times for each keyframe, in seconds. */
    setInput(input) {
        this.input = this.graph.link('input', this, input);
        return this;
    }
    /**
     * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out
     * tangents.
     */
    getOutput() {
        return this.output ? this.output.getChild() : null;
    }
    /**
     * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out
     * tangents.
     */
    setOutput(output) {
        this.output = this.graph.link('output', this, output);
        return this;
    }
}
__decorate([
    GraphChild
], AnimationSampler.prototype, "input", void 0);
__decorate([
    GraphChild
], AnimationSampler.prototype, "output", void 0);
