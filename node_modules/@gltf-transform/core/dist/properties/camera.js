import { PropertyType } from '../constants';
import { ExtensibleProperty } from './extensible-property';
import { COPY_IDENTITY } from './property';
/**
 * # Camera
 *
 * *Cameras are perspectives through which the {@link Scene} may be viewed.*
 *
 * Projection can be perspective or orthographic. Cameras are contained in nodes and thus can be
 * transformed. The camera is defined such that the local +X axis is to the right, the lens looks
 * towards the local -Z axis, and the top of the camera is aligned with the local +Y axis. If no
 * transformation is specified, the location of the camera is at the origin.
 *
 * Usage:
 *
 * ```typescript
 * const camera = doc.createCamera('myCamera')
 * 	.setType('perspective')
 * 	.setZNear(0.1)
 * 	.setZFar(100)
 * 	.setYFov(Math.PI / 4)
 * 	.setAspectRatio(1.5);
 *
 * node.setCamera(camera);
 * ```
 *
 * References:
 * - [glTF â†’ Cameras](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#cameras)
 *
 * @category Properties
 */
export class Camera extends ExtensibleProperty {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.CAMERA;
        // Common.
        this._type = "perspective" /* PERSPECTIVE */;
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        this._type = other._type;
        this._znear = other._znear;
        this._zfar = other._zfar;
        this._aspectRatio = other._aspectRatio;
        this._yfov = other._yfov;
        this._xmag = other._xmag;
        this._ymag = other._ymag;
        return this;
    }
    /**********************************************************************************************
     * Common.
     */
    /** Specifies if the camera uses a perspective or orthographic projection. */
    getType() { return this._type; }
    /** Specifies if the camera uses a perspective or orthographic projection. */
    setType(type) {
        this._type = type;
        return this;
    }
    /** Floating-point distance to the near clipping plane. */
    getZNear() { return this._znear; }
    /** Floating-point distance to the near clipping plane. */
    setZNear(znear) {
        this._znear = znear;
        return this;
    }
    /**
     * Floating-point distance to the far clipping plane. When defined, zfar must be greater than
     * znear. If zfar is undefined, runtime must use infinite projection matrix.
     */
    getZFar() { return this._zfar; }
    /**
     * Floating-point distance to the far clipping plane. When defined, zfar must be greater than
     * znear. If zfar is undefined, runtime must use infinite projection matrix.
     */
    setZFar(zfar) {
        this._zfar = zfar;
        return this;
    }
    /**********************************************************************************************
     * Perspective.
     */
    /**
     * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the
     * canvas is used.
     */
    getAspectRatio() { return this._aspectRatio; }
    /**
     * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the
     * canvas is used.
     */
    setAspectRatio(aspectRatio) {
        this._aspectRatio = aspectRatio;
        return this;
    }
    /** Floating-point vertical field of view in radians. */
    getYFov() { return this._yfov; }
    /** Floating-point vertical field of view in radians. */
    setYFov(yfov) {
        this._yfov = yfov;
        return this;
    }
    /**********************************************************************************************
     * Orthographic.
     */
    /**
     * Floating-point horizontal magnification of the view, and half the view's width
     * in world units.
     */
    getXMag() { return this._xmag; }
    /**
     * Floating-point horizontal magnification of the view, and half the view's width
     * in world units.
     */
    setXMag(xmag) {
        this._xmag = xmag;
        return this;
    }
    /**
     * Floating-point vertical magnification of the view, and half the view's height
     * in world units.
     */
    getYMag() { return this._ymag; }
    /**
     * Floating-point vertical magnification of the view, and half the view's height
     * in world units.
     */
    setYMag(ymag) {
        this._ymag = ymag;
        return this;
    }
}
