var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PropertyType } from '../constants';
import { GraphChild, GraphChildList } from '../graph/index';
import { COPY_IDENTITY, Property } from './property';
/**
 * # Primitive
 *
 * *Primitives are individual GPU draw calls comprising a {@link Mesh}.*
 *
 * Meshes typically have only a single Primitive, although various cases may require more. Each
 * primitive may be assigned vertex attributes, morph target attributes, and a material. Any of
 * these properties should be reused among multiple primitives where feasible.
 *
 * Primitives cannot be moved independently of other primitives within the same mesh, except
 * through the use of morph targets and skinning. If independent movement or other runtime
 * behavior is necessary (like raycasting or collisions) prefer to assign each primitive to a
 * different mesh. The number of GPU draw calls is typically not unaffected by grouping or
 * ungrouping primitives to a mesh.
 *
 * Each primitive may optionally be deformed by one or more morph targets, stored in a
 * {@link PrimitiveTarget}.
 *
 * Usage:
 *
 * ```ts
 * const primitive = doc.createPrimitive()
 * 	.setAttribute('POSITION', positionAccessor)
 * 	.setAttribute('TEXCOORD_0', uvAccessor)
 * 	.setMaterial(material);
 * mesh.addPrimitive(primitive);
 * node.setMesh(mesh);
 * ```
 *
 * References:
 * - [glTF → Geometry](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry)
 *
 * @category Properties
 */
export class Primitive extends Property {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.PRIMITIVE;
        /** @hidden GPU draw mode. */
        this._mode = 4 /* TRIANGLES */;
        this.material = null;
        this.indices = null;
        this.attributes = [];
        this.targets = [];
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        this._mode = other._mode;
        if (other.indices)
            this.setIndices(resolve(other.indices.getChild()));
        if (other.material)
            this.setMaterial(resolve(other.material.getChild()));
        this.clearGraphChildList(this.attributes);
        other.listSemantics().forEach((semantic) => {
            this.setAttribute(semantic, resolve(other.getAttribute(semantic)));
        });
        this.clearGraphChildList(this.targets);
        other.targets.forEach((link) => this.addTarget(resolve(link.getChild())));
        return this;
    }
    /** Returns an {@link Accessor} with indices of vertices to be drawn. */
    getIndices() {
        return this.indices ? this.indices.getChild() : null;
    }
    /**
     * Sets an {@link Accessor} with indices of vertices to be drawn. In `TRIANGLES` draw mode,
     * each set of three indices define a triangle. The front face has a counter-clockwise (CCW)
     * winding order.
     */
    setIndices(indices) {
        this.indices = this.graph.linkIndex('index', this, indices);
        return this;
    }
    /** Returns a vertex attribute as an {@link Accessor}. */
    getAttribute(semantic) {
        const link = this.attributes.find((link) => link.semantic === semantic);
        return link ? link.getChild() : null;
    }
    /**
     * Sets a vertex attribute to an {@link Accessor}. All attributes must have the same vertex
     * count.
     */
    setAttribute(semantic, accessor) {
        // Remove previous attribute.
        const prevAccessor = this.getAttribute(semantic);
        if (prevAccessor)
            this.removeGraphChild(this.attributes, prevAccessor);
        // Stop if deleting the attribute.
        if (!accessor)
            return this;
        // Add next attribute.
        const link = this.graph.linkAttribute(semantic.toLowerCase(), this, accessor);
        link.semantic = semantic;
        return this.addGraphChild(this.attributes, link);
    }
    /**
     * Lists all vertex attribute {@link Accessor}s associated with the primitive, excluding any
     * attributes used for morph targets. For example, `[positionAccessor, normalAccessor,
     * uvAccessor]`. Order will be consistent with the order returned by {@link .listSemantics}().
     */
    listAttributes() {
        return this.attributes.map((link) => link.getChild());
    }
    /**
     * Lists all vertex attribute semantics associated with the primitive, excluding any semantics
     * used for morph targets. For example, `['POSITION', 'NORMAL', 'TEXCOORD_0']`. Order will be
     * consistent with the order returned by {@link .listAttributes}().
     */
    listSemantics() {
        return this.attributes.map((link) => link.semantic);
    }
    /** Returns the material used to render the primitive. */
    getMaterial() { return this.material ? this.material.getChild() : null; }
    /** Sets the material used to render the primitive. */
    setMaterial(material) {
        this.material = this.graph.link('material', this, material);
        return this;
    }
    /**
     * Returns the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.
     *
     * Reference:
     * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#primitivemode)
     */
    getMode() { return this._mode; }
    /**
     * Sets the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.
     *
     * Reference:
     * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#primitivemode)
     */
    setMode(mode) {
        this._mode = mode;
        return this;
    }
    /** Lists all morph targets associated with the primitive. */
    listTargets() {
        return this.targets.map((link) => link.getChild());
    }
    /**
     * Adds a morph target to the primitive. All primitives in the same mesh must have the same
     * number of targets.
     */
    addTarget(target) {
        this.addGraphChild(this.targets, this.graph.link('target', this, target));
        return this;
    }
    /**
     * Removes a morph target from the primitive. All primitives in the same mesh must have the same
     * number of targets.
     */
    removeTarget(target) {
        return this.removeGraphChild(this.targets, target);
    }
}
__decorate([
    GraphChild
], Primitive.prototype, "material", void 0);
__decorate([
    GraphChild
], Primitive.prototype, "indices", void 0);
__decorate([
    GraphChildList
], Primitive.prototype, "attributes", void 0);
__decorate([
    GraphChildList
], Primitive.prototype, "targets", void 0);
