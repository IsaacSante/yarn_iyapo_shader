var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PropertyType } from '../constants';
import { GraphChildList } from '../graph/index';
import { COPY_IDENTITY, Property } from './property';
/**
 * # PrimitiveTarget
 *
 * *Morph target or shape key used to deform one {@link Primitive} in a {@link Mesh}.*
 *
 * A PrimitiveTarget contains a `POSITION` attribute (and optionally `NORMAL` and `TANGENT`) that
 * can additively deform the base attributes on a {@link Mesh} {@link Primitive}. Vertex values
 * of `0, 0, 0` in the target will have no effect, whereas a value of `0, 1, 0` would offset that
 * vertex in the base geometry by y+=1. Morph targets can be fully or partially applied: their
 * default state is controlled by {@link Mesh.getWeights}, which can also be overridden for a
 * particular instantiation of a {@link Mesh}, using {@link Node.getWeights}.
 *
 * Reference:
 * - [glTF â†’ Morph Targets](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets)
 */
export class PrimitiveTarget extends Property {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.PRIMITIVE_TARGET;
        /** @hidden Vertex attributes. */
        this.attributes = [];
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        this.clearGraphChildList(this.attributes);
        other.listSemantics().forEach((semantic) => {
            this.setAttribute(semantic, resolve(other.getAttribute(semantic)));
        });
        return this;
    }
    /** Returns a morph target vertex attribute as an {@link Accessor}. */
    getAttribute(semantic) {
        const link = this.attributes.find((link) => link.semantic === semantic);
        return link ? link.getChild() : null;
    }
    /**
     * Sets a morph target vertex attribute to an {@link Accessor}.
     */
    setAttribute(semantic, accessor) {
        // Remove previous attribute.
        const prevAccessor = this.getAttribute(semantic);
        if (prevAccessor)
            this.removeGraphChild(this.attributes, prevAccessor);
        // Stop if deleting the attribute.
        if (!accessor)
            return this;
        // Add next attribute.
        const link = this.graph.linkAttribute(semantic.toLowerCase(), this, accessor);
        link.semantic = semantic;
        return this.addGraphChild(this.attributes, link);
    }
    /**
     * Lists all morph target vertex attribute {@link Accessor}s associated. Order will be
     * consistent with the order returned by {@link .listSemantics}().
     */
    listAttributes() {
        return this.attributes.map((link) => link.getChild());
    }
    /**
     * Lists all morph target vertex attribute semantics associated. Order will be
     * consistent with the order returned by {@link .listAttributes}().
     */
    listSemantics() {
        return this.attributes.map((link) => link.semantic);
    }
}
__decorate([
    GraphChildList
], PrimitiveTarget.prototype, "attributes", void 0);
