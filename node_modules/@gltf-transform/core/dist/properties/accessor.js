var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PropertyType } from '../constants';
import { GraphChild } from '../graph';
import { MathUtils } from '../utils';
import { ExtensibleProperty } from './extensible-property';
import { COPY_IDENTITY } from './property';
/**
 * # Accessor
 *
 * *Accessors store lists of numeric, vector, or matrix elements in a typed array.*
 *
 * All large data for {@link Mesh}, {@link Skin}, and {@link Animation} properties is stored in
 * {@link Accessor}s, organized into one or more {@link Buffer}s. Each accessor provides data in
 * typed arrays, with two abstractions:
 *
 * *Elements* are the logical divisions of the data into useful types: `"SCALAR"`, `"VEC2"`,
 * `"VEC3"`, `"VEC4"`, `"MAT3"`, or `"MAT4"`. The element type can be determined with the
 * {@link getType}() method, and the number of elements in the accessor determine its
 * {@link getCount}(). The number of components in an element — e.g. 9 for `"MAT3"` — are its
 * {@link getElementSize}().
 *
 * | `type`     | Components |
 * |:----------:|:----------:|
 * | `"SCALAR"` | 1          |
 * | `"VEC2"`   | 2          |
 * | `"VEC3"`   | 3          |
 * | `"VEC4"`   | 4          |
 * | `"MAT2"`   | 4          |
 * | `"MAT3"`   | 9          |
 * | `"MAT4"`   | 16         |
 *
 * *Components* are the numeric values within an element — e.g. `.x` and `.y` for `"VEC2"`. Various
 * component types are available: `BYTE`, `UNSIGNED_BYTE`, `SHORT`, `UNSIGNED_SHORT`,
 * `UNSIGNED_INT`, and `FLOAT`. The component type can be determined with the
 * {@link getComponentType} method, and the number of bytes in each component determine its
 * {@link getComponentSize}. Component types are identified by WebGL enum values, below.
 *
 * | `componentType`         | Bytes |
 * |:-----------------------:|:-----:|
 * | `5120` (BYTE)           | 1     |
 * | `5121` (UNSIGNED_BYTE)  | 1     |
 * | `5122` (SHORT)          | 2     |
 * | `5123` (UNSIGNED_SHORT) | 2     |
 * | `5125` (UNSIGNED_INT)   | 4     |
 * | `5126` (FLOAT)          | 4     |
 *
 * Usage:
 *
 * ```typescript
 * const accessor = doc.createAccessor('myData')
 * 	.setArray(new Float32Array([1,2,3,4,5,6,7,8,9,10,11,12]))
 * 	.setType('VEC3')
 * 	.setBuffer(doc.listBuffers()[0]);
 *
 * accessor.getCount();        // → 4
 * accessor.getElementSize();  // → 3
 * accessor.getByteLength();   // → 48
 * accessor.getElement(1, []); // → [4, 5, 6]
 *
 * accessor.setElement(0, [10, 20, 30]);
 * ```
 *
 * Data access through the {@link getElement} and {@link setElement} methods reads or overwrites
 * the content of the underlying typed array. These methods use element arrays intended to be
 * compatible with the [gl-matrix](https://github.com/toji/gl-matrix) library, or with the
 * `toArray`/`fromArray` methods of libraries like three.js and babylon.js.
 *
 * Each Accessor must be assigned to a {@link Buffer}, which determines where the accessor's data
 * is stored in the final file. Assigning Accessors to different Buffers allows the data to be
 * written to different `.bin` files.
 *
 * glTF-Transform does not expose many details of sparse, normalized, or interleaved accessors
 * through its API. It reads files using those techniques, presents a simplified view of the data
 * for editing, and attempts to write data back out with optimizations. For example, vertex
 * attributes will typically be interleaved by default, regardless of the input file.
 *
 * References:
 * - [glTF → Accessors](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors)
 *
 * @category Properties
 */
export class Accessor extends ExtensibleProperty {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.ACCESSOR;
        /** @hidden Raw data of the accessor. */
        this._array = null;
        /** @hidden Type of element represented. */
        this._type = "SCALAR" /* SCALAR */;
        /** @hidden Numeric type of each component in an element. */
        this._componentType = null;
        /** @hidden Whether data in the raw array should be considered normalized. */
        this._normalized = false;
        /** @hidden Inbound transform to normalized representation, if applicable. */
        this._in = MathUtils.identity;
        /** @hidden Outbound transform from normalized representation, if applicable. */
        this._out = MathUtils.identity;
        /** @hidden The {@link Buffer} to which this accessor's data will be written. */
        this.buffer = null;
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        this._array = other._array.slice();
        this._type = other._type;
        this._componentType = other._componentType;
        this._normalized = other._normalized;
        this._in = other._in;
        this._out = other._out;
        if (other.buffer)
            this.setBuffer(resolve(other.buffer.getChild()));
        return this;
    }
    /** Returns size of a given element type, in components. */
    static getElementSize(type) {
        switch (type) {
            case "SCALAR" /* SCALAR */: return 1;
            case "VEC2" /* VEC2 */: return 2;
            case "VEC3" /* VEC3 */: return 3;
            case "VEC4" /* VEC4 */: return 4;
            case "MAT2" /* MAT2 */: return 4;
            case "MAT3" /* MAT3 */: return 9;
            case "MAT4" /* MAT4 */: return 16;
            default:
                throw new Error('Unexpected type: ' + type);
        }
    }
    /** Returns size of a given component type, in bytes. */
    static getComponentSize(componentType) {
        switch (componentType) {
            case 5120 /* BYTE */: return 1;
            case 5121 /* UNSIGNED_BYTE */: return 1;
            case 5122 /* SHORT */: return 2;
            case 5123 /* UNSIGNED_SHORT */: return 2;
            case 5125 /* UNSIGNED_INT */: return 4;
            case 5126 /* FLOAT */: return 4;
            default:
                throw new Error('Unexpected component type: ' + componentType);
        }
    }
    /**********************************************************************************************
     * Min/max bounds.
     */
    /**
     * Minimum value of each component in this attribute. Unlike in a final glTF file, values
     * returned by this method will reflect the minimum accounting for {@link .normalized}
     * state.
     */
    getMinNormalized(target) {
        const elementSize = this.getElementSize();
        this.getMin(target);
        for (let j = 0; j < elementSize; j++)
            target[j] = this._out(target[j]);
        return target;
    }
    /**
     * Minimum value of each component in this attribute. Values returned by this method do not
     * reflect normalization: use {@link .getMinNormalized} in that case.
     */
    getMin(target) {
        const count = this.getCount();
        const elementSize = this.getElementSize();
        for (let j = 0; j < elementSize; j++)
            target[j] = Infinity;
        for (let i = 0; i < count * elementSize; i += elementSize) {
            for (let j = 0; j < elementSize; j++) {
                const value = this._array[i + j];
                if (Number.isFinite(value)) {
                    target[j] = Math.min(target[j], value);
                }
            }
        }
        return target;
    }
    /**
     * Maximum value of each component in this attribute. Unlike in a final glTF file, values
     * returned by this method will reflect the minimum accounting for {@link .normalized}
     * state.
     */
    getMaxNormalized(target) {
        const elementSize = this.getElementSize();
        this.getMax(target);
        for (let j = 0; j < elementSize; j++)
            target[j] = this._out(target[j]);
        return target;
    }
    /**
     * Maximum value of each component in this attribute. Values returned by this method do not
     * reflect normalization: use {@link .getMinNormalized} in that case.
     */
    getMax(target) {
        const count = this.getCount();
        const elementSize = this.getElementSize();
        for (let j = 0; j < elementSize; j++)
            target[j] = -Infinity;
        for (let i = 0; i < count * elementSize; i += elementSize) {
            for (let j = 0; j < elementSize; j++) {
                const value = this._array[i + j];
                if (Number.isFinite(value)) {
                    target[j] = Math.max(target[j], value);
                }
            }
        }
        return target;
    }
    /**********************************************************************************************
     * Layout.
     */
    /**
     * Number of elements in the accessor. An array of length 30, containing 10 `VEC3` elements,
     * will have a count of 10.
     */
    getCount() {
        return this._array.length / this.getElementSize();
    }
    /** Type of element stored in the accessor. `VEC2`, `VEC3`, etc. */
    getType() { return this._type; }
    /**
     * Sets type of element stored in the accessor. `VEC2`, `VEC3`, etc. Array length must be a
     * multiple of the component size (`VEC2` = 2, `VEC3` = 3, ...) for the selected type.
     */
    setType(type) {
        this._type = type;
        return this;
    }
    /**
     * Number of components in each element of the accessor. For example, the element size of a
     * `VEC2` accessor is 2. This value is determined automatically based on array length and
     * accessor type, specified with {@link setType}().
     */
    getElementSize() {
        return Accessor.getElementSize(this._type);
    }
    /**
     * Size of each component (a value in the raw array), in bytes. For example, the
     * `componentSize` of data backed by a `float32` array is 4 bytes.
     */
    getComponentSize() {
        return this._array.BYTES_PER_ELEMENT;
    }
    /**
     * Component type (float32, uint16, etc.). This value is determined automatically, and can only
     * be modified by replacing the underlying array.
     */
    getComponentType() {
        return this._componentType;
    }
    /**********************************************************************************************
     * Normalization.
     */
    /**
     * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned
     * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.
     * This property is defined only for accessors that contain vertex attributes or animation
     * output data.
     */
    getNormalized() { return this._normalized; }
    /**
     * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned
     * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.
     * This property is defined only for accessors that contain vertex attributes or animation
     * output data.
     */
    setNormalized(normalized) {
        this._normalized = normalized;
        if (normalized) {
            this._out = (c) => MathUtils.denormalize(c, this._componentType);
            this._in = (f) => MathUtils.normalize(f, this._componentType);
        }
        else {
            this._out = MathUtils.identity;
            this._in = MathUtils.identity;
        }
        return this;
    }
    /**********************************************************************************************
     * Data access.
     */
    /**
     * Returns the scalar element value at the given index, accounting for normalization if
     * applicable.
     */
    getScalar(index) {
        const elementSize = this.getElementSize();
        return this._out(this._array[index * elementSize]);
    }
    /**
     * Assigns the scalar element value at the given index, accounting for normalization if
     * applicable.
     */
    setScalar(index, x) {
        this._array[index * this.getElementSize()] = this._in(x);
        return this;
    }
    /**
     * Returns the vector or matrix element value at the given index, accounting for normalization
     * if applicable.
     */
    getElement(index, target) {
        const elementSize = this.getElementSize();
        for (let i = 0; i < elementSize; i++) {
            target[i] = this._out(this._array[index * elementSize + i]);
        }
        return target;
    }
    /**
     * Assigns the vector or matrix element value at the given index, accounting for normalization
     * if applicable.
     */
    setElement(index, value) {
        const elementSize = this.getElementSize();
        for (let i = 0; i < elementSize; i++) {
            this._array[index * elementSize + i] = this._in(value[i]);
        }
        return this;
    }
    /**********************************************************************************************
     * Raw data storage.
     */
    /** Returns the {@link Buffer} into which this accessor will be organized. */
    getBuffer() { return this.buffer ? this.buffer.getChild() : null; }
    /** Assigns the {@link Buffer} into which this accessor will be organized. */
    setBuffer(buffer) {
        this.buffer = this.graph.link('buffer', this, buffer);
        return this;
    }
    /** Returns the raw typed array underlying this accessor. */
    getArray() { return this._array; }
    /** Assigns the raw typed array underlying this accessor. */
    setArray(array) {
        this._componentType = arrayToComponentType(array);
        this._array = array;
        return this;
    }
    /** Returns the total bytelength of this accessor, exclusive of padding. */
    getByteLength() {
        return this._array.byteLength;
    }
}
/**********************************************************************************************
 * Static.
 */
/** Supported element types. */
Accessor.Type = {
    SCALAR: "SCALAR" /* SCALAR */,
    VEC2: "VEC2" /* VEC2 */,
    VEC3: "VEC3" /* VEC3 */,
    VEC4: "VEC4" /* VEC4 */,
    MAT3: "MAT3" /* MAT3 */,
    MAT4: "MAT4" /* MAT4 */,
};
/** Supported component types. */
Accessor.ComponentType = {
    BYTE: 5120 /* BYTE */,
    UNSIGNED_BYTE: 5121 /* UNSIGNED_BYTE */,
    SHORT: 5122 /* SHORT */,
    UNSIGNED_SHORT: 5123 /* UNSIGNED_SHORT */,
    UNSIGNED_INT: 5125 /* UNSIGNED_INT */,
    FLOAT: 5126 /* FLOAT */,
};
__decorate([
    GraphChild
], Accessor.prototype, "buffer", void 0);
/**************************************************************************************************
 * Array utilities.
 */
/** @hidden */
function arrayToComponentType(array) {
    switch (array.constructor) {
        case Float32Array:
            return 5126 /* FLOAT */;
        case Uint32Array:
            return 5125 /* UNSIGNED_INT */;
        case Uint16Array:
            return 5123 /* UNSIGNED_SHORT */;
        case Uint8Array:
            return 5121 /* UNSIGNED_BYTE */;
        case Int16Array:
            return 5122 /* SHORT */;
        case Int8Array:
            return 5120 /* BYTE */;
        default:
            throw new Error('Unknown accessor componentType.');
    }
}
