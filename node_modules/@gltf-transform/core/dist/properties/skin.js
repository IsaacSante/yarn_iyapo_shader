var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PropertyType } from '../constants';
import { GraphChild, GraphChildList } from '../graph';
import { ExtensibleProperty } from './extensible-property';
import { COPY_IDENTITY } from './property';
/**
 * # Skin
 *
 * *Collection of {@link Node} joints and inverse bind matrices used with skinned {@link Mesh}
 * instances.*
 *
 * Reference
 * - [glTF â†’ Skins](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#skins)
 *
 * @category Properties
 */
export class Skin extends ExtensibleProperty {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.SKIN;
        this.skeleton = null;
        this.inverseBindMatrices = null;
        this.joints = [];
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        if (other.skeleton)
            this.setSkeleton(resolve(other.skeleton.getChild()));
        if (other.inverseBindMatrices)
            this.setInverseBindMatrices(resolve(other.inverseBindMatrices.getChild()));
        this.clearGraphChildList(this.joints);
        other.joints.forEach((link) => this.addJoint(resolve(link.getChild())));
        return this;
    }
    /**
     * {@link Node} used as a skeleton root. The node must be the closest common root of the joints
     * hierarchy or a direct or indirect parent node of the closest common root.
     */
    getSkeleton() {
        return this.skeleton ? this.skeleton.getChild() : null;
    }
    /**
     * {@link Node} used as a skeleton root. The node must be the closest common root of the joints
     * hierarchy or a direct or indirect parent node of the closest common root.
     */
    setSkeleton(skeleton) {
        this.skeleton = this.graph.link('skeleton', this, skeleton);
        return this;
    }
    /**
     * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is
     * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were
     * pre-applied.
     */
    getInverseBindMatrices() {
        return this.inverseBindMatrices ? this.inverseBindMatrices.getChild() : null;
    }
    /**
     * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is
     * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were
     * pre-applied.
     */
    setInverseBindMatrices(inverseBindMatrices) {
        this.inverseBindMatrices = this.graph.link('inverseBindMatrices', this, inverseBindMatrices);
        return this;
    }
    /** Adds a joint {@link Node} to this {@link Skin}. */
    addJoint(joint) {
        const link = this.graph.link('joint', this, joint);
        return this.addGraphChild(this.joints, link);
    }
    /** Removes a joint {@link Node} from this {@link Skin}. */
    removeJoint(joint) {
        return this.removeGraphChild(this.joints, joint);
    }
    /** Lists joints ({@link Node}s used as joints or bones) in this {@link Skin}. */
    listJoints() {
        return this.joints.map((link) => link.getChild());
    }
}
__decorate([
    GraphChild
], Skin.prototype, "skeleton", void 0);
__decorate([
    GraphChild
], Skin.prototype, "inverseBindMatrices", void 0);
__decorate([
    GraphChildList
], Skin.prototype, "joints", void 0);
