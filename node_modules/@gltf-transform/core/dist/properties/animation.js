var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PropertyType } from '../constants';
import { GraphChildList } from '../graph';
import { ExtensibleProperty } from './extensible-property';
import { COPY_IDENTITY } from './property';
/**
 * # Animation
 *
 * *Reusable collections of {@link AnimationChannel}s, together representing a discrete animation
 * clip.*
 *
 * One Animation represents one playable unit in an animation system. Each may contain channels
 * affecting multiple paths (`translation`, `rotation`, `scale`, or `weights`) on multiple
 * {@link Node}s. An Animation's channels must be played together, and do not have any meaning in
 * isolation.
 *
 * Multiple Animations _may_ be played together: for example, one character's _Walk_ animation
 * might play while another character's _Run_ animation plays. Or a single character might have
 * both an _Idle_ and a _Talk_ animation playing at the same time. However, glTF does not define
 * any particular relationship between top-level Animations, or any particular playback behavior
 * like looping or sequences of Animations. General-purpose viewers typically autoplay the first
 * animation and provide UI controls for choosing another. Game engines may have significantly
 * more advanced methods of playing and blending animations.
 *
 * For example, a very simple skinned {@link Mesh} might have two Animations, _Idle_ and _Walk_.
 * Each of those Animations might affect the rotations of two bones, _LegL_ and _LegR_, where the
 * keyframes for each target-path pair are stored in {@link AnimationChannel} instances. In  total,
 * this model would contain two Animations and Four {@link AnimationChannel}s.
 *
 * Usage:
 *
 * ```ts
 * const animation = doc.createAnimation('machineRun')
 * 	.addChannel(rotateCog1)
 * 	.addChannel(rotateCog2)
 * 	.addChannel(rotateCog3);
 * ```
 *
 * Reference
 * - [glTF â†’ Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)
 */
export class Animation extends ExtensibleProperty {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.ANIMATION;
        this.channels = [];
        this.samplers = [];
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        this.clearGraphChildList(this.channels);
        this.clearGraphChildList(this.samplers);
        other.channels.forEach((link) => this.addChannel(resolve(link.getChild())));
        other.samplers.forEach((link) => this.addSampler(resolve(link.getChild())));
        return this;
    }
    /** Adds an {@link AnimationChannel} to this Animation. */
    addChannel(channel) {
        const link = this.graph.link('channel', this, channel);
        return this.addGraphChild(this.channels, link);
    }
    /** Removes an {@link AnimationChannel} from this Animation. */
    removeChannel(channel) {
        return this.removeGraphChild(this.channels, channel);
    }
    /** Lists {@link AnimationChannel}s in this Animation. */
    listChannels() {
        return this.channels.map((link) => link.getChild());
    }
    /** Adds an {@link AnimationSampler} to this Animation. */
    addSampler(sampler) {
        const link = this.graph.link('sampler', this, sampler);
        return this.addGraphChild(this.samplers, link);
    }
    /** Removes an {@link AnimationSampler} from this Animation. */
    removeSampler(sampler) {
        return this.removeGraphChild(this.samplers, sampler);
    }
    /** Lists {@link AnimationSampler}s in this Animation. */
    listSamplers() {
        return this.samplers.map((link) => link.getChild());
    }
}
__decorate([
    GraphChildList
], Animation.prototype, "channels", void 0);
__decorate([
    GraphChildList
], Animation.prototype, "samplers", void 0);
