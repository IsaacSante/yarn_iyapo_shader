var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PropertyType, VERSION } from '../constants';
import { GraphChildList } from '../graph/index';
import { COPY_IDENTITY, Property } from './property';
/**
 * # Root
 *
 * *Root property of a glTF asset.*
 *
 * Any properties to be exported with a particular asset must be referenced (directly or
 * indirectly) by the root. Metadata about the asset's license, generator, and glTF specification
 * version are stored in the asset, accessible with {@link .getAsset}().
 *
 * Properties are added to the root with factory methods on its {@link Document}, and removed by
 * calling {@link Property.dispose}() on the resource. Any properties that have been created but
 * not disposed will be included when calling the various `root.list*()` methods.
 *
 * A document's root cannot be removed, and no other root may be created. Unlike other
 * {@link Property} types, the `.dispose()`, `.detach()` methods have no useful function on a
 * Root property.
 *
 * Usage:
 *
 * ```ts
 * const root = document.getRoot();
 * const scene = document.createScene('myScene');
 * const node = document.createNode('myNode');
 * scene.addChild(node);
 *
 * console.log(root.listScenes()); // → [scene x 1]
 * ```
 *
 * Reference: [glTF → Concepts](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#concepts)
 *
 * @category Properties
 */
export class Root extends Property {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.ROOT;
        this._asset = {
            generator: `glTF-Transform ${VERSION}`,
            version: '2.0'
        };
        this._extensions = new Set();
        this.accessors = [];
        this.animations = [];
        this.buffers = [];
        this.cameras = [];
        this.materials = [];
        this.meshes = [];
        this.nodes = [];
        this.scenes = [];
        this.skins = [];
        this.textures = [];
    }
    clone() {
        throw new Error('Root cannot be cloned.');
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        // Root cannot be cloned in isolation: only with its Document. Extensions are managed by
        // the Document during cloning. The Root, and only the Root, should avoid calling
        // .clearGraphChildList() while copying to avoid overwriting existing links during a merge.
        if (!resolve)
            throw new Error('Root cannot be copied.');
        Object.assign(this._asset, other._asset);
        other.accessors.forEach((link) => this._addAccessor(resolve(link.getChild())));
        other.animations.forEach((link) => this._addAnimation(resolve(link.getChild())));
        other.buffers.forEach((link) => this._addBuffer(resolve(link.getChild())));
        other.cameras.forEach((link) => this._addCamera(resolve(link.getChild())));
        other.materials.forEach((link) => this._addMaterial(resolve(link.getChild())));
        other.meshes.forEach((link) => this._addMesh(resolve(link.getChild())));
        other.nodes.forEach((link) => this._addNode(resolve(link.getChild())));
        other.scenes.forEach((link) => this._addScene(resolve(link.getChild())));
        other.skins.forEach((link) => this._addSkin(resolve(link.getChild())));
        other.textures.forEach((link) => this._addTexture(resolve(link.getChild())));
        return this;
    }
    /**
     * Returns the `asset` object, which specifies the target glTF version of the asset. Additional
     * metadata can be stored in optional properties such as `generator` or `copyright`.
     *
     * Reference: [glTF → Asset](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#asset)
     */
    getAsset() { return this._asset; }
    /**********************************************************************************************
     * Extensions.
     */
    /** Lists all {@link Extension} properties enabled for this root. */
    listExtensionsUsed() {
        return Array.from(this._extensions);
    }
    /** Lists all {@link Extension} properties enabled and required for this root. */
    listExtensionsRequired() {
        return this.listExtensionsUsed().filter((extension) => extension.isRequired());
    }
    /** @hidden */
    _enableExtension(extension) {
        if (this._extensions.has(extension)) {
            throw new Error(`Extension "${extension.extensionName}" is already enabled.`);
        }
        this._extensions.add(extension);
        return this;
    }
    /** @hidden */
    _disableExtension(extension) {
        this._extensions.delete(extension);
        return this;
    }
    /**********************************************************************************************
     * Scenes.
     */
    /**
     * Adds a new {@link Scene} to the root list.
     * @hidden
     */
    _addScene(scene) {
        return this.addGraphChild(this.scenes, this.graph.link('scene', this, scene));
    }
    /** Lists all {@link Scene} properties associated with this root. */
    listScenes() {
        return this.scenes.map((p) => p.getChild());
    }
    /**********************************************************************************************
     * Nodes.
     */
    /**
     * Adds a new {@link Node} to the root list.
     * @hidden
     */
    _addNode(node) {
        return this.addGraphChild(this.nodes, this.graph.link('node', this, node));
    }
    /** Lists all {@link Node} properties associated with this root. */
    listNodes() {
        return this.nodes.map((p) => p.getChild());
    }
    /**********************************************************************************************
     * Cameras.
     */
    /**
     * Adds a new {@link Camera} to the root list.
     * @hidden
     */
    _addCamera(camera) {
        return this.addGraphChild(this.cameras, this.graph.link('camera', this, camera));
    }
    /** Lists all {@link Camera} properties associated with this root. */
    listCameras() {
        return this.cameras.map((p) => p.getChild());
    }
    /**********************************************************************************************
     * Skins.
     */
    /**
     * Adds a new {@link Skin} to the root list.
     * @hidden
     */
    _addSkin(skin) {
        return this.addGraphChild(this.skins, this.graph.link('skin', this, skin));
    }
    /** Lists all {@link Skin} properties associated with this root. */
    listSkins() {
        return this.skins.map((p) => p.getChild());
    }
    /**********************************************************************************************
     * Meshes.
     */
    /**
     * Adds a new {@link Mesh} to the root list.
     * @hidden
     */
    _addMesh(mesh) {
        return this.addGraphChild(this.meshes, this.graph.link('mesh', this, mesh));
    }
    /** Lists all {@link Mesh} properties associated with this root. */
    listMeshes() {
        return this.meshes.map((p) => p.getChild());
    }
    /**********************************************************************************************
     * Materials.
     */
    /**
     * Adds a new {@link Material} to the root list.
     * @hidden
     */
    _addMaterial(material) {
        return this.addGraphChild(this.materials, this.graph.link('material', this, material));
    }
    /** Lists all {@link Material} properties associated with this root. */
    listMaterials() {
        return this.materials.map((p) => p.getChild());
    }
    /**********************************************************************************************
     * Textures.
     */
    /**
     * Adds a new {@link Texture} to the root list.
     * @hidden
     */
    _addTexture(texture) {
        return this.addGraphChild(this.textures, this.graph.link('texture', this, texture));
    }
    /** Lists all {@link Texture} properties associated with this root. */
    listTextures() {
        return this.textures.map((p) => p.getChild());
    }
    /**********************************************************************************************
     * Animations.
     */
    /**
     * Adds a new {@link Animation} to the root list.
     * @hidden
     */
    _addAnimation(animation) {
        return this.addGraphChild(this.animations, this.graph.link('animation', this, animation));
    }
    /** Lists all {@link Animation} properties associated with this root. */
    listAnimations() {
        return this.animations.map((p) => p.getChild());
    }
    /**********************************************************************************************
     * Accessors.
     */
    /**
     * Adds a new {@link Accessor} to the root list.
     * @hidden
     */
    _addAccessor(accessor) {
        return this.addGraphChild(this.accessors, this.graph.link('accessor', this, accessor));
    }
    /** Lists all {@link Accessor} properties associated with this root. */
    listAccessors() {
        return this.accessors.map((p) => p.getChild());
    }
    /**********************************************************************************************
     * Buffers.
     */
    /**
     * Adds a new {@link Buffer} to the root list.
     * @hidden
     */
    _addBuffer(buffer) {
        return this.addGraphChild(this.buffers, this.graph.link('buffer', this, buffer));
    }
    /** Lists all {@link Buffer} properties associated with this root. */
    listBuffers() {
        return this.buffers.map((p) => p.getChild());
    }
}
__decorate([
    GraphChildList
], Root.prototype, "accessors", void 0);
__decorate([
    GraphChildList
], Root.prototype, "animations", void 0);
__decorate([
    GraphChildList
], Root.prototype, "buffers", void 0);
__decorate([
    GraphChildList
], Root.prototype, "cameras", void 0);
__decorate([
    GraphChildList
], Root.prototype, "materials", void 0);
__decorate([
    GraphChildList
], Root.prototype, "meshes", void 0);
__decorate([
    GraphChildList
], Root.prototype, "nodes", void 0);
__decorate([
    GraphChildList
], Root.prototype, "scenes", void 0);
__decorate([
    GraphChildList
], Root.prototype, "skins", void 0);
__decorate([
    GraphChildList
], Root.prototype, "textures", void 0);
