var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PropertyType } from '../constants';
import { GraphChild } from '../graph/index';
import { ColorUtils } from '../utils';
import { ExtensibleProperty } from './extensible-property';
import { COPY_IDENTITY } from './property';
/**
 * # Material
 *
 * *Materials describe a surface's appearance and response to light.*
 *
 * Each {@link Primitive} within a {@link Mesh} may be assigned a single Material. The number of
 * GPU draw calls typically increases with both the numbers of Primitives and of Materials in an
 * asset; Materials should be reused wherever possible. Techniques like texture atlasing and vertex
 * colors allow objects to have varied appearances while technically sharing a single Material.
 *
 * Material properties are modified by both scalars (like `baseColorFactor`) and textures (like
 * `baseColorTexture`). When both are available, factors are considered linear multipliers against
 * textures of the same name. In the case of base color, vertex colors (`COLOR_0` attributes) are
 * also multiplied.
 *
 * Textures containing color data (`baseColorTexture`, `emissiveTexture`) are sRGB. All other
 * textures are linear. Like other resources, textures should be reused when possible.
 *
 * Usage:
 *
 * ```typescript
 * const material = doc.createMaterial('myMaterial')
 * 	.setBaseColorFactor([1, 0.5, 0.5, 1]) // RGBA
 * 	.setOcclusionTexture(aoTexture)
 * 	.setOcclusionStrength(0.5);
 *
 * mesh.listPrimitives()
 * 	.forEach((prim) => prim.setMaterial(material));
 * ```
 *
 * @category Properties
 */
export class Material extends ExtensibleProperty {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.MATERIAL;
        /** @hidden Mode of the material's alpha channels. (`OPAQUE`, `BLEND`, or `MASK`) */
        this._alphaMode = "OPAQUE" /* OPAQUE */;
        /** @hidden Visibility threshold. Applied only when `.alphaMode='MASK'`. */
        this._alphaCutoff = 0.5;
        /** @hidden When true, both sides of each triangle are rendered. May decrease performance. */
        this._doubleSided = false;
        /** @hidden Base color / albedo; linear multiplier. */
        this._baseColorFactor = [1, 1, 1, 1];
        /** @hidden Emissive color; linear multiplier. */
        this._emissiveFactor = [0, 0, 0];
        /** @hidden Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */
        this._normalScale = 1;
        /** @hidden (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionMap`. */
        this._occlusionStrength = 1;
        /**
         * Roughness factor; linear multiplier. Affects roughness channel of
         * `metallicRoughnessTexture`.
         * @hidden
         */
        this._roughnessFactor = 1;
        /**
         * Metallic factor; linear multiplier. Affects metallic channel of
         * `metallicRoughnessTexture`.
         * @hidden
         */
        this._metallicFactor = 1;
        /** @hidden Base color / albedo texture. */
        this.baseColorTexture = null;
        /** @hidden Emissive texture. */
        this.emissiveTexture = null;
        /**
         * Normal (surface detail) texture. Normal maps often suffer artifacts with JPEG compression,
         * so PNG files are preferred.
         * @hidden
         */
        this.normalTexture = null;
        /**
         * (Ambient) Occlusion texture. Occlusion data is stored in the `.r` channel, allowing this
         * texture to be packed with `metallicRoughnessTexture`, optionally.
         * @hidden
         */
        this.occlusionTexture = null;
        /**
         * Metallic/roughness PBR texture. Roughness data is stored in the `.g` channel and metallic
         * data is stored in the `.b` channel, allowing thist exture to be packed with
         * `occlusionTexture`, optionally.
         * @hidden
        */
        this.metallicRoughnessTexture = null;
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        this._alphaMode = other._alphaMode;
        this._alphaCutoff = other._alphaCutoff;
        this._doubleSided = other._doubleSided;
        this._baseColorFactor = [...other._baseColorFactor];
        this._emissiveFactor = [...other._emissiveFactor];
        this._normalScale = other._normalScale;
        this._occlusionStrength = other._occlusionStrength;
        this._roughnessFactor = other._roughnessFactor;
        this._metallicFactor = other._metallicFactor;
        if (other.baseColorTexture) {
            this.setBaseColorTexture(resolve(other.baseColorTexture.getChild()));
            this.baseColorTexture.copy(other.baseColorTexture);
        }
        if (other.emissiveTexture) {
            this.setEmissiveTexture(resolve(other.emissiveTexture.getChild()));
            this.emissiveTexture.copy(other.emissiveTexture);
        }
        if (other.normalTexture) {
            this.setNormalTexture(resolve(other.normalTexture.getChild()));
            this.normalTexture.copy(other.normalTexture);
        }
        if (other.occlusionTexture) {
            this.setOcclusionTexture(resolve(other.occlusionTexture.getChild()));
            this.occlusionTexture.copy(other.occlusionTexture);
        }
        if (other.metallicRoughnessTexture) {
            this.setMetallicRoughnessTexture(resolve(other.metallicRoughnessTexture.getChild()));
            this.metallicRoughnessTexture.copy(other.metallicRoughnessTexture);
        }
        return this;
    }
    /**********************************************************************************************
     * Double-sided / culling.
     */
    /** Returns true when both sides of triangles should be rendered. May impact performance. */
    getDoubleSided() { return this._doubleSided; }
    /** Sets whether to render both sides of triangles. May impact performance. */
    setDoubleSided(doubleSided) {
        this._doubleSided = doubleSided;
        return this;
    }
    /**********************************************************************************************
     * Alpha.
     */
    /** Returns material alpha, equivalent to baseColorFactor[3]. */
    getAlpha() { return this._baseColorFactor[3]; }
    /** Sets material alpha, equivalent to baseColorFactor[3]. */
    setAlpha(alpha) {
        this._baseColorFactor[3] = alpha;
        return this;
    }
    /**
     * Returns the mode of the material's alpha channels, which are provided by `baseColorFactor`
     * and `baseColorTexture`.
     *
     * - `OPAQUE`: Alpha value is ignored and the rendered output is fully opaque.
     * - `BLEND`: Alpha value is used to determine the transparency each pixel on a surface, and
     * 	the fraction of surface vs. background color in the final result. Alpha blending creates
     *	significant edge cases in realtime renderers, and some care when structuring the model is
     * 	necessary for good results. In particular, transparent geometry should be kept in separate
     * 	meshes or primitives from opaque geometry. The `depthWrite` or `zWrite` settings in engines
     * 	should usually be disabled on transparent materials.
     * - `MASK`: Alpha value is compared against `alphaCutoff` threshold for each pixel on a
     * 	surface, and the pixel is either fully visible or fully discarded based on that cutoff.
     * 	This technique is useful for things like leafs/foliage, grass, fabric meshes, and other
     * 	surfaces where no semitransparency is needed. With a good choice of `alphaCutoff`, surfaces
     * 	that don't require semitransparency can avoid the performance penalties and visual issues
     * 	involved with `BLEND` transparency.
     *
     * Reference:
     * - [glTF → material.alphaMode](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialalphamode)
     */
    getAlphaMode() { return this._alphaMode; }
    /** Sets the mode of the material's alpha channels. See {@link getAlphaMode} for details. */
    setAlphaMode(alphaMode) {
        this._alphaMode = alphaMode;
        return this;
    }
    /** Returns the visibility threshold; applied only when `.alphaMode='MASK'`. */
    getAlphaCutoff() { return this._alphaCutoff; }
    /** Sets the visibility threshold; applied only when `.alphaMode='MASK'`. */
    setAlphaCutoff(alphaCutoff) {
        this._alphaCutoff = alphaCutoff;
        return this;
    }
    /**********************************************************************************************
     * Base color.
     */
    /** Base color / albedo factor in linear space. See {@link getBaseColorTexture}. */
    getBaseColorFactor() { return this._baseColorFactor; }
    /** Sets the base color / albedo factor in linear space. See {@link getBaseColorTexture}. */
    setBaseColorFactor(baseColorFactor) {
        this._baseColorFactor = baseColorFactor;
        return this;
    }
    /**
     * Base color / albedo as hexadecimal in sRGB colorspace. Converted automatically from
     * baseColorFactor in linear space. See {@link getBaseColorTexture}.
     */
    getBaseColorHex() {
        return ColorUtils.factorToHex(this._baseColorFactor);
    }
    /**
     * Sets base color / albedo as hexadecimal in sRGB colorspace. Converted automatically to
     * baseColorFactor in linear space. See {@link getBaseColorTexture}.
     */
    setBaseColorHex(hex) {
        ColorUtils.hexToFactor(hex, this._baseColorFactor);
        return this;
    }
    /**
     * Base color / albedo. The visible color of a non-metallic surface under constant ambient
     * light would be a linear combination (multiplication) of its vertex colors, base color
     * factor, and base color texture. Lighting, and reflections in metallic or smooth surfaces,
     * also effect the final color. The alpha (`.a`) channel of base color factors and textures
     * will have varying effects, based on the setting of {@link getAlphaMode}.
     *
     * Reference:
     * - [glTF → material.pbrMetallicRoughness.baseColorFactor](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#pbrmetallicroughnessbasecolorfactor)
     */
    getBaseColorTexture() {
        return this.baseColorTexture ? this.baseColorTexture.getChild() : null;
    }
    /**
     * Settings affecting the material's use of its base color texture. If no texture is attached,
     * {@link TextureInfo} is `null`.
     */
    getBaseColorTextureInfo() {
        return this.baseColorTexture ? this.baseColorTexture.textureInfo : null;
    }
    /**
     * Settings affecting the material's use of its base color texture. If no texture is attached,
     * {@link TextureSampler} is `null`.
     */
    getBaseColorTextureSampler() {
        return this.baseColorTexture ? this.baseColorTexture.sampler : null;
    }
    /** Sets base color / albedo texture. See {@link getBaseColorTexture}. */
    setBaseColorTexture(texture) {
        this.baseColorTexture = this.graph.linkTexture('baseColorTexture', this, texture);
        return this;
    }
    /**********************************************************************************************
     * Emissive.
     */
    /** Emissive color; linear multiplier. See {@link getEmissiveTexture}. */
    getEmissiveFactor() { return this._emissiveFactor; }
    /** Sets the emissive color; linear multiplier. See {@link getEmissiveTexture}. */
    setEmissiveFactor(emissiveFactor) {
        this._emissiveFactor = emissiveFactor;
        return this;
    }
    /**
     * Emissive as hexadecimal in sRGB colorspace. Converted automatically from
     * emissiveFactor in linear space. See {@link getBaseColorTexture}.
     */
    getEmissiveHex() {
        return ColorUtils.factorToHex(this._emissiveFactor);
    }
    /**
     * Sets emissive as hexadecimal in sRGB colorspace. Converted automatically to
     * emissiveFactor in linear space. See {@link getEmissiveTexture}.
     */
    setEmissiveHex(hex) {
        ColorUtils.hexToFactor(hex, this._emissiveFactor);
        return this;
    }
    /**
     * Emissive texture. Emissive color is added to any base color of the material, after any
     * lighting/shadowing are applied. An emissive color does not inherently "glow", or affect
     * objects around it at all. To create that effect, most viewers must also enable a
     * post-processing effect called "bloom".
     *
     * Reference:
     * - [glTF → material.emissiveTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialemissivetexture)
     */
    getEmissiveTexture() {
        return this.emissiveTexture ? this.emissiveTexture.getChild() : null;
    }
    /**
     * Settings affecting the material's use of its emissive texture. If no texture is attached,
     * {@link TextureInfo} is `null`.
     */
    getEmissiveTextureInfo() {
        return this.emissiveTexture ? this.emissiveTexture.textureInfo : null;
    }
    /**
     * Settings affecting the material's use of its emissive texture. If no texture is attached,
     * {@link TextureSampler} is `null`.
     */
    getEmissiveTextureSampler() {
        return this.emissiveTexture ? this.emissiveTexture.sampler : null;
    }
    /** Sets emissive texture. See {@link getEmissiveTexture}. */
    setEmissiveTexture(texture) {
        this.emissiveTexture = this.graph.linkTexture('emissiveTexture', this, texture);
        return this;
    }
    /**********************************************************************************************
     * Normal.
     */
    /** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */
    getNormalScale() { return this._normalScale; }
    /** Sets normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */
    setNormalScale(normalScale) {
        this._normalScale = normalScale;
        return this;
    }
    /**
     * Normal (surface detail) texture.
     *
     * A tangent space normal map. The texture contains RGB components in linear space. Each texel
     * represents the XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X
     * [-1 to 1]. Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1].
     * The normal vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward
     * the viewer.
     *
     * Reference:
     * - [glTF → material.normalTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialnormaltexture)
     */
    getNormalTexture() {
        return this.normalTexture ? this.normalTexture.getChild() : null;
    }
    /**
     * Settings affecting the material's use of its normal texture. If no texture is attached,
     * {@link TextureInfo} is `null`.
     */
    getNormalTextureInfo() {
        return this.normalTexture ? this.normalTexture.textureInfo : null;
    }
    /**
     * Settings affecting the material's use of its normal texture. If no texture is attached,
     * {@link TextureSampler} is `null`.
     */
    getNormalTextureSampler() {
        return this.normalTexture ? this.normalTexture.sampler : null;
    }
    /** Sets normal (surface detail) texture. See {@link getNormalTexture}. */
    setNormalTexture(texture) {
        this.normalTexture = this.graph.linkTexture('normalTexture', this, texture);
        return this;
    }
    /**********************************************************************************************
     * Occlusion.
     */
    /** (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionTexture`. */
    getOcclusionStrength() { return this._occlusionStrength; }
    /** Sets (ambient) occlusion factor; linear multiplier. Affects `.occlusionTexture`. */
    setOcclusionStrength(occlusionStrength) {
        this._occlusionStrength = occlusionStrength;
        return this;
    }
    /**
     * (Ambient) Occlusion texture, generally used for subtle 'baked' shadowing effects that are
     * independent of an object's position, such as shading in inset areas and corners. Direct
     * lighting is not affected by occlusion, so at least one indirect light source must be present
     * in the scene for occlusion effects to be visible.
     *
     * The occlusion values are sampled from the R channel. Higher values indicate areas that
     * should receive full indirect lighting and lower values indicate no indirect lighting.
     *
     * Reference:
     * - [glTF → material.occlusionTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialocclusiontexture)
     */
    getOcclusionTexture() {
        return this.occlusionTexture ? this.occlusionTexture.getChild() : null;
    }
    /**
     * Settings affecting the material's use of its occlusion texture. If no texture is attached,
     * {@link TextureInfo} is `null`.
     */
    getOcclusionTextureInfo() {
        return this.occlusionTexture ? this.occlusionTexture.textureInfo : null;
    }
    /**
     * Settings affecting the material's use of its occlusion texture. If no texture is attached,
     * {@link TextureSampler} is `null`.
     */
    getOcclusionTextureSampler() {
        return this.occlusionTexture ? this.occlusionTexture.sampler : null;
    }
    /** Sets (ambient) occlusion texture. See {@link getOcclusionTexture}. */
    setOcclusionTexture(texture) {
        this.occlusionTexture = this.graph.linkTexture('occlusionTexture', this, texture);
        return this;
    }
    /**********************************************************************************************
     * Metallic / roughness.
     */
    /**
     * Roughness factor; linear multiplier. Affects roughness channel of
     * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.
     */
    getRoughnessFactor() { return this._roughnessFactor; }
    /**
     * Sets roughness factor; linear multiplier. Affects roughness channel of
     * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.
     */
    setRoughnessFactor(roughnessFactor) {
        this._roughnessFactor = roughnessFactor;
        return this;
    }
    /**
     * Metallic factor; linear multiplier. Affects roughness channel of
     * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.
     */
    getMetallicFactor() { return this._metallicFactor; }
    /**
     * Sets metallic factor; linear multiplier. Affects roughness channel of
     * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.
     */
    setMetallicFactor(metallicFactor) {
        this._metallicFactor = metallicFactor;
        return this;
    }
    /**
     * Metallic roughness texture. The metalness values are sampled from the B channel. The
     * roughness values are sampled from the G channel. When a material is fully metallic,
     * or nearly so, it may require image-based lighting (i.e. an environment map) or global
     * illumination to appear well-lit.
     *
     * Reference:
     * - [glTF → material.pbrMetallicRoughness.metallicRoughnessTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture)
     */
    getMetallicRoughnessTexture() {
        return this.metallicRoughnessTexture ? this.metallicRoughnessTexture.getChild() : null;
    }
    /**
     * Settings affecting the material's use of its metallic/roughness texture. If no texture is
     * attached, {@link TextureInfo} is `null`.
     */
    getMetallicRoughnessTextureInfo() {
        return this.metallicRoughnessTexture ? this.metallicRoughnessTexture.textureInfo : null;
    }
    /**
     * Settings affecting the material's use of its metallic/roughness texture. If no texture is
     * attached, {@link TextureSampler} is `null`.
     */
    getMetallicRoughnessTextureSampler() {
        return this.metallicRoughnessTexture ? this.metallicRoughnessTexture.sampler : null;
    }
    /** Sets metallic/roughness texture. See {@link getMetallicRoughnessTexture}. */
    setMetallicRoughnessTexture(texture) {
        this.metallicRoughnessTexture = this.graph.linkTexture('metallicRoughnessTexture', this, texture);
        return this;
    }
}
__decorate([
    GraphChild
], Material.prototype, "baseColorTexture", void 0);
__decorate([
    GraphChild
], Material.prototype, "emissiveTexture", void 0);
__decorate([
    GraphChild
], Material.prototype, "normalTexture", void 0);
__decorate([
    GraphChild
], Material.prototype, "occlusionTexture", void 0);
__decorate([
    GraphChild
], Material.prototype, "metallicRoughnessTexture", void 0);
