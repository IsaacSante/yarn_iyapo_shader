var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PropertyType } from '../constants';
import { GraphChildList } from '../graph/index';
import { ExtensibleProperty } from './extensible-property';
import { COPY_IDENTITY } from './property';
/**
 * # Scene
 *
 * *Scenes represent a set of visual objects to render.*
 *
 * Typically a glTF file contains only a single scene, although more are allowed and useful in some
 * cases. No particular meaning is associated with additional scenes, except as defined by the
 * application. Scenes reference {@link Node}s, and a single node cannot be a member of more than
 * one scene.
 *
 * References:
 * - [glTF → Scenes](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#scenes)
 * - [glTF → Coordinate System and Units](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#coordinate-system-and-units)
 *
 * @category Properties
 */
export class Scene extends ExtensibleProperty {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.SCENE;
        this.children = [];
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        if (resolve !== COPY_IDENTITY) {
            this.clearGraphChildList(this.children);
            other.children.forEach((link) => this.addChild(resolve(link.getChild())));
        }
        return this;
    }
    /** Adds a {@link Node} to the scene. */
    addChild(node) {
        // Remove existing parent.
        if (node._parent)
            node._parent.removeChild(node);
        // Link in graph.
        const link = this.graph.link('child', this, node);
        this.addGraphChild(this.children, link);
        // Set new parent.
        node._parent = this;
        link.onDispose(() => node._parent = null);
        return this;
    }
    /** Removes a {@link Node} from the scene. */
    removeChild(node) {
        return this.removeGraphChild(this.children, node);
    }
    /** Lists all root {@link Node}s in the scene. */
    listChildren() {
        return this.children.map((p) => p.getChild());
    }
    /** Visits each {@link Node} in the scene, including descendants, top-down. */
    traverse(fn) {
        for (const node of this.listChildren())
            node.traverse(fn);
        return this;
    }
}
__decorate([
    GraphChildList
], Scene.prototype, "children", void 0);
