var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { fromRotationTranslationScale, getRotation, getScaling, getTranslation, multiply } from 'gl-matrix/mat4';
import { PropertyType } from '../constants';
import { GraphChild, GraphChildList } from '../graph/graph-decorators';
import { ExtensibleProperty } from './extensible-property';
import { COPY_IDENTITY } from './property';
/**
 * # Node
 *
 * *Nodes are the objects that comprise a {@link Scene}.*
 *
 * Each node may have one or more children, and a transform (position, rotation, and scale) that
 * applies to all of its descendants. A node may also reference (or "instantiate") other resources
 * at its location, including {@link Mesh}, Camera, Light, and Skin properties. A node cannot be
 * part of more than one {@link Scene}.
 *
 * A node's local transform is represented with array-like objects, intended to be compatible with
 * [gl-matrix](https://github.com/toji/gl-matrix), or with the `toArray`/`fromArray` methods of
 * libraries like three.js and babylon.js.
 *
 * Usage:
 *
 * ```ts
 * const node = doc.createNode('myNode')
 * 	.setMesh(mesh)
 * 	.setTranslation([0, 0, 0])
 * 	.addChild(otherNode);
 * ```
 *
 * References:
 * - [glTF â†’ Nodes and Hierarchy](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#nodes-and-hierarchy)
 *
 * @category Properties
 */
export class Node extends ExtensibleProperty {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.NODE;
        this._translation = [0, 0, 0];
        this._rotation = [0, 0, 0, 1];
        this._scale = [1, 1, 1];
        this._weights = [];
        /** @hidden Internal reference to node's parent, omitted from {@link Graph}. */
        this._parent = null;
        this.camera = null;
        this.mesh = null;
        this.skin = null;
        this.children = [];
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        this._translation = [...other._translation];
        this._rotation = [...other._rotation];
        this._scale = [...other._scale];
        this._weights = [...other._weights];
        if (other.camera)
            this.setCamera(resolve(other.camera.getChild()));
        if (other.mesh)
            this.setMesh(resolve(other.mesh.getChild()));
        if (other.skin)
            this.setSkin(resolve(other.skin.getChild()));
        if (resolve !== COPY_IDENTITY) {
            this.clearGraphChildList(this.children);
            other.children.forEach((link) => this.addChild(resolve(link.getChild())));
        }
        return this;
    }
    /**********************************************************************************************
     * Local transform.
     */
    /** Returns the translation (position) of this node in local space. */
    getTranslation() { return this._translation; }
    /** Returns the rotation (quaternion) of this node in local space. */
    getRotation() { return this._rotation; }
    /** Returns the scale of this node in local space. */
    getScale() { return this._scale; }
    /** Sets the translation (position) of this node in local space. */
    setTranslation(translation) {
        this._translation = translation;
        return this;
    }
    /** Sets the rotation (quaternion) of this node in local space. */
    setRotation(rotation) {
        this._rotation = rotation;
        return this;
    }
    /** Sets the scale of this node in local space. */
    setScale(scale) {
        this._scale = scale;
        return this;
    }
    /** Returns the local matrix of this node. */
    getMatrix() {
        return fromRotationTranslationScale([], this._rotation, this._translation, this._scale);
    }
    /**********************************************************************************************
     * World transform.
     */
    /** Returns the translation (position) of this node in world space. */
    getWorldTranslation() {
        return getTranslation([], this.getWorldMatrix());
    }
    /** Returns the rotation (quaternion) of this node in world space. */
    getWorldRotation() {
        return getRotation([], this.getWorldMatrix());
    }
    /** Returns the scale of this node in world space. */
    getWorldScale() {
        return getScaling([], this.getWorldMatrix());
    }
    /** Returns the world matrix of this node. */
    getWorldMatrix() {
        // Build ancestor chain.
        const ancestors = [];
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        for (let node = this; node instanceof Node; node = node._parent) {
            ancestors.push(node);
        }
        // Compute world matrix.
        let ancestor;
        const worldMatrix = ancestors.pop().getMatrix();
        while ((ancestor = ancestors.pop())) {
            multiply(worldMatrix, worldMatrix, ancestor.getMatrix());
        }
        return worldMatrix;
    }
    /**********************************************************************************************
     * Scene hierarchy.
     */
    /** Adds another node as a child of this one. Nodes cannot have multiple parents. */
    addChild(child) {
        // Remove existing parent.
        if (child._parent)
            child._parent.removeChild(child);
        // Link in graph.
        const link = this.graph.link('child', this, child);
        this.addGraphChild(this.children, link);
        // Set new parent.
        child._parent = this;
        link.onDispose(() => child._parent = null);
        return this;
    }
    /** Removes a node from this node's child node list. */
    removeChild(child) {
        return this.removeGraphChild(this.children, child);
    }
    /** Lists all child nodes of this node. */
    listChildren() {
        return this.children.map((link) => link.getChild());
    }
    /**
     * Returns the unique parent ({@link Scene}, {@link Node}, or null) of this node in the scene
     * hierarchy. Unrelated to {@link Property.listParents}, which lists all resource references.
     */
    getParent() {
        return this._parent;
    }
    /**********************************************************************************************
     * Attachments.
     */
    /** Returns the {@link Mesh}, if any, instantiated at this node. */
    getMesh() { return this.mesh ? this.mesh.getChild() : null; }
    /**
     * Sets a {@link Mesh} to be instantiated at this node. A single mesh may be instatiated by
     * multiple nodes; reuse of this sort is strongly encouraged.
     */
    setMesh(mesh) {
        this.mesh = this.graph.link('mesh', this, mesh);
        return this;
    }
    /** Returns the {@link Camera}, if any, instantiated at this node. */
    getCamera() { return this.camera ? this.camera.getChild() : null; }
    /** Sets a {@link Camera} to be instantiated at this node. */
    setCamera(camera) {
        this.camera = this.graph.link('camera', this, camera);
        return this;
    }
    /** Returns the {@link Skin}, if any, instantiated at this node. */
    getSkin() { return this.skin ? this.skin.getChild() : null; }
    /** Sets a {@link Skin} to be instantiated at this node. */
    setSkin(skin) {
        this.skin = this.graph.link('skin', this, skin);
        return this;
    }
    /**
     * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this node.
     * Most engines only support 4-8 active morph targets at a time.
     */
    getWeights() {
        return this._weights;
    }
    /**
     * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this node.
     * Most engines only support 4-8 active morph targets at a time.
     */
    setWeights(weights) {
        this._weights = weights;
        return this;
    }
    /**********************************************************************************************
     * Helpers.
     */
    /** Visits this {@link Node} and its descendants, top-down. */
    traverse(fn) {
        fn(this);
        for (const child of this.listChildren())
            child.traverse(fn);
        return this;
    }
}
__decorate([
    GraphChild
], Node.prototype, "camera", void 0);
__decorate([
    GraphChild
], Node.prototype, "mesh", void 0);
__decorate([
    GraphChild
], Node.prototype, "skin", void 0);
__decorate([
    GraphChildList
], Node.prototype, "children", void 0);
