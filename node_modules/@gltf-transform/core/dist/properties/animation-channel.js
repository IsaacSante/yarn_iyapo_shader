var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { PropertyType } from '../constants';
import { GraphChild } from '../graph';
import { COPY_IDENTITY, Property } from './property';
/**
 * # AnimationChannel
 *
 * *A target-path pair within a larger {@link Animation}, which refers to an
 * {@link AnimationSampler} storing the keyframe data for that pair.*
 *
 * A _target_ is always a {@link Node}, in the core glTF spec. A _path_ is any property of that
 * Node that can be affected by animation: `translation`, `rotation`, `scale`, or `weights`. An
 * {@link Animation} affecting the positions and rotations of several {@link Node}s would contain one
 * channel for each Node-position or Node-rotation pair. The keyframe data for an AnimationChannel
 * is stored in an {@link AnimationSampler}, which must be attached to the same {@link Animation}.
 *
 * Usage:
 *
 * ```ts
 * const node = doc.getRoot()
 * 	.listNodes()
 * 	.find((node) => node.getName() === 'Cog');
 *
 * const channel = doc.createAnimationChannel('cogRotation')
 * 	.setTargetPath('rotation')
 * 	.setTargetNode(node)
 * 	.setSampler(rotateSampler);
 * ```
 *
 * Reference
 * - [glTF â†’ Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)
 */
export class AnimationChannel extends Property {
    constructor() {
        super(...arguments);
        this.propertyType = PropertyType.ANIMATION_CHANNEL;
        this._targetPath = null;
        this.targetNode = null;
        this.sampler = null;
    }
    copy(other, resolve = COPY_IDENTITY) {
        super.copy(other, resolve);
        this._targetPath = other._targetPath;
        if (other.targetNode)
            this.setTargetNode(resolve(other.targetNode.getChild()));
        if (other.sampler)
            this.setSampler(resolve(other.sampler.getChild()));
        return this;
    }
    /**
     * Path (property) animated on the target {@link Node}. Supported values include:
     * `translation`, `rotation`, `scale`, or `weights`.
     */
    getTargetPath() {
        return this._targetPath;
    }
    /**
     * Path (property) animated on the target {@link Node}. Supported values include:
     * `translation`, `rotation`, `scale`, or `weights`.
     */
    setTargetPath(targetPath) {
        this._targetPath = targetPath;
        return this;
    }
    /** Target {@link Node} animated by the channel. */
    getTargetNode() {
        return this.targetNode ? this.targetNode.getChild() : null;
    }
    /** Target {@link Node} animated by the channel. */
    setTargetNode(targetNode) {
        this.targetNode = this.graph.link('target.node', this, targetNode);
        return this;
    }
    /**
     * Keyframe data input/output values for the channel. Must be attached to the same
     * {@link Animation}.
     */
    getSampler() {
        return this.sampler ? this.sampler.getChild() : null;
    }
    /**
     * Keyframe data input/output values for the channel. Must be attached to the same
     * {@link Animation}.
     */
    setSampler(sampler) {
        this.sampler = this.graph.link('sampler', this, sampler);
        return this;
    }
}
__decorate([
    GraphChild
], AnimationChannel.prototype, "targetNode", void 0);
__decorate([
    GraphChild
], AnimationChannel.prototype, "sampler", void 0);
