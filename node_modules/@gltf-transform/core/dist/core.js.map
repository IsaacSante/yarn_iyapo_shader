{"version":3,"file":"core.js","sources":["../src/constants.ts","../../../node_modules/tslib/tslib.es6.js","../src/graph/graph-links.ts","../src/graph/graph.ts","../src/graph/graph-decorators.ts","../src/graph/graph-node.ts","../src/utils/buffer-utils.ts","../src/utils/color-utils.ts","../src/utils/file-utils.ts","../src/utils/image-utils.ts","../src/utils/math-utils.ts","../src/utils/logger.ts","../src/utils/uuid.ts","../src/properties/property.ts","../src/properties/extensible-property.ts","../src/properties/accessor.ts","../src/properties/animation.ts","../src/properties/animation-channel.ts","../src/properties/animation-sampler.ts","../src/properties/buffer.ts","../src/properties/camera.ts","../src/properties/extension-property.ts","../src/properties/property-links.ts","../src/properties/property-graph.ts","../src/properties/texture-info.ts","../src/properties/material.ts","../src/properties/mesh.ts","../src/properties/node.ts","../src/properties/primitive.ts","../src/properties/primitive-target.ts","../src/properties/root.ts","../src/properties/scene.ts","../src/properties/skin.ts","../src/properties/texture.ts","../src/document.ts","../src/extension.ts","../src/io/reader-context.ts","../src/io/reader.ts","../src/io/writer-context.ts","../src/io/writer.ts","../src/io/platform-io.ts","../src/io/node-io.ts","../src/io/web-io.ts"],"sourcesContent":["// Injected at compile time, from $npm_package_version.\ndeclare const PACKAGE_VERSION: string;\n\n/**\n * Current version of the package.\n * @hidden\n */\nexport const VERSION = `v${PACKAGE_VERSION}`;\n\n/** @hidden */\nexport const NAME = '@gltf-transform/core';\n\n/**\n * Interface allowing Accessor setter/getter methods to be used interchangeably with gl-matrix\n * arrays or with three.js math objects' fromArray/toArray methods. For example, THREE.Vector2,\n * THREE.Vector3, THREE.Vector4, THREE.Quaternion, THREE.Matrix3, THREE.Matrix4, and THREE.Color.\n *\n * @hidden\n */\nexport interface ArrayProxy {\n\t/** Sets the value of the object from an array of values. */\n\tfromArray(array: number[]): ArrayProxy;\n\t/** Writes the value of the object into the given array. */\n\ttoArray(array: number[]): number[];\n}\n\n/**\n * 2-dimensional vector.\n * @hidden\n */\nexport type vec2 = [number, number];\n\n/**\n * 3-dimensional vector.\n * @hidden\n */\nexport type vec3 = [number, number, number];\n\n/**\n * 4-dimensional vector, e.g. RGBA or a quaternion.\n * @hidden\n */\nexport type vec4 = [number, number, number, number];\n\n/**\n * 3x3 matrix, e.g. an affine transform of a 2D vector.\n * @hidden\n */\nexport type mat3 = [\n\tnumber, number, number,\n\tnumber, number, number,\n\tnumber, number, number,\n];\n\n/**\n * 4x4 matrix, e.g. an affine transform of a 3D vector.\n * @hidden\n */\nexport type mat4 = [\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n\tnumber, number, number, number,\n];\n\n/** @hidden */\nexport const GLB_BUFFER = '@glb.bin';\n\n/**\n * Abstraction representing any one of the typed array classes supported by glTF and JavaScript.\n * @hidden\n */\nexport type TypedArray = Float32Array | Uint32Array | Uint16Array | Uint8Array | Int16Array | Int8Array;\n\n/**\n * Abstraction representing any one of the typed array constructors supported by glTF and JavaScript.\n * @hidden\n */\nexport type TypedArrayConstructor = Float32ArrayConstructor | Uint32ArrayConstructor | Uint16ArrayConstructor | Uint8ArrayConstructor | Int16ArrayConstructor | Int8ArrayConstructor;\n\n/** String IDs for core {@link Property} types. */\nexport enum PropertyType {\n\tACCESSOR = 'Accessor',\n\tANIMATION = 'Animation',\n\tANIMATION_CHANNEL = 'AnimationChannel',\n\tANIMATION_SAMPLER = 'AnimationSampler',\n\tBUFFER = 'Buffer',\n\tCAMERA = 'Camera',\n\tMATERIAL = 'Material',\n\tMESH = 'Mesh',\n\tPRIMITIVE = 'Primitive',\n\tPRIMITIVE_TARGET = 'PrimitiveTarget',\n\tNODE = 'Node',\n\tROOT = 'Root',\n\tSCENE = 'Scene',\n\tSKIN = 'Skin',\n\tTEXTURE = 'Texture',\n\tTEXTURE_INFO = 'TextureInfo',\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { GraphNode } from './graph-node';\n\n/**\n * Represents a connection between two {@link GraphNode} resources in a {@link Graph}.\n *\n * The left node is considered the owner, and the right node the resource. The\n * owner is responsible for being able find and remove a reference to a resource, given\n * that link. The resource does not hold a reference to the link or to the owner,\n * although that reverse lookup can be done on the graph.\n *\n * @hidden\n * @category Graph\n */\nexport class Link<Parent extends GraphNode, Child extends GraphNode> {\n\tprivate _disposed = false;\n\tprivate readonly _listeners: (() => void)[] = [];\n\tconstructor(\n\t\tprivate readonly _name: string,\n\t\tprivate readonly _parent: Parent,\n\t\tprivate _child: Child) {\n\t\tif (!_parent.canLink(_child)) {\n\t\t\tthrow new Error('Cannot link disconnected graphs/documents.');\n\t\t}\n\t}\n\n\t/** Name. */\n\tgetName(): string { return this._name; }\n\n\t/** Owner node. */\n\tgetParent(): Parent { return this._parent; }\n\n\t/** Resource node. */\n\tgetChild(): Child { return this._child; }\n\n\t/**\n\t * Sets the child node.\n\t *\n\t * @internal Only {@link Graph} implementations may safely call this method directly. Use\n\t * \t{@link Property.swap} or {@link Graph.swapChild} instead.\n\t * @hidden\n\t */\n\tsetChild(child: Child): this {\n\t\tthis._child = child;\n\t\treturn this;\n\t}\n\n\t/** Destroys a (currently intact) link, updating both the graph and the owner. */\n\tdispose(): void {\n\t\tif (this._disposed) return;\n\t\tthis._disposed = true;\n\t\tthis._listeners.forEach((fn) => fn());\n\t\tthis._listeners.length = 0;\n\t}\n\n\t/** Registers a listener to be invoked if this link is destroyed. */\n\tonDispose(fn: () => void): this {\n\t\tthis._listeners.push(fn);\n\t\treturn this;\n\t}\n\n\t/** Whether this link has been destroyed. */\n\tisDisposed(): boolean { return this._disposed; }\n}\n","import { Link } from './graph-links';\nimport { GraphNode } from './graph-node';\n\nconst EMPTY_SET: Set<Link<GraphNode, GraphNode>> = new Set();\n\n/**\n * A graph manages a network of {@link GraphNode} nodes, connected\n * by {@link @Link} edges.\n *\n * @hidden\n * @category Graph\n */\nexport class Graph {\n\tprivate _links: Set<Link<GraphNode, GraphNode>> = new Set();\n\tprivate _parentRefs: Map<GraphNode, Set<Link<GraphNode, GraphNode>>> = new Map();\n\tprivate _childRefs: Map<GraphNode, Set<Link<GraphNode, GraphNode>>> = new Map();\n\n\tpublic getLinks(): Link<GraphNode, GraphNode>[] {\n\t\treturn Array.from(this._links);\n\t}\n\n\tpublic listParents(node: GraphNode): GraphNode[] {\n\t\tconst links = this._childRefs.get(node) || EMPTY_SET;\n\t\treturn Array.from(links).map((link) => link.getParent());\n\t}\n\n\tpublic listChildren(node: GraphNode): GraphNode[] {\n\t\tconst links = this._parentRefs.get(node) || EMPTY_SET;\n\t\treturn Array.from(links).map((link) => link.getChild());\n\t}\n\n\tpublic disconnectChildren(node: GraphNode): this {\n\t\tconst links = this._parentRefs.get(node) || EMPTY_SET;\n\t\tlinks.forEach((link) => link.dispose());\n\t\treturn this;\n\t}\n\n\tpublic disconnectParents(node: GraphNode, filter?: (n: GraphNode) => boolean): this {\n\t\tlet links = Array.from(this._childRefs.get(node) || EMPTY_SET);\n\t\tif (filter) {\n\t\t\tlinks = links.filter((link) => filter(link.getParent()));\n\t\t}\n\t\tlinks.forEach((link) => link.dispose());\n\t\treturn this;\n\t}\n\n\tpublic swapChild(parent: GraphNode, prevChild: GraphNode, nextChild: GraphNode): this {\n\t\tconst links = this._parentRefs.get(parent) || EMPTY_SET;\n\t\tArray.from(links)\n\t\t\t.filter((link) => link.getChild() === prevChild)\n\t\t\t.forEach((link) => {\n\t\t\t\tthis._childRefs.get(prevChild).delete(link);\n\n\t\t\t\tlink.setChild(nextChild);\n\t\t\t\tif (!this._childRefs.has(nextChild)) this._childRefs.set(nextChild, new Set());\n\t\t\t\tthis._childRefs.get(nextChild).add(link);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t* Creates a link between two {@link GraphNode} instances. Link is returned\n\t* for the caller to store.\n\t* @param a Owner\n\t* @param b Resource\n\t*/\n\tpublic link<A extends GraphNode, B extends GraphNode>(name: string, a: A, b: B): Link<A, B> {\n\t\t// If there's no resource, return a null link. Avoids a lot of boilerplate in node setters.\n\t\tif (!b) return null;\n\n\t\tconst link = new Link(name, a, b);\n\t\tthis.registerLink(link);\n\t\treturn link;\n\t}\n\n\tprotected registerLink(link: Link<GraphNode, GraphNode>): Link<GraphNode, GraphNode> {\n\t\tthis._links.add(link);\n\n\t\tconst parent = link.getParent();\n\t\tif (!this._parentRefs.has(parent)) this._parentRefs.set(parent, new Set());\n\t\tthis._parentRefs.get(parent).add(link);\n\n\t\tconst child = link.getChild();\n\t\tif (!this._childRefs.has(child)) this._childRefs.set(child, new Set());\n\t\tthis._childRefs.get(child).add(link);\n\n\t\tlink.onDispose(() => this.unlink(link));\n\t\treturn link;\n\t}\n\n\t/**\n\t* Removes the link from the graph. This method should only be invoked by\n\t* the onDispose() listener created in {@link link()}. The public method\n\t* of removing a link is {@link link.dispose()}.\n\t* @param link\n\t*/\n\tprivate unlink(link: Link<GraphNode, GraphNode>): this {\n\t\tthis._links.delete(link);\n\t\tthis._parentRefs.get(link.getParent()).delete(link);\n\t\tthis._childRefs.get(link.getChild()).delete(link);\n\t\treturn this;\n\t}\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nconst DECORATOR_PREFIX = '__';\n\n/**\n * @hidden\n * @category Graph\n */\nexport function GraphChild (target: any, propertyKey: string): void {\n\tObject.defineProperty(target, propertyKey, {\n\t\tget: function () {\n\t\t\treturn this[DECORATOR_PREFIX + propertyKey];\n\t\t},\n\t\tset: function (value) {\n\t\t\tconst link = this[DECORATOR_PREFIX + propertyKey];\n\n\t\t\tif (link && !Array.isArray(link)) {\n\t\t\t\t// console.log('[GraphChild] Disposing link: ' + propertyKey, link, value);\n\t\t\t\tlink.dispose();\n\t\t\t}\n\n\t\t\tif (value && !Array.isArray(value)) {\n\t\t\t\t// This listener handles dispose events for property Links. The addGraphChild\n\t\t\t\t// method handles the events for arrays of Links.\n\t\t\t\tvalue.onDispose(() => {\n\t\t\t\t\t// console.log('[GraphChild] Unassigning link: ' + propertyKey, link);\n\t\t\t\t\tthis[DECORATOR_PREFIX + propertyKey] = null;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// if (value) console.log('[GraphChild] Assigning link: ' + propertyKey, value);\n\t\t\tthis[DECORATOR_PREFIX + propertyKey] = value;\n\t\t},\n\t\tenumerable: true\n\t});\n}\n\n/**\n * @hidden\n * @category Graph\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function GraphChildList (target: any, propertyKey: string): void {}\n","import { Graph } from './graph';\nimport { Link } from './graph-links';\n\n/**\n * Represents a node in a {@link Graph}.\n *\n * @hidden\n * @category Graph\n */\nexport abstract class GraphNode {\n\tprotected readonly graph: Graph;\n\tprivate _disposed = false;\n\tconstructor(graph: Graph) {\n\t\tthis.graph = graph;\n\t}\n\n\t/**\n\t * Returns true if links between this and the given node are allowed. Validates only that the\n\t * objects are both {@link GraphNode} instances and on the same graph, not that they are\n\t * semantically compatible.\n\t *\n\t * @hidden\n\t */\n\tpublic canLink(other: GraphNode): boolean {\n\t\treturn this.graph === other.graph;\n\t}\n\n\t/** Returns true if the node has been permanently removed from the graph. */\n\tpublic isDisposed(): boolean { return this._disposed; }\n\n\t/**\n\t * Removes both inbound references to and outbound references from this object. At the end\n\t * of the process the object holds no references, and nothing holds references to it. A\n\t * disposed object is not reusable.\n\t */\n\tpublic dispose(): void {\n\t\tthis.graph.disconnectChildren(this);\n\t\tthis.graph.disconnectParents(this);\n\t\tthis._disposed = true;\n\t}\n\n\t/**\n\t * Removes all inbound references to this object. At the end of the process the object is\n\t * considered 'detached': it may hold references to child resources, but nothing holds\n\t * references to it. A detached object may be re-attached.\n\t */\n\tpublic detach(): this {\n\t\tthis.graph.disconnectParents(this);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Transfers this object's references from the old node to the new one. The old node is fully\n\t * detached from this parent at the end of the process.\n\t *\n\t * @hidden This method works imperfectly with Root, Scene, and Node properties, which may\n\t * already hold equivalent links to the replacement object.\n\t */\n\tpublic swap(old: GraphNode, replacement: GraphNode): this {\n\t\tthis.graph.swapChild(this, old, replacement);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a Link to a managed {@link @GraphChildList}, and sets up a listener to\n\t * remove the link if it's disposed. This function is only for lists of links,\n\t * annotated with {@link @GraphChildList}. Properties are annotated and managed by\n\t * {@link @GraphChild} instead.\n\t *\n\t * @hidden\n\t */\n\tprotected addGraphChild(links: Link<GraphNode, GraphNode>[], link: Link<GraphNode, GraphNode>): this {\n\t\tlinks.push(link);\n\t\tlink.onDispose(() => {\n\t\t\tconst remaining = links.filter((l) => l !== link);\n\t\t\tlinks.length = 0;\n\t\t\tfor (const link of remaining) links.push(link);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes a {@link GraphNode} from a {@link GraphChildList}.\n\t *\n\t * @hidden\n\t */\n\tprotected removeGraphChild(links: Link<GraphNode, GraphNode>[], child: GraphNode): this {\n\t\tconst pruned = links.filter((link) => link.getChild() === child);\n\t\tpruned.forEach((link) => link.dispose());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes all {@link GraphNode}s from a {@link GraphChildList}.\n\t *\n\t * @hidden\n\t */\n\tprotected clearGraphChildList(links: Link<GraphNode, GraphNode>[]): this {\n\t\twhile (links.length > 0) links[0].dispose();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a list of all nodes that hold a reference to this node.\n\t *\n\t * Available publicly by {@link Property}'s `.listParents()`.\n\t *\n\t * @hidden\n\t */\n\tprotected listGraphParents(): GraphNode[] {\n\t\treturn this.graph.listParents(this) as GraphNode[];\n\t}\n}\n","/**\n * # BufferUtils\n *\n * *Common utilities for working with ArrayBuffer and Buffer objects.*\n *\n * @category Utilities\n */\nexport class BufferUtils {\n\t/** Creates an ArrayBuffer from a Data URI. */\n\tstatic createBufferFromDataURI(dataURI: string): ArrayBuffer {\n\t\tif (typeof Buffer === 'undefined') {\n\t\t\t// Browser.\n\t\t\tconst byteString = atob(dataURI.split(',')[1]);\n\t\t\tconst ia = new Uint8Array(byteString.length);\n\t\t\tfor (let i = 0; i < byteString.length; i++) {\n\t\t\t\tia[i] = byteString.charCodeAt(i);\n\t\t\t}\n\t\t\treturn ia.buffer;\n\t\t} else {\n\t\t\t// Node.js.\n\t\t\tconst data = dataURI.split(',')[1];\n\t\t\tconst isBase64 = dataURI.indexOf('base64') >= 0;\n\t\t\treturn this.trim(Buffer.from(data, isBase64 ? 'base64' : 'utf8'));\n\t\t}\n\t}\n\n\t/** Encodes text to an ArrayBuffer. */\n\tstatic encodeText(text: string): ArrayBuffer {\n\t\tif (typeof TextEncoder !== 'undefined') {\n\t\t\treturn new TextEncoder().encode(text).buffer;\n\t\t}\n\t\treturn this.trim(Buffer.from(text));\n\t}\n\n\t/** Decodes an ArrayBuffer to text. */\n\tstatic decodeText(buffer: ArrayBuffer): string {\n\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\treturn new TextDecoder().decode(buffer);\n\t\t}\n\t\treturn Buffer.from(buffer).toString('utf8');\n\t}\n\n\t/** Copies an ArrayBuffer from a Buffer's content. */\n\tstatic trim(buffer: Buffer): ArrayBuffer {\n\t\tconst {byteOffset, byteLength} = buffer;\n\t\treturn buffer.buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\t/**\n\t* Concatenates N ArrayBuffers.\n\t*/\n\tstatic concat (buffers: ArrayBuffer[]): ArrayBuffer {\n\t\tlet totalByteLength = 0;\n\t\tfor (const buffer of buffers) {\n\t\t\ttotalByteLength += buffer.byteLength;\n\t\t}\n\n\t\tconst result = new Uint8Array(totalByteLength);\n\t\tlet byteOffset = 0;\n\n\t\tfor (const buffer of buffers) {\n\t\t\tresult.set(new Uint8Array(buffer), byteOffset);\n\t\t\tbyteOffset += buffer.byteLength;\n\t\t}\n\n\t\treturn result.buffer;\n\t}\n\n\t/**\n\t* Pads an ArrayBuffer to the next 4-byte boundary.\n\t*\n\t* Reference: [glTF → Data Alignment](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment)\n\t*/\n\tstatic pad (arrayBuffer: ArrayBuffer, paddingByte = 0): ArrayBuffer {\n\n\t\tconst paddedLength = this.padNumber( arrayBuffer.byteLength );\n\n\t\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\t\tconst array = new Uint8Array( paddedLength );\n\t\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\t\tif ( paddingByte !== 0 ) {\n\n\t\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array.buffer;\n\n\t\t}\n\n\t\treturn arrayBuffer;\n\n\t}\n\n\t/** Pads a number to 4-byte boundaries. */\n\tstatic padNumber (v: number): number {\n\n\t\treturn Math.ceil( v / 4 ) * 4;\n\n\t}\n\n\t/** Returns true if given ArrayBuffer instances are equal. */\n\tstatic equals(a: ArrayBuffer, b: ArrayBuffer): boolean {\n\t\tif (a === b) return true;\n\n\t\tif (a.byteLength !== b.byteLength) return false;\n\n\t\tconst view1 = new DataView(a);\n\t\tconst view2 = new DataView(b);\n\n\t\tlet i = a.byteLength;\n\t\twhile (i--) {\n\t\t\tif (view1.getUint8(i) !== view2.getUint8(i)) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n}\n","import { vec3, vec4 } from '../constants';\n\n/**\n * # ColorUtils\n *\n * *Common utilities for working with colors in vec3, vec4, or hexadecimal form.*\n *\n * Provides methods to convert linear components (vec3, vec4) to sRGB hex values. All colors in\n * the glTF specification, excluding color textures, are linear. Hexadecimal values, in sRGB\n * colorspace, are accessible through helper functions in the API as a convenience.\n *\n * ```typescript\n * // Hex (sRGB) to factor (linear).\n * const factor = ColorUtils.hexToFactor(0xFFCCCC, []);\n *\n * // Factor (linear) to hex (sRGB).\n * const hex = ColorUtils.factorToHex([1, .25, .25])\n * ```\n *\n * @category Utilities\n */\nexport class ColorUtils {\n\t/**\n\t * Converts sRGB hexadecimal to linear components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic hexToFactor<T = vec3 | vec4>(hex: number, target: T): T {\n\t\thex = Math.floor( hex );\n\t\ttarget[0] = ( hex >> 16 & 255 ) / 255;\n\t\ttarget[1] = ( hex >> 8 & 255 ) / 255;\n\t\ttarget[2] = ( hex & 255 ) / 255;\n\t\treturn this.convertSRGBToLinear<T>(target, target);\n\t}\n\n\t/**\n\t * Converts linear components to sRGB hexadecimal.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic factorToHex<T = vec3 | vec4>(factor: T): number {\n\t\tconst target = [...factor as unknown as number[]] as unknown as T;\n\t\tconst [r, g, b] = this.convertLinearToSRGB(factor, target) as unknown as number[];\n\t\treturn ( r * 255 ) << 16 ^ ( g * 255 ) << 8 ^ ( b * 255 ) << 0;\n\t}\n\n\t/**\n\t * Converts sRGB components to linear components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic convertSRGBToLinear<T = vec3 | vec4>(source: T, target: T): T {\n\t\tfor (let i = 0 ; i < 3; i++) {\n\t\t\ttarget[i] = ( source[i] < 0.04045 )\n\t\t\t\t? source[i] * 0.0773993808\n\t\t\t\t: Math.pow( source[i] * 0.9478672986 + 0.0521327014, 2.4 );\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Converts linear components to sRGB components.\n\t * @typeParam T vec3 or vec4 linear components.\n\t */\n\tstatic convertLinearToSRGB<T = vec3 | vec4>(source: T, target: T): T {\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\ttarget[i] = ( source[i] < 0.0031308 )\n\t\t\t\t? source[i] * 12.92\n\t\t\t\t: 1.055 * ( Math.pow( source[i], 0.41666 ) ) - 0.055;\n\t\t}\n\t\treturn target;\n\t}\n}\n","/**\n * # FileUtils\n *\n * *Utility class for working with file systems and URI paths.*\n *\n * @category Utilities\n */\nexport class FileUtils {\n\t/** Extracts the basename from a path, e.g. \"folder/model.glb\" -> \"model\". */\n\tstatic basename(path: string): string {\n\t\t// https://stackoverflow.com/a/15270931/1314762\n\t\treturn path.split(/[\\\\/]/).pop().split(/[.]/).shift();\n\t}\n\n\t/** Extracts the extension from a path, e.g. \"folder/model.glb\" -> \"glb\". */\n\tstatic extension(path: string): string {\n\t\tif (path.indexOf('data:') !== 0) {\n\t\t\treturn path.split(/[\\\\/]/).pop().split(/[.]/).pop();\n\t\t} else if (path.indexOf('data:image/png') === 0) {\n\t\t\treturn 'png';\n\t\t} else if (path.indexOf('data:image/jpeg') === 0) {\n\t\t\treturn 'jpeg';\n\t\t} else {\n\t\t\treturn 'bin';\n\t\t}\n\t}\n}\n","import { vec2 } from '../constants';\nimport { BufferUtils } from './buffer-utils';\n\n// Used to detect \"fried\" png's: http://www.jongware.com/pngdefry.html\nconst PNG_FRIED_CHUNK_NAME = 'CgBI';\n\n/*\n * PNG signature: 'PNG\\r\\n\\x1a\\n'\n * PNG image header chunk name: 'IHDR'\n */\n\n/**\n * # ImageUtils\n *\n * *Common utilities for working with image data.*\n *\n * @category Utilities\n */\nclass ImageUtils {\n\t/** Returns the size of a JPEG image. */\n\tpublic static getSizeJPEG (buffer: ArrayBuffer): vec2 {\n\t\t// Skip 4 chars, they are for signature\n\t\tlet view = new DataView(buffer, 4);\n\n\t\tlet i, next;\n\t\twhile (view.byteLength) {\n\t\t\t// read length of the next block\n\t\t\ti = view.getUint16(0, false);\n\t\t\t// i = buffer.readUInt16BE(0);\n\n\t\t\t// ensure correct format\n\t\t\tvalidateBuffer(view, i);\n\n\t\t\t// 0xFFC0 is baseline standard(SOF)\n\t\t\t// 0xFFC1 is baseline optimized(SOF)\n\t\t\t// 0xFFC2 is progressive(SOF2)\n\t\t\tnext = view.getUint8(i + 1);\n\t\t\tif (next === 0xC0 || next === 0xC1 || next === 0xC2) {\n\t\t\t\treturn [view.getUint16(i + 7, false), view.getUint16(i + 5, false)]\n\t\t\t}\n\n\t\t\t// move to the next block\n\t\t\tview = new DataView(buffer, view.byteOffset + i + 2);\n\t\t}\n\n\t\tthrow new TypeError('Invalid JPG, no size found');\n\t}\n\n\t/** Returns the size of a PNG image. */\n\tpublic static getSizePNG (buffer: ArrayBuffer): vec2 {\n\t\tconst view = new DataView(buffer);\n\t\tconst magic = BufferUtils.decodeText(buffer.slice(12, 16));\n\t\tif (magic === PNG_FRIED_CHUNK_NAME) {\n\t\t\treturn [view.getUint32(32, false), view.getUint32(36, false)];\n\t\t}\n\t\treturn [view.getUint32(16, false), view.getUint32(20, false)];\n\t}\n\n\tpublic static mimeTypeToExtension(mimeType: string): string {\n\t\tif (mimeType === 'image/jpeg') return 'jpg';\n\t\treturn mimeType.split('/').pop();\n\t}\n\n\tpublic static extensionToMimeType(extension: string): string {\n\t\tif (extension === 'jpg') return 'image/jpeg';\n\t\treturn `image/${extension}`;\n\t}\n}\n\nfunction validateBuffer (view: DataView, i: number): void {\n    // index should be within buffer limits\n    if (i > view.byteLength) {\n        throw new TypeError('Corrupt JPG, exceeded buffer limits');\n    }\n    // Every JPEG block must begin with a 0xFF\n    if (view.getUint8(i) !== 0xFF) {\n        throw new TypeError('Invalid JPG, marker table corrupted');\n    }\n}\n\nexport { ImageUtils };\n","/** @hidden */\nexport class MathUtils {\n\tpublic static identity(v: number): number {\n\t\treturn v;\n\t}\n\n\tpublic static denormalize(c: number, componentType: GLTF.AccessorComponentType): number {\n\t\tswitch (componentType) {\n\t\t\tcase GLTF.AccessorComponentType.FLOAT:\n\t\t\t\treturn c;\n\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_SHORT:\n\t\t\t\treturn c / 65535.0;\n\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_BYTE:\n\t\t\t\treturn c / 255.0;\n\t\t\tcase GLTF.AccessorComponentType.SHORT:\n\t\t\t\treturn Math.max(c / 32767.0, -1.0);\n\t\t\tcase GLTF.AccessorComponentType.BYTE:\n\t\t\t\treturn Math.max(c / 127.0, -1.0);\n\t\t}\n\n\t}\n\n\tpublic static normalize(f: number, componentType: GLTF.AccessorComponentType): number {\n\t\tswitch (componentType) {\n\t\t\tcase GLTF.AccessorComponentType.FLOAT:\n\t\t\t\treturn f;\n\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_SHORT:\n\t\t\t\treturn Math.round(f * 65535.0);\n\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_BYTE:\n\t\t\t\treturn Math.round(f * 255.0);\n\t\t\tcase GLTF.AccessorComponentType.SHORT:\n\t\t\t\treturn Math.round(f * 32767.0);\n\t\t\tcase GLTF.AccessorComponentType.BYTE:\n\t\t\t\treturn Math.round(f * 127.0);\n\t\t}\n\t}\n}\n","/**\n * # Logger\n *\n * *Logger utility class.*\n *\n * @category Utilities\n */\nclass Logger {\n\t/**\n\t * Log verbosity thresholds.\n\t */\n\tstatic Verbosity = {\n\t\t/** No events are logged. */\n\t\tSILENT: 4,\n\n\t\t/** Only error events are logged. */\n\t\tERROR: 3,\n\n\t\t/** Only error and warn events are logged. */\n\t\tWARN: 2,\n\n\t\t/** Only error, warn, and info events are logged. (DEFAULT) */\n\t\tINFO: 1,\n\n\t\t/** All events are logged. */\n\t\tDEBUG: 0,\n\t}\n\n\t/** Default logger instance. */\n\tpublic static DEFAULT_INSTANCE = new Logger(Logger.Verbosity.INFO);\n\n\t/** Constructs a new Logger instance. */\n\tconstructor (private readonly verbosity: number) {}\n\n\t/** Logs an event at level {@link Logger.Verbosity.DEBUG}. */\n\tdebug (text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.DEBUG) {\n\t\t\tconsole.debug(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.INFO}. */\n\tinfo (text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.INFO) {\n\t\t\tconsole.info(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.WARN}. */\n\twarn (text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.WARN) {\n\t\t\tconsole.warn(text);\n\t\t}\n\t}\n\n\t/** Logs an event at level {@link Logger.Verbosity.ERROR}. */\n\terror (text: string): void {\n\t\tif (this.verbosity <= Logger.Verbosity.ERROR) {\n\t\t\tconsole.error(text);\n\t\t}\n\t}\n}\n\nexport { Logger };\n","const ALPHABET = '23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ';\nconst UNIQUE_RETRIES = 999;\nconst ID_LENGTH = 6;\n\nconst previousIDs = new Set();\n\nconst generateOne = function(): string {\n  let rtn = '';\n  for (let i = 0; i < ID_LENGTH; i++) {\n    rtn += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));\n  }\n  return rtn;\n}\n\n/**\n * Short ID generator.\n *\n * Generated IDs are short, easy to type, and unique for the duration of the program's execution.\n * Uniqueness across multiple program executions, or on other devices, is not guaranteed. Based on\n * [Short ID Generation in JavaScript](https://tomspencer.dev/blog/2014/11/16/short-id-generation-in-javascript/),\n * with alterations.\n *\n * @category Utilities\n * @hidden\n */\nexport const uuid = function(): string {\n  for (let retries = 0; retries < UNIQUE_RETRIES; retries++) {\n\tconst id = generateOne();\n\tif (!previousIDs.has(id)) {\n\t\tpreviousIDs.add(id);\n\t\treturn id;\n\t}\n  }\n};\n","import { GraphNode } from '../graph';\nimport { PropertyGraph } from './property-graph';\n\nexport type PropertyResolver<T extends Property> = (p: T) => T;\nexport const COPY_IDENTITY = <T extends Property>(t: T): T => t;\n\n/**\n * # Property\n *\n * *Properties represent distinct resources in a glTF asset, referenced by other properties.*\n *\n * For example, each material and texture is a property, with material properties holding\n * references to the textures. All properties are created with factory methods on the\n * {@link Document} in which they should be constructed. Properties are destroyed by calling\n * {@link dispose}().\n *\n * Usage:\n *\n * ```ts\n * const texture = doc.createTexture('myTexture');\n * doc.listTextures(); // → [texture x 1]\n *\n * // Attach a texture to a material.\n * material.setBaseColorTexture(texture);\n * material.getBaseColortexture(); // → texture\n *\n * // Detaching a texture removes any references to it, except from the doc.\n * texture.detach();\n * material.getBaseColorTexture(); // → null\n * doc.listTextures(); // → [texture x 1]\n *\n * // Disposing a texture removes all references to it, and its own references.\n * texture.dispose();\n * doc.listTextures(); // → []\n * ```\n *\n * Reference:\n * - [glTF → Concepts](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nexport abstract class Property extends GraphNode {\n\t/** Property type. */\n\tpublic abstract readonly propertyType: string;\n\n\tprotected readonly graph: PropertyGraph;\n\n\tprivate _extras: object = {};\n\tprivate _name = '';\n\n\t/** @hidden */\n\tconstructor(graph: PropertyGraph, name = '') {\n\t\tsuper(graph);\n\t\tthis._name = name;\n\t}\n\n\t/**********************************************************************************************\n\t * Name.\n\t */\n\n\t/**\n\t * Returns the name of this property. While names are not required to be unique, this is\n\t * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n\t * a property, prefer to use Extras.\n\t */\n\tpublic getName(): string { return this._name; }\n\n\t/**\n\t * Sets the name of this property. While names are not required to be unique, this is\n\t * encouraged, and non-unique names will be overwritten in some tools. For custom data about\n\t * a property, prefer to use Extras.\n\t */\n\tpublic setName(name: string): this {\n\t\tthis._name = name;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Extras.\n\t */\n\n\t/**\n\t * Returns a reference to the Extras object, containing application-specific data for this\n\t * Property. Extras should be an Object, not a primitive value, for best portability.\n\t */\n\tpublic getExtras(): object { return this._extras; }\n\n\t/**\n\t * Updates the Extras object, containing application-specific data for this Property. Extras\n\t * should be an Object, not a primitive value, for best portability.\n\t */\n\tpublic setExtras(extras: object): this {\n\t\tthis._extras = extras;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Graph state.\n\t */\n\n\t/**\n\t * Makes a copy of this property, with the same resources (by reference) as the original.\n\t */\n\tpublic clone(): this {\n\t\tconst PropertyClass = this.constructor as new(g: PropertyGraph) => this;\n\t\treturn new PropertyClass(this.graph).copy(this, COPY_IDENTITY);\n\t}\n\n\t/**\n\t * Copies all data from another property to this one. Child properties are copied by reference,\n\t * unless a 'resolve' function is given to override that.\n\t * @param other Property to copy references from.\n\t * @param resolve Function to resolve each Property being transferred. Default is identity.\n\t */\n\tpublic copy(other: this, resolve: PropertyResolver<Property>): this {\n\t\tthis._name = other._name;\n\t\tthis._extras = JSON.parse(JSON.stringify(other._extras));\n\t\treturn this;\n\t}\n\n\tpublic detach(): this {\n\t\t// Detaching should keep properties in the same Document, and attached to its root.\n\t\tthis.graph.disconnectParents(this, (n: Property) => n.propertyType !== 'Root');\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a list of all properties that hold a reference to this property. For example, a\n\t * material may hold references to various textures, but a texture does not hold references\n\t * to the materials that use it.\n\t *\n\t * It is often necessary to filter the results for a particular type: some resources, like\n\t * {@link Accessor}s, may be referenced by different types of properties. Most properties\n\t * include the {@link Root} as a parent, which is usually not of interest.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * const materials = texture\n\t * \t.listParents()\n\t * \t.filter((p) => p instanceof Material)\n\t * ```\n\t */\n\tpublic listParents(): Property[] {\n\t\treturn this.listGraphParents() as Property[];\n\t}\n}\n","import { GraphChildList, Link } from '../graph';\nimport { ExtensionProperty } from './extension-property';\nimport { COPY_IDENTITY, Property } from './property';\n\n// Breaking change introduced in v0.6.\nconst TOKEN_WARNING = 'Pass extension name (string) as lookup token, not a constructor.';\n\n/**\n * # ExtensibleProperty\n *\n * *A {@link Property} that can have {@link ExtensionProperty} instances attached.*\n *\n * Most properties — excluding {@link Root} and {@link ExtensionProperty} — are extensible. See the\n * {@link Extension} documentation for information about how to use extensions.\n *\n * @category Properties\n */\nexport abstract class ExtensibleProperty extends Property {\n\t@GraphChildList protected extensions: Link<Property, ExtensionProperty>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis.clearGraphChildList(this.extensions);\n\t\tother.extensions.forEach((link) => {\n\t\t\tconst extension = link.getChild();\n\t\t\tthis.setExtension(extension.extensionName, resolve(extension));\n\t\t})\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an {@link ExtensionProperty} attached to this Property, if any. *Not available on\n\t * {@link Root} properties.*\n\t */\n\tpublic getExtension<Prop extends ExtensionProperty>(name: string): Prop {\n\t\tif (typeof name !== 'string') throw new Error(TOKEN_WARNING);\n\t\tconst link = this.extensions.find((link) => link.getChild().extensionName === name);\n\t\treturn link ? link.getChild() as Prop : null;\n\t}\n\n\t/**\n\t * Attaches the given {@link ExtensionProperty} to this Property. For a given extension, only\n\t * one ExtensionProperty may be attached to any one Property at a time. *Not available on\n\t * {@link Root} properties.*\n\t */\n\tpublic setExtension<Prop extends ExtensionProperty>(name: string, extensionProperty: Prop): this {\n\t\tif (typeof name !== 'string') throw new Error(TOKEN_WARNING);\n\n\t\t// Remove previous extension.\n\t\tconst prevExtension = this.getExtension(name);\n\t\tif (prevExtension) this.removeGraphChild(this.extensions, prevExtension);\n\n\t\t// Stop if deleting the extension.\n\t\tif (!extensionProperty) return this;\n\n\t\t// Add next extension.\n\t\textensionProperty._validateParent(this);\n\t\treturn this.addGraphChild(this.extensions, this.graph.link(name, this, extensionProperty));\n\t}\n\n\t/**\n\t * Lists all {@link ExtensionProperty} instances attached to this Property. *Not available on\n\t * {@link Root} properties.*\n\t */\n\tpublic listExtensions(): ExtensionProperty[] {\n\t\treturn this.extensions.map((link) => link.getChild());\n\t}\n}\n","import { PropertyType, TypedArray } from '../constants';\nimport { GraphChild, Link } from '../graph';\nimport { MathUtils } from '../utils';\nimport { Buffer } from './buffer';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Accessor\n *\n * *Accessors store lists of numeric, vector, or matrix elements in a typed array.*\n *\n * All large data for {@link Mesh}, {@link Skin}, and {@link Animation} properties is stored in\n * {@link Accessor}s, organized into one or more {@link Buffer}s. Each accessor provides data in\n * typed arrays, with two abstractions:\n *\n * *Elements* are the logical divisions of the data into useful types: `\"SCALAR\"`, `\"VEC2\"`,\n * `\"VEC3\"`, `\"VEC4\"`, `\"MAT3\"`, or `\"MAT4\"`. The element type can be determined with the\n * {@link getType}() method, and the number of elements in the accessor determine its\n * {@link getCount}(). The number of components in an element — e.g. 9 for `\"MAT3\"` — are its\n * {@link getElementSize}().\n *\n * | `type`     | Components |\n * |:----------:|:----------:|\n * | `\"SCALAR\"` | 1          |\n * | `\"VEC2\"`   | 2          |\n * | `\"VEC3\"`   | 3          |\n * | `\"VEC4\"`   | 4          |\n * | `\"MAT2\"`   | 4          |\n * | `\"MAT3\"`   | 9          |\n * | `\"MAT4\"`   | 16         |\n *\n * *Components* are the numeric values within an element — e.g. `.x` and `.y` for `\"VEC2\"`. Various\n * component types are available: `BYTE`, `UNSIGNED_BYTE`, `SHORT`, `UNSIGNED_SHORT`,\n * `UNSIGNED_INT`, and `FLOAT`. The component type can be determined with the\n * {@link getComponentType} method, and the number of bytes in each component determine its\n * {@link getComponentSize}. Component types are identified by WebGL enum values, below.\n *\n * | `componentType`         | Bytes |\n * |:-----------------------:|:-----:|\n * | `5120` (BYTE)           | 1     |\n * | `5121` (UNSIGNED_BYTE)  | 1     |\n * | `5122` (SHORT)          | 2     |\n * | `5123` (UNSIGNED_SHORT) | 2     |\n * | `5125` (UNSIGNED_INT)   | 4     |\n * | `5126` (FLOAT)          | 4     |\n *\n * Usage:\n *\n * ```typescript\n * const accessor = doc.createAccessor('myData')\n * \t.setArray(new Float32Array([1,2,3,4,5,6,7,8,9,10,11,12]))\n * \t.setType('VEC3')\n * \t.setBuffer(doc.listBuffers()[0]);\n *\n * accessor.getCount();        // → 4\n * accessor.getElementSize();  // → 3\n * accessor.getByteLength();   // → 48\n * accessor.getElement(1, []); // → [4, 5, 6]\n *\n * accessor.setElement(0, [10, 20, 30]);\n * ```\n *\n * Data access through the {@link getElement} and {@link setElement} methods reads or overwrites\n * the content of the underlying typed array. These methods use element arrays intended to be\n * compatible with the [gl-matrix](https://github.com/toji/gl-matrix) library, or with the\n * `toArray`/`fromArray` methods of libraries like three.js and babylon.js.\n *\n * Each Accessor must be assigned to a {@link Buffer}, which determines where the accessor's data\n * is stored in the final file. Assigning Accessors to different Buffers allows the data to be\n * written to different `.bin` files.\n *\n * glTF-Transform does not expose many details of sparse, normalized, or interleaved accessors\n * through its API. It reads files using those techniques, presents a simplified view of the data\n * for editing, and attempts to write data back out with optimizations. For example, vertex\n * attributes will typically be interleaved by default, regardless of the input file.\n *\n * References:\n * - [glTF → Accessors](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nexport class Accessor extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.ACCESSOR;\n\n\t/** @hidden Raw data of the accessor. */\n\tprivate _array: TypedArray = null;\n\n\t/** @hidden Type of element represented. */\n\tprivate _type: GLTF.AccessorType = GLTF.AccessorType.SCALAR;\n\n\t/** @hidden Numeric type of each component in an element. */\n\tprivate _componentType: GLTF.AccessorComponentType = null;\n\n\t/** @hidden Whether data in the raw array should be considered normalized. */\n\tprivate _normalized = false;\n\n\t/** @hidden Inbound transform to normalized representation, if applicable. */\n\tprivate _in = MathUtils.identity;\n\n\t/** @hidden Outbound transform from normalized representation, if applicable. */\n\tprivate _out = MathUtils.identity;\n\n\t/** @hidden The {@link Buffer} to which this accessor's data will be written. */\n\t@GraphChild private buffer: Link<Accessor, Buffer> = null;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._array = other._array.slice();\n\t\tthis._type = other._type;\n\t\tthis._componentType = other._componentType;\n\t\tthis._normalized = other._normalized;\n\t\tthis._in = other._in;\n\t\tthis._out = other._out;\n\n\t\tif (other.buffer) this.setBuffer(resolve(other.buffer.getChild()));\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Static.\n\t */\n\n\t/** Supported element types. */\n\tpublic static Type = {\n\t\tSCALAR: GLTF.AccessorType.SCALAR,\n\t\tVEC2: GLTF.AccessorType.VEC2,\n\t\tVEC3: GLTF.AccessorType.VEC3,\n\t\tVEC4: GLTF.AccessorType.VEC4,\n\t\tMAT3: GLTF.AccessorType.MAT3,\n\t\tMAT4: GLTF.AccessorType.MAT4,\n\t}\n\n\t/** Supported component types. */\n\tpublic static ComponentType = {\n\t\tBYTE: GLTF.AccessorComponentType.BYTE,\n\t\tUNSIGNED_BYTE: GLTF.AccessorComponentType.UNSIGNED_BYTE,\n\t\tSHORT: GLTF.AccessorComponentType.SHORT,\n\t\tUNSIGNED_SHORT: GLTF.AccessorComponentType.UNSIGNED_SHORT,\n\t\tUNSIGNED_INT: GLTF.AccessorComponentType.UNSIGNED_INT,\n\t\tFLOAT: GLTF.AccessorComponentType.FLOAT,\n\t}\n\n\t/** Returns size of a given element type, in components. */\n\tpublic static getElementSize(type: GLTF.AccessorType): number {\n\t\tswitch (type) {\n\t\t\tcase GLTF.AccessorType.SCALAR: return 1;\n\t\t\tcase GLTF.AccessorType.VEC2: return 2;\n\t\t\tcase GLTF.AccessorType.VEC3: return 3;\n\t\t\tcase GLTF.AccessorType.VEC4: return 4;\n\t\t\tcase GLTF.AccessorType.MAT2: return 4;\n\t\t\tcase GLTF.AccessorType.MAT3: return 9;\n\t\t\tcase GLTF.AccessorType.MAT4: return 16;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unexpected type: ' + type);\n\t\t}\n\t}\n\n\t/** Returns size of a given component type, in bytes. */\n\tpublic static getComponentSize(componentType: GLTF.AccessorComponentType): number {\n\t\tswitch (componentType) {\n\t\t\tcase GLTF.AccessorComponentType.BYTE: return 1;\n\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_BYTE: return 1;\n\t\t\tcase GLTF.AccessorComponentType.SHORT: return 2;\n\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_SHORT: return 2;\n\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_INT: return 4;\n\t\t\tcase GLTF.AccessorComponentType.FLOAT: return 4;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unexpected component type: ' + componentType);\n\t\t}\n\t}\n\n\t/**********************************************************************************************\n\t * Min/max bounds.\n\t */\n\n\t/**\n\t * Minimum value of each component in this attribute. Unlike in a final glTF file, values\n\t * returned by this method will reflect the minimum accounting for {@link .normalized}\n\t * state.\n\t */\n\tpublic getMinNormalized(target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\n\t\tthis.getMin(target);\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = this._out(target[j]);\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Minimum value of each component in this attribute. Values returned by this method do not\n\t * reflect normalization: use {@link .getMinNormalized} in that case.\n\t */\n\tpublic getMin(target: number[]): number[] {\n\t\tconst count = this.getCount();\n\t\tconst elementSize = this.getElementSize();\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = Infinity;\n\n\t\tfor (let i = 0; i < count * elementSize; i += elementSize) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\tconst value = this._array[i + j];\n\t\t\t\tif (Number.isFinite(value)) {\n\t\t\t\t\ttarget[j] = Math.min(target[j], value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Maximum value of each component in this attribute. Unlike in a final glTF file, values\n\t * returned by this method will reflect the minimum accounting for {@link .normalized}\n\t * state.\n\t */\n\tpublic getMaxNormalized(target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\n\t\tthis.getMax(target);\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = this._out(target[j]);\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Maximum value of each component in this attribute. Values returned by this method do not\n\t * reflect normalization: use {@link .getMinNormalized} in that case.\n\t */\n\tpublic getMax(target: number[]): number[] {\n\t\tconst count = this.getCount();\n\t\tconst elementSize = this.getElementSize();\n\n\t\tfor (let j = 0; j < elementSize; j++) target[j] = -Infinity;\n\n\t\tfor (let i = 0; i < count * elementSize; i += elementSize) {\n\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\tconst value = this._array[i + j];\n\t\t\t\tif (Number.isFinite(value)) {\n\t\t\t\t\ttarget[j] = Math.max(target[j], value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**********************************************************************************************\n\t * Layout.\n\t */\n\n\t/**\n\t * Number of elements in the accessor. An array of length 30, containing 10 `VEC3` elements,\n\t * will have a count of 10.\n\t */\n\tpublic getCount(): number {\n\t\treturn this._array.length / this.getElementSize();\n\t}\n\n\t/** Type of element stored in the accessor. `VEC2`, `VEC3`, etc. */\n\tpublic getType(): GLTF.AccessorType { return this._type; }\n\n\t/**\n\t * Sets type of element stored in the accessor. `VEC2`, `VEC3`, etc. Array length must be a\n\t * multiple of the component size (`VEC2` = 2, `VEC3` = 3, ...) for the selected type.\n\t */\n\tpublic setType(type: GLTF.AccessorType): Accessor {\n\t\tthis._type = type;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Number of components in each element of the accessor. For example, the element size of a\n\t * `VEC2` accessor is 2. This value is determined automatically based on array length and\n\t * accessor type, specified with {@link setType}().\n\t */\n\tpublic getElementSize(): number {\n\t\treturn Accessor.getElementSize(this._type);\n\t}\n\n\t/**\n\t * Size of each component (a value in the raw array), in bytes. For example, the\n\t * `componentSize` of data backed by a `float32` array is 4 bytes.\n\t */\n\tpublic getComponentSize(): number {\n\t\treturn this._array.BYTES_PER_ELEMENT;\n\t}\n\n\t/**\n\t * Component type (float32, uint16, etc.). This value is determined automatically, and can only\n\t * be modified by replacing the underlying array.\n\t */\n\tpublic getComponentType(): GLTF.AccessorComponentType {\n\t\treturn this._componentType;\n\t}\n\n\t/**********************************************************************************************\n\t * Normalization.\n\t */\n\n\t/**\n\t * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n\t * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n\t * This property is defined only for accessors that contain vertex attributes or animation\n\t * output data.\n\t */\n\tpublic getNormalized(): boolean { return this._normalized; }\n\n\t/**\n\t * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned\n\t * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.\n\t * This property is defined only for accessors that contain vertex attributes or animation\n\t * output data.\n\t */\n\tpublic setNormalized(normalized: boolean): this {\n\t\tthis._normalized = normalized;\n\n\t\tif (normalized) {\n\t\t\tthis._out = (c: number): number => MathUtils.denormalize(c, this._componentType);\n\t\t\tthis._in = (f: number): number => MathUtils.normalize(f, this._componentType);\n\t\t} else {\n\t\t\tthis._out = MathUtils.identity;\n\t\t\tthis._in = MathUtils.identity;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Data access.\n\t */\n\n\t/**\n\t * Returns the scalar element value at the given index, accounting for normalization if\n\t * applicable.\n\t */\n\tpublic getScalar(index: number): number {\n\t\tconst elementSize = this.getElementSize();\n\t\treturn this._out(this._array[index * elementSize]);\n\t}\n\n\t/**\n\t * Assigns the scalar element value at the given index, accounting for normalization if\n\t * applicable.\n\t */\n\tpublic setScalar(index: number, x: number): this {\n\t\tthis._array[index * this.getElementSize()] = this._in(x);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the vector or matrix element value at the given index, accounting for normalization\n\t * if applicable.\n\t */\n\tpublic getElement(index: number, target: number[]): number[] {\n\t\tconst elementSize = this.getElementSize();\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\ttarget[i] = this._out(this._array[index * elementSize + i]);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Assigns the vector or matrix element value at the given index, accounting for normalization\n\t * if applicable.\n\t */\n\tpublic setElement(index: number, value: number[]): this {\n\t\tconst elementSize = this.getElementSize();\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tthis._array[index * elementSize + i] = this._in(value[i]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Raw data storage.\n\t */\n\n\t/** Returns the {@link Buffer} into which this accessor will be organized. */\n\tpublic getBuffer(): Buffer { return this.buffer ? this.buffer.getChild() : null; }\n\n\t/** Assigns the {@link Buffer} into which this accessor will be organized. */\n\tpublic setBuffer(buffer: Buffer): this {\n\t\tthis.buffer = this.graph.link('buffer', this, buffer);\n\t\treturn this;\n\t}\n\n\t/** Returns the raw typed array underlying this accessor. */\n\tpublic getArray(): TypedArray { return this._array; }\n\n\t/** Assigns the raw typed array underlying this accessor. */\n\tpublic setArray(array: TypedArray): this {\n\t\tthis._componentType = arrayToComponentType(array);\n\t\tthis._array = array;\n\t\treturn this;\n\t}\n\n\t/** Returns the total bytelength of this accessor, exclusive of padding. */\n\tpublic getByteLength(): number {\n\t\treturn this._array.byteLength;\n\t}\n}\n\n/**************************************************************************************************\n * Array utilities.\n */\n\n/** @hidden */\nfunction arrayToComponentType(array: TypedArray): GLTF.AccessorComponentType {\n\tswitch (array.constructor) {\n\t\tcase Float32Array:\n\t\t\treturn GLTF.AccessorComponentType.FLOAT;\n\t\tcase Uint32Array:\n\t\t\treturn GLTF.AccessorComponentType.UNSIGNED_INT;\n\t\tcase Uint16Array:\n\t\t\treturn GLTF.AccessorComponentType.UNSIGNED_SHORT;\n\t\tcase Uint8Array:\n\t\t\treturn GLTF.AccessorComponentType.UNSIGNED_BYTE;\n\t\tcase Int16Array:\n\t\t\treturn GLTF.AccessorComponentType.SHORT;\n\t\tcase Int8Array:\n\t\t\treturn GLTF.AccessorComponentType.BYTE;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown accessor componentType.');\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChildList, Link } from '../graph';\nimport { AnimationChannel } from './animation-channel';\nimport { AnimationSampler } from './animation-sampler';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Animation\n *\n * *Reusable collections of {@link AnimationChannel}s, together representing a discrete animation\n * clip.*\n *\n * One Animation represents one playable unit in an animation system. Each may contain channels\n * affecting multiple paths (`translation`, `rotation`, `scale`, or `weights`) on multiple\n * {@link Node}s. An Animation's channels must be played together, and do not have any meaning in\n * isolation.\n *\n * Multiple Animations _may_ be played together: for example, one character's _Walk_ animation\n * might play while another character's _Run_ animation plays. Or a single character might have\n * both an _Idle_ and a _Talk_ animation playing at the same time. However, glTF does not define\n * any particular relationship between top-level Animations, or any particular playback behavior\n * like looping or sequences of Animations. General-purpose viewers typically autoplay the first\n * animation and provide UI controls for choosing another. Game engines may have significantly\n * more advanced methods of playing and blending animations.\n *\n * For example, a very simple skinned {@link Mesh} might have two Animations, _Idle_ and _Walk_.\n * Each of those Animations might affect the rotations of two bones, _LegL_ and _LegR_, where the\n * keyframes for each target-path pair are stored in {@link AnimationChannel} instances. In  total,\n * this model would contain two Animations and Four {@link AnimationChannel}s.\n *\n * Usage:\n *\n * ```ts\n * const animation = doc.createAnimation('machineRun')\n * \t.addChannel(rotateCog1)\n * \t.addChannel(rotateCog2)\n * \t.addChannel(rotateCog3);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)\n */\nexport class Animation extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.ANIMATION;\n\t@GraphChildList private channels: Link<Animation, AnimationChannel>[] = [];\n\t@GraphChildList private samplers: Link<Animation, AnimationSampler>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis.clearGraphChildList(this.channels);\n\t\tthis.clearGraphChildList(this.samplers);\n\n\t\tother.channels.forEach((link) => this.addChannel(resolve(link.getChild())));\n\t\tother.samplers.forEach((link) => this.addSampler(resolve(link.getChild())));\n\n\t\treturn this;\n\t}\n\n\t/** Adds an {@link AnimationChannel} to this Animation. */\n\tpublic addChannel(channel: AnimationChannel): this {\n\t\tconst link = this.graph.link('channel', this, channel);\n\t\treturn this.addGraphChild(this.channels, link);\n\t}\n\n\t/** Removes an {@link AnimationChannel} from this Animation. */\n\tpublic removeChannel(channel: AnimationChannel): this {\n\t\treturn this.removeGraphChild(this.channels, channel);\n\t}\n\n\t/** Lists {@link AnimationChannel}s in this Animation. */\n\tpublic listChannels(): AnimationChannel[] {\n\t\treturn this.channels.map((link) => link.getChild());\n\t}\n\n\t/** Adds an {@link AnimationSampler} to this Animation. */\n\tpublic addSampler(sampler: AnimationSampler): this {\n\t\tconst link = this.graph.link('sampler', this, sampler);\n\t\treturn this.addGraphChild(this.samplers, link);\n\t}\n\n\t/** Removes an {@link AnimationSampler} from this Animation. */\n\tpublic removeSampler(sampler: AnimationSampler): this {\n\t\treturn this.removeGraphChild(this.samplers, sampler);\n\t}\n\n\t/** Lists {@link AnimationSampler}s in this Animation. */\n\tpublic listSamplers(): AnimationSampler[] {\n\t\treturn this.samplers.map((link) => link.getChild());\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChild, Link } from '../graph';\nimport { AnimationSampler } from './animation-sampler';\nimport { Node } from './node';\nimport { COPY_IDENTITY, Property } from './property';\n\n/**\n * # AnimationChannel\n *\n * *A target-path pair within a larger {@link Animation}, which refers to an\n * {@link AnimationSampler} storing the keyframe data for that pair.*\n *\n * A _target_ is always a {@link Node}, in the core glTF spec. A _path_ is any property of that\n * Node that can be affected by animation: `translation`, `rotation`, `scale`, or `weights`. An\n * {@link Animation} affecting the positions and rotations of several {@link Node}s would contain one\n * channel for each Node-position or Node-rotation pair. The keyframe data for an AnimationChannel\n * is stored in an {@link AnimationSampler}, which must be attached to the same {@link Animation}.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.getRoot()\n * \t.listNodes()\n * \t.find((node) => node.getName() === 'Cog');\n *\n * const channel = doc.createAnimationChannel('cogRotation')\n * \t.setTargetPath('rotation')\n * \t.setTargetNode(node)\n * \t.setSampler(rotateSampler);\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)\n */\nexport class AnimationChannel extends Property {\n\tpublic readonly propertyType = PropertyType.ANIMATION_CHANNEL;\n\tprivate _targetPath: GLTF.AnimationChannelTargetPath = null;\n\t@GraphChild private targetNode: Link<AnimationChannel, Node> = null;\n\t@GraphChild private sampler: Link<AnimationChannel, AnimationSampler> = null;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._targetPath = other._targetPath;\n\n\t\tif (other.targetNode) this.setTargetNode(resolve(other.targetNode.getChild()));\n\t\tif (other.sampler) this.setSampler(resolve(other.sampler.getChild()));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Path (property) animated on the target {@link Node}. Supported values include:\n\t * `translation`, `rotation`, `scale`, or `weights`.\n\t */\n\tpublic getTargetPath(): GLTF.AnimationChannelTargetPath {\n\t\treturn this._targetPath;\n\t}\n\n\t/**\n\t * Path (property) animated on the target {@link Node}. Supported values include:\n\t * `translation`, `rotation`, `scale`, or `weights`.\n\t */\n\tpublic setTargetPath(targetPath: GLTF.AnimationChannelTargetPath): this {\n\t\tthis._targetPath = targetPath;\n\t\treturn this;\n\t}\n\n\t/** Target {@link Node} animated by the channel. */\n\tpublic getTargetNode(): Node {\n\t\treturn this.targetNode ? this.targetNode.getChild() : null;\n\t}\n\n\t/** Target {@link Node} animated by the channel. */\n\tpublic setTargetNode(targetNode: Node): this {\n\t\tthis.targetNode = this.graph.link('target.node', this, targetNode);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Keyframe data input/output values for the channel. Must be attached to the same\n\t * {@link Animation}.\n\t */\n\tpublic getSampler(): AnimationSampler {\n\t\treturn this.sampler ? this.sampler.getChild() : null;\n\t}\n\n\t/**\n\t * Keyframe data input/output values for the channel. Must be attached to the same\n\t * {@link Animation}.\n\t */\n\tpublic setSampler(sampler: AnimationSampler): this {\n\t\tthis.sampler = this.graph.link('sampler', this, sampler);\n\t\treturn this;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChild, Link } from '../graph';\nimport { Accessor } from './accessor';\nimport { COPY_IDENTITY, Property } from './property';\n\n/**\n * # AnimationSampler\n *\n * *Reusable collection of keyframes affecting particular property of an object.*\n *\n * Each AnimationSampler refers to an input and an output {@link Accessor}. Input contains times\n * (in seconds) for each keyframe. Output contains values (of any {@link Accessor.Type}) for the\n * animated property at each keyframe. Samplers using `CUBICSPLINE` interpolation will also contain\n * in/out tangents in the output, with the layout:\n *\n * in<sub>1</sub>, value<sub>1</sub>, out<sub>1</sub>, in<sub>2</sub>, value<sub>2</sub>, out<sub>2</sub>,\n * in<sub>3</sub>, value<sub>3</sub>, out<sub>3</sub>, ...\n *\n * Usage:\n *\n * ```ts\n * // Create accessor containing input times, in seconds.\n * const input = doc.createAccessor('bounceTimes')\n * \t.setArray(new Float32Array([0, 1, 2]))\n * \t.setType('SCALAR');\n *\n * // Create accessor containing output values, in local units.\n * const output = doc.createAccessor('bounceValues')\n * \t.setArray(new Float32Array([\n * \t\t0, 0, 0, // y = 0\n * \t\t0, 1, 0, // y = 1\n * \t\t0, 0, 0, // y = 0\n * \t]))\n * \t.setType('VEC3');\n *\n * // Create sampler.\n * const sampler = doc.createAnimationSampler('bounce')\n * \t.setInput(input)\n * \t.setOutput(output)\n * \t.setInterpolation('LINEAR');\n * ```\n *\n * Reference\n * - [glTF → Animations](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#animations)\n */\nexport class AnimationSampler extends Property {\n\tpublic readonly propertyType = PropertyType.ANIMATION_SAMPLER;\n\n\tprivate _interpolation: GLTF.AnimationSamplerInterpolation = GLTF.AnimationSamplerInterpolation.LINEAR;\n\n\t@GraphChild private input: Link<AnimationSampler, Accessor> = null;\n\t@GraphChild private output: Link<AnimationSampler, Accessor> = null;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._interpolation = other._interpolation;\n\n\t\tif (other.input) this.setInput(resolve(other.input.getChild()));\n\t\tif (other.output) this.setOutput(resolve(other.output.getChild()));\n\n\t\treturn this;\n\t}\n\n\t/** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n\tpublic getInterpolation(): GLTF.AnimationSamplerInterpolation {\n\t\treturn this._interpolation;\n\t}\n\n\t/** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */\n\tpublic setInterpolation(interpolation: GLTF.AnimationSamplerInterpolation): this {\n\t\tthis._interpolation = interpolation;\n\t\treturn this;\n\t}\n\n\t/** Times for each keyframe, in seconds. */\n\tpublic getInput(): Accessor {\n\t\treturn this.input ? this.input.getChild() : null;\n\t}\n\n\t/** Times for each keyframe, in seconds. */\n\tpublic setInput(input: Accessor): this {\n\t\tthis.input = this.graph.link('input', this, input);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n\t * tangents.\n\t */\n\tpublic getOutput(): Accessor {\n\t\treturn this.output ? this.output.getChild() : null;\n\t}\n\n\t/**\n\t * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out\n\t * tangents.\n\t */\n\tpublic setOutput(output: Accessor): this {\n\t\tthis.output = this.graph.link('output', this, output);\n\t\treturn this;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Buffer\n *\n * *Buffers are low-level storage units for binary data.*\n *\n * glTF 2.0 has three concepts relevant to binary storage: accessors, buffer views, and buffers.\n * In glTF-Transform, an {@link Accessor} is referenced by any property that requires numeric typed\n * array data. Meshes, Primitives, and Animations all reference Accessors. Buffers define how that\n * data is organized into transmitted file(s). A `.glb` file has only a single Buffer, and when\n * exporting to `.glb` your resources should be grouped accordingly. A `.gltf` file may reference\n * one or more `.bin` files — each `.bin` is a Buffer — and grouping Accessors under different\n * Buffers allow you to specify that structure.\n *\n * For engines that can dynamically load portions of a glTF file, splitting data into separate\n * buffers can allow you to avoid loading data until it is needed. For example, you might put\n * binary data for specific meshes into a different `.bin` buffer, or put each animation's binary\n * payload into its own `.bin`.\n *\n * Buffer Views define how Accessors are organized within a given Buffer. glTF-Transform creates an\n * efficient Buffer View layout automatically at export: there is no Buffer View property exposed\n * by the glTF-Transform API, simplifying data management.\n *\n * Usage:\n *\n * ```ts\n * // Create two buffers with custom filenames.\n * const buffer1 = doc.createBuffer('buffer1')\n * \t.setURI('part1.bin');\n * const buffer2 = doc.createBuffer('buffer2')\n * \t.setURI('part2.bin');\n *\n * // Assign the attributes of two meshes to different buffers. If the meshes\n * // had indices or morph target attributes, you would also want to relocate\n * // those accessors.\n * mesh1\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer1)));\n * mesh2\n * \t.listPrimitives()\n * \t.forEach((primitive) => primitive.listAttributes()\n * \t\t.forEach((attribute) => attribute.setBuffer(buffer2)));\n *\n * // Write to disk. Each mesh's binary data will be in a separate binary file;\n * // any remaining accessors will be in a third (default) buffer.\n * new NodeIO().write('scene.gltf', doc);\n * // → scene.gltf, part1.bin, part2.bin\n * ```\n *\n * References:\n * - [glTF → Buffers and Buffer Views](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views)\n * - [glTF → Accessors](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors)\n *\n * @category Properties\n */\nexport class Buffer extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.BUFFER;\n\n\t/** @hidden URI (or filename) of the buffer. */\n\tprivate _uri: string;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._uri = other._uri;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n\t * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n\t * is possible for custom applications, but will limit the compatibility of the asset with most\n\t * tools.\n\t *\n\t * Buffers commonly use the extension `.bin`, though this is not required.\n\t */\n\tpublic getURI(): string {\n\t\treturn this._uri;\n\t}\n\n\t/**\n\t * Sets the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly\n\t * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)\n\t * is possible for custom applications, but will limit the compatibility of the asset with most\n\t * tools.\n\t *\n\t * Buffers commonly use the extension `.bin`, though this is not required.\n\t */\n\tpublic setURI(uri: string): this {\n\t\tthis._uri = uri;\n\t\treturn this;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Camera\n *\n * *Cameras are perspectives through which the {@link Scene} may be viewed.*\n *\n * Projection can be perspective or orthographic. Cameras are contained in nodes and thus can be\n * transformed. The camera is defined such that the local +X axis is to the right, the lens looks\n * towards the local -Z axis, and the top of the camera is aligned with the local +Y axis. If no\n * transformation is specified, the location of the camera is at the origin.\n *\n * Usage:\n *\n * ```typescript\n * const camera = doc.createCamera('myCamera')\n * \t.setType('perspective')\n * \t.setZNear(0.1)\n * \t.setZFar(100)\n * \t.setYFov(Math.PI / 4)\n * \t.setAspectRatio(1.5);\n *\n * node.setCamera(camera);\n * ```\n *\n * References:\n * - [glTF → Cameras](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#cameras)\n *\n * @category Properties\n */\nexport class Camera extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.CAMERA;\n\n\t// Common.\n\n\tprivate _type: GLTF.CameraType = GLTF.CameraType.PERSPECTIVE;\n\tprivate _znear: number;\n\tprivate _zfar: number;\n\n\t// Perspective.\n\n\tprivate _aspectRatio: number;\n\tprivate _yfov: number;\n\n\t// Orthographic.\n\n\tprivate _xmag: number;\n\tprivate _ymag: number;\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._type = other._type;\n\t\tthis._znear = other._znear;\n\t\tthis._zfar = other._zfar;\n\t\tthis._aspectRatio = other._aspectRatio;\n\t\tthis._yfov = other._yfov;\n\t\tthis._xmag = other._xmag;\n\t\tthis._ymag = other._ymag;\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Common.\n\t */\n\n\t/** Specifies if the camera uses a perspective or orthographic projection. */\n\tpublic getType(): GLTF.CameraType { return this._type; }\n\n\t/** Specifies if the camera uses a perspective or orthographic projection. */\n\tpublic setType(type: GLTF.CameraType): this {\n\t\tthis._type = type;\n\t\treturn this;\n\t}\n\n\t/** Floating-point distance to the near clipping plane. */\n\tpublic getZNear(): number { return this._znear; }\n\n\t/** Floating-point distance to the near clipping plane. */\n\tpublic setZNear(znear: number): this {\n\t\tthis._znear = znear;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n\t * znear. If zfar is undefined, runtime must use infinite projection matrix.\n\t */\n\tpublic getZFar(): number { return this._zfar; }\n\n\t/**\n\t * Floating-point distance to the far clipping plane. When defined, zfar must be greater than\n\t * znear. If zfar is undefined, runtime must use infinite projection matrix.\n\t */\n\tpublic setZFar(zfar: number): this {\n\t\tthis._zfar = zfar;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Perspective.\n\t */\n\n\t/**\n\t * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n\t * canvas is used.\n\t */\n\tpublic getAspectRatio(): number { return this._aspectRatio; }\n\n\t/**\n\t * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the\n\t * canvas is used.\n\t */\n\tpublic setAspectRatio(aspectRatio: number): this {\n\t\tthis._aspectRatio = aspectRatio;\n\t\treturn this;\n\t}\n\n\t/** Floating-point vertical field of view in radians. */\n\tpublic getYFov(): number { return this._yfov; }\n\n\t/** Floating-point vertical field of view in radians. */\n\tpublic setYFov(yfov: number): this {\n\t\tthis._yfov = yfov;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Orthographic.\n\t */\n\n\t/**\n\t * Floating-point horizontal magnification of the view, and half the view's width\n\t * in world units.\n\t */\n\tpublic getXMag(): number { return this._xmag; }\n\n\t/**\n\t * Floating-point horizontal magnification of the view, and half the view's width\n\t * in world units.\n\t */\n\tpublic setXMag(xmag: number): this {\n\t\tthis._xmag = xmag;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Floating-point vertical magnification of the view, and half the view's height\n\t * in world units.\n\t */\n\tpublic getYMag(): number { return this._ymag; }\n\n\t/**\n\t * Floating-point vertical magnification of the view, and half the view's height\n\t * in world units.\n\t */\n\tpublic setYMag(ymag: number): this {\n\t\tthis._ymag = ymag;\n\t\treturn this;\n\t}\n}\n","import { ExtensibleProperty } from './extensible-property';\nimport { Property } from './property';\nimport { PropertyGraph } from './property-graph';\n\n/** @hidden */\nexport interface ExtensionPropertyParent {\n\taddExtensionProperty(ext: ExtensionProperty): this;\n\tremoveExtensionProperty(ext: ExtensionProperty): this;\n}\n\n/**\n * # ExtensionProperty\n *\n * *Base class for all {@link Property} types that can be attached by an {@link Extension}.*\n *\n * After an {@link Extension} is attached to a glTF {@link Document}, the Extension may be used to\n * construct ExtensionProperty instances, to be referenced throughout the document as prescribed by\n * the Extension. For example, the `KHR_materials_clearcoat` Extension defines a `Clearcoat`\n * ExtensionProperty, which is referenced by {@link Material} Properties in the Document, and may\n * contain references to {@link Texture} properties of its own.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#specifying-extensions)\n */\nexport abstract class ExtensionProperty extends Property {\n\tpublic static EXTENSION_NAME: string;\n\tpublic abstract readonly extensionName: string;\n\n\t/** List of supported {@link Property} types. */\n\tpublic abstract readonly parentTypes: string[];\n\n\tconstructor(graph: PropertyGraph, private readonly _extension: ExtensionPropertyParent) {\n\t\tsuper(graph);\n\t\tthis._extension.addExtensionProperty(this);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._extension.removeExtensionProperty(this);\n\t\tsuper.dispose();\n\t}\n\n\t/** @hidden */\n\tpublic _validateParent(parent: ExtensibleProperty): void {\n\t\tif (!this.parentTypes.includes(parent.propertyType)) {\n\t\t\tthrow new Error(`Parent \"${parent.propertyType}\" invalid for child \"${this.propertyType}\".`);\n\t\t}\n\t}\n}\n","import { Link } from '../graph';\nimport { Accessor } from './accessor';\nimport { Primitive } from './primitive';\nimport { PrimitiveTarget } from './primitive-target';\n\n/** @hidden */\nexport class AttributeLink extends Link<Primitive|PrimitiveTarget, Accessor> {\n\tpublic semantic = '';\n\tpublic copy (other: this): this {\n\t\tthis.semantic = other.semantic;\n\t\treturn this;\n\t}\n}\n\n/** @hidden */\nexport class IndexLink extends Link<Primitive, Accessor> {\n\tpublic copy (other: this): this { return this; }\n}\n","import { Graph } from '../graph';\nimport { Accessor } from './accessor';\nimport { Primitive } from './primitive';\nimport { PrimitiveTarget } from './primitive-target';\nimport { AttributeLink, IndexLink } from './property-links';\n\n/** @hidden */\nexport class PropertyGraph extends Graph {\n\tpublic linkAttribute(name: string, a: Primitive|PrimitiveTarget, b: Accessor): AttributeLink {\n\t\tif (!b) return null;\n\t\tconst link = new AttributeLink(name, a, b);\n\t\tthis.registerLink(link);\n\t\treturn link;\n\t}\n\n\tpublic linkIndex(name: string, a: Primitive, b: Accessor): IndexLink {\n\t\tif (!b) return null;\n\t\tconst link = new IndexLink(name, a, b);\n\t\tthis.registerLink(link);\n\t\treturn link;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # TextureInfo\n *\n * *Settings associated with a particular use of a {@link Texture}.*\n *\n * Different materials may reuse the same texture but with different texture coordinates,\n * minFilter/magFilter, or wrapS/wrapT settings. The TextureInfo class contains settings\n * derived from both the \"TextureInfo\" and \"Sampler\" properties in the glTF specification,\n * consolidated here for simplicity.\n *\n * TextureInfo properties cannot be directly created. For any material texture slot, such as\n * baseColorTexture, there will be a corresponding method to obtain the TextureInfo for that slot.\n * For example, see {@link Material.getBaseColorTextureInfo}.\n *\n * References:\n * - [glTF → Texture Info](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#reference-textureinfo)\n *\n * @category Properties\n */\nexport class TextureInfo extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.TEXTURE_INFO;\n\n\tprivate _texCoord = 0;\n\n\t// Sampler properties are also attached to TextureInfo, for simplicity.\n\tprivate _magFilter: GLTF.TextureMagFilter = null;\n\tprivate _minFilter: GLTF.TextureMinFilter = null;\n\tprivate _wrapS: GLTF.TextureWrapMode = GLTF.TextureWrapMode.REPEAT;\n\tprivate _wrapT: GLTF.TextureWrapMode = GLTF.TextureWrapMode.REPEAT;\n\n\t/** UV wrapping mode. Values correspond to WebGL enums. */\n\tpublic static TextureWrapMode = {\n\t\tCLAMP_TO_EDGE: GLTF.TextureWrapMode.CLAMP_TO_EDGE,\n\t\tMIRRORED_REPEAT: GLTF.TextureWrapMode.MIRRORED_REPEAT,\n\t\tREPEAT: GLTF.TextureWrapMode.REPEAT,\n\t}\n\n\t/** Magnification filter. Values correspond to WebGL enums. */\n\tpublic static TextureMagFilter = {\n\t\tNEAREST: GLTF.TextureMagFilter.NEAREST,\n\t\tLINEAR: GLTF.TextureMagFilter.LINEAR,\n\t}\n\n\t/** Minification filter. Values correspond to WebGL enums. */\n\tpublic static TextureMinFilter = {\n\t\tNEAREST: GLTF.TextureMinFilter.NEAREST,\n\t\tLINEAR: GLTF.TextureMinFilter.LINEAR,\n\t\tNEAREST_MIPMAP_NEAREST: GLTF.TextureMinFilter.NEAREST_MIPMAP_NEAREST,\n\t\tLINEAR_MIPMAP_NEAREST: GLTF.TextureMinFilter.LINEAR_MIPMAP_NEAREST,\n\t\tNEAREST_MIPMAP_LINEAR: GLTF.TextureMinFilter.NEAREST_MIPMAP_LINEAR,\n\t\tLINEAR_MIPMAP_LINEAR: GLTF.TextureMinFilter.LINEAR_MIPMAP_LINEAR,\n\t}\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._texCoord = other._texCoord;\n\t\tthis._magFilter = other._magFilter;\n\t\tthis._minFilter = other._minFilter;\n\t\tthis._wrapS = other._wrapS;\n\t\tthis._wrapT = other._wrapT;\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t* Texture coordinates.\n\t*/\n\n\t/** Returns the texture coordinate (UV set) index for the texture. */\n\tpublic getTexCoord(): number { return this._texCoord; }\n\n\t/** Sets the texture coordinate (UV set) index for the texture. */\n\tpublic setTexCoord(texCoord: number): this {\n\t\tthis._texCoord = texCoord;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t* Min/mag filter.\n\t*/\n\n\t/** Returns the magnification filter applied to the texture. */\n\tpublic getMagFilter(): GLTF.TextureMagFilter { return this._magFilter; }\n\n\t/** Sets the magnification filter applied to the texture. */\n\tpublic setMagFilter(magFilter: GLTF.TextureMagFilter): this {\n\t\tthis._magFilter = magFilter;\n\t\treturn this;\n\t}\n\n\t/** Sets the minification filter applied to the texture. */\n\tpublic getMinFilter(): GLTF.TextureMinFilter { return this._minFilter; }\n\n\t/** Returns the minification filter applied to the texture. */\n\tpublic setMinFilter(minFilter: GLTF.TextureMinFilter): this {\n\t\tthis._minFilter = minFilter;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t* UV wrapping.\n\t*/\n\n\t/** Returns the S (U) wrapping mode for UVs used by the texture. */\n\tpublic getWrapS(): GLTF.TextureWrapMode { return this._wrapS; }\n\n\t/** Sets the S (U) wrapping mode for UVs used by the texture. */\n\tpublic setWrapS(wrapS: GLTF.TextureWrapMode): this {\n\t\tthis._wrapS = wrapS;\n\t\treturn this;\n\t}\n\n\t/** Returns the T (V) wrapping mode for UVs used by the texture. */\n\tpublic getWrapT(): GLTF.TextureWrapMode { return this._wrapT; }\n\n\t/** Sets the T (V) wrapping mode for UVs used by the texture. */\n\tpublic setWrapT(wrapT: GLTF.TextureWrapMode): this {\n\t\tthis._wrapT = wrapT;\n\t\treturn this;\n\t}\n}\n","import { PropertyType, vec3, vec4 } from '../constants';\nimport { GraphChild, Link } from '../graph/index';\nimport { ColorUtils } from '../utils';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\nimport { Texture } from './texture';\nimport { TextureInfo } from './texture-info';\n\n/**\n * # Material\n *\n * *Materials describe a surface's appearance and response to light.*\n *\n * Each {@link Primitive} within a {@link Mesh} may be assigned a single Material. The number of\n * GPU draw calls typically increases with both the numbers of Primitives and of Materials in an\n * asset; Materials should be reused wherever possible. Techniques like texture atlasing and vertex\n * colors allow objects to have varied appearances while technically sharing a single Material.\n *\n * Material properties are modified by both scalars (like `baseColorFactor`) and textures (like\n * `baseColorTexture`). When both are available, factors are considered linear multipliers against\n * textures of the same name. In the case of base color, vertex colors (`COLOR_0` attributes) are\n * also multiplied.\n *\n * Textures containing color data (`baseColorTexture`, `emissiveTexture`) are sRGB. All other\n * textures are linear. Like other resources, textures should be reused when possible.\n *\n * Usage:\n *\n * ```typescript\n * const material = doc.createMaterial('myMaterial')\n * \t.setBaseColorFactor([1, 0.5, 0.5, 1]) // RGBA\n * \t.setOcclusionTexture(aoTexture)\n * \t.setOcclusionStrength(0.5);\n *\n * mesh.listPrimitives()\n * \t.forEach((prim) => prim.setMaterial(material));\n * ```\n *\n * @category Properties\n */\nexport class Material extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.MATERIAL;\n\n\t/** @hidden Mode of the material's alpha channels. (`OPAQUE`, `BLEND`, or `MASK`) */\n\tprivate _alphaMode: GLTF.MaterialAlphaMode = GLTF.MaterialAlphaMode.OPAQUE;\n\n\t/** @hidden Visibility threshold. Applied only when `.alphaMode='MASK'`. */\n\tprivate _alphaCutoff = 0.5;\n\n\t/** @hidden When true, both sides of each triangle are rendered. May decrease performance. */\n\tprivate _doubleSided = false;\n\n\t/** @hidden Base color / albedo; linear multiplier. */\n\tprivate _baseColorFactor: vec4 = [1, 1, 1, 1];\n\n\t/** @hidden Emissive color; linear multiplier. */\n\tprivate _emissiveFactor: vec3 = [0, 0, 0];\n\n\t/** @hidden Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tprivate _normalScale = 1;\n\n\t/** @hidden (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionMap`. */\n\tprivate _occlusionStrength = 1;\n\n\t/**\n\t * Roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`.\n\t * @hidden\n\t */\n\tprivate _roughnessFactor = 1;\n\n\t/**\n\t * Metallic factor; linear multiplier. Affects metallic channel of\n\t * `metallicRoughnessTexture`.\n\t * @hidden\n\t */\n\tprivate _metallicFactor = 1;\n\n\t/** @hidden Base color / albedo texture. */\n\t@GraphChild private baseColorTexture: Link<this, Texture> = null;\n\t@GraphChild private baseColorTextureInfo: Link<this, TextureInfo> =\n\t\tthis.graph.link('baseColorTextureInfo', this, new TextureInfo(this.graph));\n\n\t/** @hidden Emissive texture. */\n\t@GraphChild private emissiveTexture: Link<this, Texture> = null;\n\t@GraphChild private emissiveTextureInfo: Link<this, TextureInfo> =\n\t\tthis.graph.link('emissiveTextureInfo', this, new TextureInfo(this.graph));\n\n\t/**\n\t * Normal (surface detail) texture. Normal maps often suffer artifacts with JPEG compression,\n\t * so PNG files are preferred.\n\t * @hidden\n\t */\n\t@GraphChild private normalTexture: Link<this, Texture> = null;\n\t@GraphChild private normalTextureInfo: Link<this, TextureInfo> =\n\t\tthis.graph.link('normalTextureInfo', this, new TextureInfo(this.graph));\n\n\t/**\n\t * (Ambient) Occlusion texture. Occlusion data is stored in the `.r` channel, allowing this\n\t * texture to be packed with `metallicRoughnessTexture`, optionally.\n\t * @hidden\n\t */\n\t@GraphChild private occlusionTexture: Link<this, Texture> = null;\n\t@GraphChild private occlusionTextureInfo: Link<this, TextureInfo> =\n\t\tthis.graph.link('occlusionTextureInfo', this, new TextureInfo(this.graph));\n\n\t/**\n\t * Metallic/roughness PBR texture. Roughness data is stored in the `.g` channel and metallic\n\t * data is stored in the `.b` channel, allowing thist exture to be packed with\n\t * `occlusionTexture`, optionally.\n\t * @hidden\n\t*/\n\t@GraphChild private metallicRoughnessTexture: Link<this, Texture> = null;\n\t@GraphChild private metallicRoughnessTextureInfo: Link<this, TextureInfo> =\n\t\tthis.graph.link('metallicRoughnessTextureInfo', this, new TextureInfo(this.graph));\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._alphaMode = other._alphaMode;\n\t\tthis._alphaCutoff = other._alphaCutoff;\n\t\tthis._doubleSided = other._doubleSided;\n\t\tthis._baseColorFactor = [...other._baseColorFactor] as vec4;\n\t\tthis._emissiveFactor = [...other._emissiveFactor] as vec3;\n\t\tthis._normalScale = other._normalScale;\n\t\tthis._occlusionStrength = other._occlusionStrength;\n\t\tthis._roughnessFactor = other._roughnessFactor;\n\t\tthis._metallicFactor = other._metallicFactor;\n\n\t\tif (other.baseColorTexture) {\n\t\t\tthis.setBaseColorTexture(resolve(other.baseColorTexture.getChild()));\n\t\t\tthis.getBaseColorTextureInfo().copy(resolve(other.baseColorTextureInfo.getChild()), resolve);\n\t\t}\n\t\tif (other.emissiveTexture) {\n\t\t\tthis.setEmissiveTexture(resolve(other.emissiveTexture.getChild()));\n\t\t\tthis.getEmissiveTextureInfo().copy(resolve(other.emissiveTextureInfo.getChild()), resolve);\n\t\t}\n\t\tif (other.normalTexture) {\n\t\t\tthis.setNormalTexture(resolve(other.normalTexture.getChild()));\n\t\t\tthis.getNormalTextureInfo().copy(resolve(other.normalTextureInfo.getChild()), resolve);\n\t\t}\n\t\tif (other.occlusionTexture) {\n\t\t\tthis.setOcclusionTexture(resolve(other.occlusionTexture.getChild()));\n\t\t\tthis.getOcclusionTextureInfo().copy(resolve(other.occlusionTextureInfo.getChild()), resolve);\n\t\t}\n\t\tif (other.metallicRoughnessTexture) {\n\t\t\tthis.setMetallicRoughnessTexture(resolve(other.metallicRoughnessTexture.getChild()));\n\t\t\tthis.getMetallicRoughnessTextureInfo().copy(resolve(other.metallicRoughnessTextureInfo.getChild()), resolve);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tdispose(): void {\n\t\t// TextureInfo instances were created by this material, and should be disposed with it.\n\t\tthis.baseColorTextureInfo.getChild().dispose();\n\t\tthis.emissiveTextureInfo.getChild().dispose();\n\t\tthis.normalTextureInfo.getChild().dispose();\n\t\tthis.occlusionTextureInfo.getChild().dispose();\n\t\tthis.metallicRoughnessTextureInfo.getChild().dispose();\n\t\tsuper.dispose();\n\t}\n\n\t/**********************************************************************************************\n\t * Double-sided / culling.\n\t */\n\n\t/** Returns true when both sides of triangles should be rendered. May impact performance. */\n\tpublic getDoubleSided(): boolean { return this._doubleSided; }\n\n\t/** Sets whether to render both sides of triangles. May impact performance. */\n\tpublic setDoubleSided(doubleSided: boolean): this {\n\t\tthis._doubleSided = doubleSided;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Alpha.\n\t */\n\n\t/** Returns material alpha, equivalent to baseColorFactor[3]. */\n\tpublic getAlpha(): number { return this._baseColorFactor[3]; }\n\n\t/** Sets material alpha, equivalent to baseColorFactor[3]. */\n\tpublic setAlpha(alpha: number): this {\n\t\tthis._baseColorFactor[3] = alpha;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the mode of the material's alpha channels, which are provided by `baseColorFactor`\n\t * and `baseColorTexture`.\n\t *\n\t * - `OPAQUE`: Alpha value is ignored and the rendered output is fully opaque.\n\t * - `BLEND`: Alpha value is used to determine the transparency each pixel on a surface, and\n\t * \tthe fraction of surface vs. background color in the final result. Alpha blending creates\n\t *\tsignificant edge cases in realtime renderers, and some care when structuring the model is\n\t * \tnecessary for good results. In particular, transparent geometry should be kept in separate\n\t * \tmeshes or primitives from opaque geometry. The `depthWrite` or `zWrite` settings in engines\n\t * \tshould usually be disabled on transparent materials.\n\t * - `MASK`: Alpha value is compared against `alphaCutoff` threshold for each pixel on a\n\t * \tsurface, and the pixel is either fully visible or fully discarded based on that cutoff.\n\t * \tThis technique is useful for things like leafs/foliage, grass, fabric meshes, and other\n\t * \tsurfaces where no semitransparency is needed. With a good choice of `alphaCutoff`, surfaces\n\t * \tthat don't require semitransparency can avoid the performance penalties and visual issues\n\t * \tinvolved with `BLEND` transparency.\n\t *\n\t * Reference:\n\t * - [glTF → material.alphaMode](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialalphamode)\n\t */\n\tpublic getAlphaMode(): GLTF.MaterialAlphaMode { return this._alphaMode; }\n\n\t/** Sets the mode of the material's alpha channels. See {@link getAlphaMode} for details. */\n\tpublic setAlphaMode(alphaMode: GLTF.MaterialAlphaMode): this {\n\t\tthis._alphaMode = alphaMode;\n\t\treturn this;\n\t}\n\n\t/** Returns the visibility threshold; applied only when `.alphaMode='MASK'`. */\n\tpublic getAlphaCutoff(): number { return this._alphaCutoff; }\n\n\t/** Sets the visibility threshold; applied only when `.alphaMode='MASK'`. */\n\tpublic setAlphaCutoff(alphaCutoff: number): this {\n\t\tthis._alphaCutoff = alphaCutoff;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Base color.\n\t */\n\n\t/** Base color / albedo factor in linear space. See {@link getBaseColorTexture}. */\n\tpublic getBaseColorFactor(): vec4 { return this._baseColorFactor; }\n\n\t/** Sets the base color / albedo factor in linear space. See {@link getBaseColorTexture}. */\n\tpublic setBaseColorFactor(baseColorFactor: vec4): this {\n\t\tthis._baseColorFactor = baseColorFactor;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Base color / albedo as hexadecimal in sRGB colorspace. Converted automatically from\n\t * baseColorFactor in linear space. See {@link getBaseColorTexture}.\n\t */\n\tpublic getBaseColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this._baseColorFactor);\n\t}\n\n\t/**\n\t * Sets base color / albedo as hexadecimal in sRGB colorspace. Converted automatically to\n\t * baseColorFactor in linear space. See {@link getBaseColorTexture}.\n\t */\n\tpublic setBaseColorHex(hex: number): this {\n\t\tColorUtils.hexToFactor(hex, this._baseColorFactor);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Base color / albedo. The visible color of a non-metallic surface under constant ambient\n\t * light would be a linear combination (multiplication) of its vertex colors, base color\n\t * factor, and base color texture. Lighting, and reflections in metallic or smooth surfaces,\n\t * also effect the final color. The alpha (`.a`) channel of base color factors and textures\n\t * will have varying effects, based on the setting of {@link getAlphaMode}.\n\t *\n\t * Reference:\n\t * - [glTF → material.pbrMetallicRoughness.baseColorFactor](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#pbrmetallicroughnessbasecolorfactor)\n\t */\n\tpublic getBaseColorTexture(): Texture {\n\t\treturn this.baseColorTexture ? this.baseColorTexture.getChild() : null;\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its base color texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getBaseColorTextureInfo(): TextureInfo {\n\t\treturn this.baseColorTexture ? this.baseColorTextureInfo.getChild() : null;\n\t}\n\n\t/** Sets base color / albedo texture. See {@link getBaseColorTexture}. */\n\tpublic setBaseColorTexture(texture: Texture): this {\n\t\tthis.baseColorTexture = this.graph.link('baseColorTexture', this, texture);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Emissive.\n\t */\n\n\t/** Emissive color; linear multiplier. See {@link getEmissiveTexture}. */\n\tpublic getEmissiveFactor(): vec3 { return this._emissiveFactor; }\n\n\t/** Sets the emissive color; linear multiplier. See {@link getEmissiveTexture}. */\n\tpublic setEmissiveFactor(emissiveFactor: vec3): this {\n\t\tthis._emissiveFactor = emissiveFactor;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Emissive as hexadecimal in sRGB colorspace. Converted automatically from\n\t * emissiveFactor in linear space. See {@link getBaseColorTexture}.\n\t */\n\tpublic getEmissiveHex(): number {\n\t\treturn ColorUtils.factorToHex(this._emissiveFactor);\n\t}\n\n\t/**\n\t * Sets emissive as hexadecimal in sRGB colorspace. Converted automatically to\n\t * emissiveFactor in linear space. See {@link getEmissiveTexture}.\n\t */\n\tpublic setEmissiveHex(hex: number): this {\n\t\tColorUtils.hexToFactor(hex, this._emissiveFactor);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Emissive texture. Emissive color is added to any base color of the material, after any\n\t * lighting/shadowing are applied. An emissive color does not inherently \"glow\", or affect\n\t * objects around it at all. To create that effect, most viewers must also enable a\n\t * post-processing effect called \"bloom\".\n\t *\n\t * Reference:\n\t * - [glTF → material.emissiveTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialemissivetexture)\n\t */\n\tpublic getEmissiveTexture(): Texture {\n\t\treturn this.emissiveTexture ? this.emissiveTexture.getChild() : null;\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its emissive texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getEmissiveTextureInfo(): TextureInfo {\n\t\treturn this.emissiveTexture ? this.emissiveTextureInfo.getChild() : null;\n\t}\n\n\t/** Sets emissive texture. See {@link getEmissiveTexture}. */\n\tpublic setEmissiveTexture(texture: Texture): this {\n\t\tthis.emissiveTexture = this.graph.link('emissiveTexture', this, texture);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Normal.\n\t */\n\n\t/** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tpublic getNormalScale(): number { return this. _normalScale; }\n\n\t/** Sets normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */\n\tpublic setNormalScale(normalScale: number): this {\n\t\tthis._normalScale = normalScale;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Normal (surface detail) texture.\n\t *\n\t * A tangent space normal map. The texture contains RGB components in linear space. Each texel\n\t * represents the XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X\n\t * [-1 to 1]. Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1].\n\t * The normal vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward\n\t * the viewer.\n\t *\n\t * Reference:\n\t * - [glTF → material.normalTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialnormaltexture)\n\t */\n\tpublic getNormalTexture(): Texture {\n\t\treturn this.normalTexture ? this.normalTexture.getChild() : null;\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its normal texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getNormalTextureInfo(): TextureInfo {\n\t\treturn this.normalTexture ? this.normalTextureInfo.getChild() : null;\n\t}\n\n\t/** Sets normal (surface detail) texture. See {@link getNormalTexture}. */\n\tpublic setNormalTexture(texture: Texture): this {\n\t\tthis.normalTexture = this.graph.link('normalTexture', this, texture);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Occlusion.\n\t */\n\n\t/** (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n\tpublic getOcclusionStrength(): number { return this._occlusionStrength; }\n\n\t/** Sets (ambient) occlusion factor; linear multiplier. Affects `.occlusionTexture`. */\n\tpublic setOcclusionStrength(occlusionStrength: number): this {\n\t\tthis._occlusionStrength = occlusionStrength;\n\t\treturn this;\n\t}\n\n\t/**\n\t * (Ambient) Occlusion texture, generally used for subtle 'baked' shadowing effects that are\n\t * independent of an object's position, such as shading in inset areas and corners. Direct\n\t * lighting is not affected by occlusion, so at least one indirect light source must be present\n\t * in the scene for occlusion effects to be visible.\n\t *\n\t * The occlusion values are sampled from the R channel. Higher values indicate areas that\n\t * should receive full indirect lighting and lower values indicate no indirect lighting.\n\t *\n\t * Reference:\n\t * - [glTF → material.occlusionTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialocclusiontexture)\n\t */\n\tpublic getOcclusionTexture(): Texture {\n\t\treturn this.occlusionTexture ? this.occlusionTexture.getChild() : null;\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its occlusion texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getOcclusionTextureInfo(): TextureInfo {\n\t\treturn this.occlusionTexture ? this.occlusionTextureInfo.getChild() : null;\n\t}\n\n\t/** Sets (ambient) occlusion texture. See {@link getOcclusionTexture}. */\n\tpublic setOcclusionTexture(texture: Texture): this {\n\t\tthis.occlusionTexture = this.graph.link('occlusionTexture', this, texture);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Metallic / roughness.\n\t */\n\n\t/**\n\t * Roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic getRoughnessFactor(): number { return this._roughnessFactor; }\n\n\t/**\n\t * Sets roughness factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic setRoughnessFactor(roughnessFactor: number): this {\n\t\tthis._roughnessFactor = roughnessFactor;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Metallic factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic getMetallicFactor(): number { return this._metallicFactor; }\n\n\t/**\n\t * Sets metallic factor; linear multiplier. Affects roughness channel of\n\t * `metallicRoughnessTexture`. See {@link getMetallicRoughnessTexture}.\n\t */\n\tpublic setMetallicFactor(metallicFactor: number): this {\n\t\tthis._metallicFactor = metallicFactor;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Metallic roughness texture. The metalness values are sampled from the B channel. The\n\t * roughness values are sampled from the G channel. When a material is fully metallic,\n\t * or nearly so, it may require image-based lighting (i.e. an environment map) or global\n\t * illumination to appear well-lit.\n\t *\n\t * Reference:\n\t * - [glTF → material.pbrMetallicRoughness.metallicRoughnessTexture](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture)\n\t */\n\tpublic getMetallicRoughnessTexture(): Texture {\n\t\treturn this.metallicRoughnessTexture ? this.metallicRoughnessTexture.getChild() : null;\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its metallic/roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getMetallicRoughnessTextureInfo(): TextureInfo {\n\t\treturn this.metallicRoughnessTexture ? this.metallicRoughnessTextureInfo.getChild() : null;\n\t}\n\n\t/** Sets metallic/roughness texture. See {@link getMetallicRoughnessTexture}. */\n\tpublic setMetallicRoughnessTexture(texture: Texture): this {\n\t\tthis.metallicRoughnessTexture = this.graph.link('metallicRoughnessTexture', this, texture);\n\t\treturn this;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChildList } from '../graph/index';\nimport { Link } from '../graph/index';\nimport { ExtensibleProperty } from './extensible-property';\nimport { Primitive } from './primitive';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Mesh\n *\n * *Meshes define reusable geometry (triangles, lines, or points) and are instantiated by\n * {@link Node}s.*\n *\n * Each draw call required to render a mesh is represented as a {@link Primitive}. Meshes typically\n * have only a single {@link Primitive}, but may have more for various reasons. A mesh manages only\n * a list of primitives — materials, morph targets, and other properties are managed on a per-\n * primitive basis.\n *\n * When the same geometry and material should be rendered at multiple places in the scene, reuse\n * the same Mesh instance and attach it to multiple nodes for better efficiency. Where the geometry\n * is shared but the material is not, reusing {@link Accessor}s under different meshes and\n * primitives can similarly improve transmission efficiency, although some rendering efficiency is\n * lost as the number of materials in a scene increases.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor);\n * const mesh = doc.createMesh('myMesh')\n * \t.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nexport class Mesh extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.MESH;\n\n\tprivate _weights: number[] = [];\n\n\t/** @hidden Primitive GPU draw call list. */\n\t@GraphChildList private primitives: Link<Mesh, Primitive>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._weights = [...other._weights];\n\n\t\tthis.clearGraphChildList(this.primitives);\n\t\tother.primitives.forEach((link) => this.addPrimitive(resolve(link.getChild())));\n\n\t\treturn this;\n\t}\n\n\t/** Adds a {@link Primitive} to the mesh's draw call list. */\n\tpublic addPrimitive(primitive: Primitive): this {\n\t\treturn this.addGraphChild(this.primitives, this.graph.link('primitive', this, primitive));\n\t}\n\n\t/** Removes a {@link Primitive} from the mesh's draw call list. */\n\tpublic removePrimitive(primitive: Primitive): this {\n\t\treturn this.removeGraphChild(this.primitives, primitive);\n\t}\n\n\t/** Lists {@link Primitive} draw calls of the mesh. */\n\tpublic listPrimitives(): Primitive[] {\n\t\treturn this.primitives.map((p) => p.getChild());\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n\t * have the same number of targets. Most engines only support 4-8 active morph targets at a\n\t * time.\n\t */\n\tpublic getWeights(): number[] {\n\t\treturn this._weights;\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must\n\t * have the same number of targets. Most engines only support 4-8 active morph targets at a\n\t * time.\n\t */\n\tpublic setWeights(weights: number[]): this {\n\t\tthis._weights = weights;\n\t\treturn this;\n\t}\n}\n","import { fromRotationTranslationScale, getRotation, getScaling, getTranslation, multiply } from 'gl-matrix/mat4'\nimport { PropertyType, mat4, vec3, vec4 } from '../constants';\nimport { GraphChild, GraphChildList } from '../graph/graph-decorators';\nimport { Link } from '../graph/graph-links';\nimport { Camera } from './camera';\nimport { ExtensibleProperty } from './extensible-property';\nimport { Mesh } from './mesh';\nimport { COPY_IDENTITY } from './property';\nimport { Skin } from './skin';\n\n/**\n * # Node\n *\n * *Nodes are the objects that comprise a {@link Scene}.*\n *\n * Each node may have one or more children, and a transform (position, rotation, and scale) that\n * applies to all of its descendants. A node may also reference (or \"instantiate\") other resources\n * at its location, including {@link Mesh}, Camera, Light, and Skin properties. A node cannot be\n * part of more than one {@link Scene}.\n *\n * A node's local transform is represented with array-like objects, intended to be compatible with\n * [gl-matrix](https://github.com/toji/gl-matrix), or with the `toArray`/`fromArray` methods of\n * libraries like three.js and babylon.js.\n *\n * Usage:\n *\n * ```ts\n * const node = doc.createNode('myNode')\n * \t.setMesh(mesh)\n * \t.setTranslation([0, 0, 0])\n * \t.addChild(otherNode);\n * ```\n *\n * References:\n * - [glTF → Nodes and Hierarchy](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#nodes-and-hierarchy)\n *\n * @category Properties\n */\nexport class Node extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.NODE;\n\tprivate _translation: vec3 = [0, 0, 0];\n\tprivate _rotation: vec4 = [0, 0, 0, 1];\n\tprivate _scale: vec3 = [1, 1, 1];\n\tprivate _weights: number[] = [];\n\n\t/** @hidden Internal reference to node's parent, omitted from {@link Graph}. */\n\tpublic _parent: SceneNode = null;\n\n\t@GraphChild private camera: Link<Node, Camera> = null;\n\t@GraphChild private mesh: Link<Node, Mesh> = null;\n\t@GraphChild private skin: Link<Node, Skin> = null;\n\t@GraphChildList private children: Link<Node, Node>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._translation = [...other._translation] as vec3;\n\t\tthis._rotation = [...other._rotation] as vec4;\n\t\tthis._scale = [...other._scale] as vec3;\n\t\tthis._weights = [...other._weights];\n\n\t\tif (other.camera) this.setCamera(resolve(other.camera.getChild()));\n\t\tif (other.mesh) this.setMesh(resolve(other.mesh.getChild()));\n\t\tif (other.skin) this.setSkin(resolve(other.skin.getChild()));\n\n\t\tif (resolve !== COPY_IDENTITY) {\n\t\t\tthis.clearGraphChildList(this.children);\n\t\t\tother.children.forEach((link) => this.addChild(resolve(link.getChild())));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Local transform.\n\t */\n\n\t/** Returns the translation (position) of this node in local space. */\n\tpublic getTranslation(): vec3 { return this._translation; }\n\n\t/** Returns the rotation (quaternion) of this node in local space. */\n\tpublic getRotation(): vec4 { return this._rotation; }\n\n\t/** Returns the scale of this node in local space. */\n\tpublic getScale(): vec3 { return this._scale; }\n\n\t/** Sets the translation (position) of this node in local space. */\n\tpublic setTranslation(translation: vec3): this {\n\t\tthis._translation = translation;\n\t\treturn this;\n\t}\n\n\t/** Sets the rotation (quaternion) of this node in local space. */\n\tpublic setRotation(rotation: vec4): this {\n\t\tthis._rotation = rotation;\n\t\treturn this;\n\t}\n\n\t/** Sets the scale of this node in local space. */\n\tpublic setScale(scale: vec3): this {\n\t\tthis._scale = scale;\n\t\treturn this;\n\t}\n\n\t/** Returns the local matrix of this node. */\n\tpublic getMatrix(): mat4 {\n\t\treturn fromRotationTranslationScale([], this._rotation, this._translation, this._scale);\n\t}\n\n\t/**********************************************************************************************\n\t * World transform.\n\t */\n\n\t/** Returns the translation (position) of this node in world space. */\n\tpublic getWorldTranslation(): vec3 {\n\t\treturn getTranslation([], this.getWorldMatrix());\n\t}\n\n\t/** Returns the rotation (quaternion) of this node in world space. */\n\tpublic getWorldRotation(): vec4 {\n\t\treturn getRotation([], this.getWorldMatrix());\n\t}\n\n\t/** Returns the scale of this node in world space. */\n\tpublic getWorldScale(): vec3 {\n\t\treturn getScaling([], this.getWorldMatrix());\n\t}\n\n\t/** Returns the world matrix of this node. */\n\tpublic getWorldMatrix(): mat4 {\n\t\t// Build ancestor chain.\n\t\tconst ancestors: Node[] = [];\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\tfor (let node: SceneNode = this; node instanceof Node; node = node._parent) {\n\t\t\tancestors.push(node);\n\t\t}\n\n\t\t// Compute world matrix.\n\t\tlet ancestor: Node;\n\t\tconst worldMatrix = ancestors.pop().getMatrix();\n\t\twhile ((ancestor = ancestors.pop())) {\n\t\t\tmultiply(worldMatrix, worldMatrix, ancestor.getMatrix());\n\t\t}\n\n\t\treturn worldMatrix;\n\t}\n\n\t/**********************************************************************************************\n\t * Scene hierarchy.\n\t */\n\n\t/** Adds another node as a child of this one. Nodes cannot have multiple parents. */\n\tpublic addChild(child: Node): this {\n\t\t// Remove existing parent.\n\t\tif (child._parent) child._parent.removeChild(child);\n\n\t\t// Link in graph.\n\t\tconst link = this.graph.link('child', this, child);\n\t\tthis.addGraphChild(this.children, link);\n\n\t\t// Set new parent.\n\t\tchild._parent = this;\n\t\tlink.onDispose(() => child._parent = null);\n\t\treturn this;\n\t}\n\n\t/** Removes a node from this node's child node list. */\n\tpublic removeChild(child: Node): this {\n\t\treturn this.removeGraphChild(this.children, child)\n\t}\n\n\t/** Lists all child nodes of this node. */\n\tpublic listChildren(): Node[] {\n\t\treturn this.children.map((link) => link.getChild());\n\t}\n\n\t/**\n\t * Returns the unique parent ({@link Scene}, {@link Node}, or null) of this node in the scene\n\t * hierarchy. Unrelated to {@link Property.listParents}, which lists all resource references.\n\t */\n\tpublic getParent(): SceneNode {\n\t\treturn this._parent;\n\t}\n\n\t/**********************************************************************************************\n\t * Attachments.\n\t */\n\n\t/** Returns the {@link Mesh}, if any, instantiated at this node. */\n\tpublic getMesh(): Mesh { return this.mesh ? this.mesh.getChild() : null; }\n\n\t/**\n\t * Sets a {@link Mesh} to be instantiated at this node. A single mesh may be instatiated by\n\t * multiple nodes; reuse of this sort is strongly encouraged.\n\t */\n\tpublic setMesh(mesh: Mesh): this {\n\t\tthis.mesh = this.graph.link('mesh', this, mesh);\n\t\treturn this;\n\t}\n\n\t/** Returns the {@link Camera}, if any, instantiated at this node. */\n\tpublic getCamera(): Camera { return this.camera ? this.camera.getChild() : null; }\n\n\t/** Sets a {@link Camera} to be instantiated at this node. */\n\tpublic setCamera(camera: Camera): this {\n\t\tthis.camera = this.graph.link('camera', this, camera);\n\t\treturn this;\n\t}\n\n\t/** Returns the {@link Skin}, if any, instantiated at this node. */\n\tpublic getSkin(): Skin { return this.skin ? this.skin.getChild() : null; }\n\n\t/** Sets a {@link Skin} to be instantiated at this node. */\n\tpublic setSkin(skin: Skin): this {\n\t\tthis.skin = this.graph.link('skin', this, skin);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this node.\n\t * Most engines only support 4-8 active morph targets at a time.\n\t */\n\tpublic getWeights(): number[] {\n\t\treturn this._weights;\n\t}\n\n\t/**\n\t * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this node.\n\t * Most engines only support 4-8 active morph targets at a time.\n\t */\n\tpublic setWeights(weights: number[]): this {\n\t\tthis._weights = weights;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Helpers.\n\t */\n\n\t/** Visits this {@link Node} and its descendants, top-down. */\n\tpublic traverse(fn: (node: Node) => void): this {\n\t\tfn(this);\n\t\tfor (const child of this.listChildren()) child.traverse(fn);\n\t\treturn this;\n\t}\n}\n\ninterface SceneNode {\n\t_parent?: SceneNode;\n\taddChild(node: Node): this;\n\tremoveChild(node: Node): this;\n}\n","import { PropertyType } from '../constants';\nimport { GraphChild, GraphChildList } from '../graph/index';\nimport { Link } from '../graph/index';\nimport { Accessor } from './accessor';\nimport { Material } from './material';\nimport { PrimitiveTarget } from './primitive-target';\nimport { COPY_IDENTITY, Property } from './property';\nimport { AttributeLink } from './property-links';\n\n/**\n * # Primitive\n *\n * *Primitives are individual GPU draw calls comprising a {@link Mesh}.*\n *\n * Meshes typically have only a single Primitive, although various cases may require more. Each\n * primitive may be assigned vertex attributes, morph target attributes, and a material. Any of\n * these properties should be reused among multiple primitives where feasible.\n *\n * Primitives cannot be moved independently of other primitives within the same mesh, except\n * through the use of morph targets and skinning. If independent movement or other runtime\n * behavior is necessary (like raycasting or collisions) prefer to assign each primitive to a\n * different mesh. The number of GPU draw calls is typically not unaffected by grouping or\n * ungrouping primitives to a mesh.\n *\n * Each primitive may optionally be deformed by one or more morph targets, stored in a\n * {@link PrimitiveTarget}.\n *\n * Usage:\n *\n * ```ts\n * const primitive = doc.createPrimitive()\n * \t.setAttribute('POSITION', positionAccessor)\n * \t.setAttribute('TEXCOORD_0', uvAccessor)\n * \t.setMaterial(material);\n * mesh.addPrimitive(primitive);\n * node.setMesh(mesh);\n * ```\n *\n * References:\n * - [glTF → Geometry](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry)\n *\n * @category Properties\n */\nexport class Primitive extends Property {\n\tpublic readonly propertyType = PropertyType.PRIMITIVE;\n\n\t/** @hidden GPU draw mode. */\n\tprivate _mode: GLTF.MeshPrimitiveMode = GLTF.MeshPrimitiveMode.TRIANGLES;\n\n\t@GraphChild private material: Link<Primitive, Material> = null;\n\t@GraphChild private indices: Link<Primitive, Accessor> = null;\n\t@GraphChildList private attributes: AttributeLink[] = [];\n\t@GraphChildList private targets: Link<Primitive, PrimitiveTarget>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._mode = other._mode;\n\n\t\tif (other.indices) this.setIndices(resolve(other.indices.getChild()));\n\t\tif (other.material) this.setMaterial(resolve(other.material.getChild()));\n\n\t\tthis.clearGraphChildList(this.attributes);\n\t\tother.listSemantics().forEach((semantic) => {\n\t\t\tthis.setAttribute(semantic, resolve(other.getAttribute(semantic)));\n\t\t});\n\n\t\tthis.clearGraphChildList(this.targets);\n\t\tother.targets.forEach((link) => this.addTarget(resolve(link.getChild())));\n\n\t\treturn this;\n\t}\n\n\t/** Returns an {@link Accessor} with indices of vertices to be drawn. */\n\tpublic getIndices(): Accessor {\n\t\treturn this.indices ? this.indices.getChild() : null;\n\t}\n\n\t/**\n\t * Sets an {@link Accessor} with indices of vertices to be drawn. In `TRIANGLES` draw mode,\n\t * each set of three indices define a triangle. The front face has a counter-clockwise (CCW)\n\t * winding order.\n\t */\n\tpublic setIndices(indices: Accessor): this {\n\t\tthis.indices = this.graph.linkIndex('index', this, indices);\n\t\treturn this;\n\t}\n\n\t/** Returns a vertex attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor {\n\t\tconst link = this.attributes.find((link) => link.semantic === semantic);\n\t\treturn link ? link.getChild() : null;\n\t}\n\n\t/**\n\t * Sets a vertex attribute to an {@link Accessor}. All attributes must have the same vertex\n\t * count.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor): this {\n\t\t// Remove previous attribute.\n\t\tconst prevAccessor = this.getAttribute(semantic);\n\t\tif (prevAccessor) this.removeGraphChild(this.attributes, prevAccessor);\n\n\t\t// Stop if deleting the attribute.\n\t\tif (!accessor) return this;\n\n\t\t// Add next attribute.\n\t\tconst link = this.graph.linkAttribute(semantic.toLowerCase(), this, accessor) as AttributeLink;\n\t\tlink.semantic = semantic;\n\t\treturn this.addGraphChild(this.attributes, link);\n\t}\n\n\t/**\n\t * Lists all vertex attribute {@link Accessor}s associated with the primitive, excluding any\n\t * attributes used for morph targets. For example, `[positionAccessor, normalAccessor,\n\t * uvAccessor]`. Order will be consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.attributes.map((link) => link.getChild());\n\t}\n\n\t/**\n\t * Lists all vertex attribute semantics associated with the primitive, excluding any semantics\n\t * used for morph targets. For example, `['POSITION', 'NORMAL', 'TEXCOORD_0']`. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.attributes.map((link) => link.semantic);\n\t}\n\n\t/** Returns the material used to render the primitive. */\n\tpublic getMaterial(): Material { return this.material ? this.material.getChild() : null; }\n\n\t/** Sets the material used to render the primitive. */\n\tpublic setMaterial(material: Material): this {\n\t\tthis.material = this.graph.link('material', this, material);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n\t *\n\t * Reference:\n\t * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#primitivemode)\n\t */\n\tpublic getMode(): GLTF.MeshPrimitiveMode { return this._mode; }\n\n\t/**\n\t * Sets the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.\n\t *\n\t * Reference:\n\t * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#primitivemode)\n\t */\n\tpublic setMode(mode: GLTF.MeshPrimitiveMode): this {\n\t\tthis._mode = mode;\n\t\treturn this;\n\t}\n\n\t/** Lists all morph targets associated with the primitive. */\n\tpublic listTargets(): PrimitiveTarget[] {\n\t\treturn this.targets.map((link) => link.getChild());\n\t}\n\n\t/**\n\t * Adds a morph target to the primitive. All primitives in the same mesh must have the same\n\t * number of targets.\n\t */\n\tpublic addTarget(target: PrimitiveTarget): this {\n\t\tthis.addGraphChild(this.targets, this.graph.link('target', this, target));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes a morph target from the primitive. All primitives in the same mesh must have the same\n\t * number of targets.\n\t */\n\tpublic removeTarget(target: PrimitiveTarget): this {\n\t\treturn this.removeGraphChild(this.targets, target);\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChildList } from '../graph/index';\nimport { Accessor } from './accessor';\nimport { COPY_IDENTITY, Property } from './property';\nimport { AttributeLink } from './property-links';\n\n/**\n * # PrimitiveTarget\n *\n * *Morph target or shape key used to deform one {@link Primitive} in a {@link Mesh}.*\n *\n * A PrimitiveTarget contains a `POSITION` attribute (and optionally `NORMAL` and `TANGENT`) that\n * can additively deform the base attributes on a {@link Mesh} {@link Primitive}. Vertex values\n * of `0, 0, 0` in the target will have no effect, whereas a value of `0, 1, 0` would offset that\n * vertex in the base geometry by y+=1. Morph targets can be fully or partially applied: their\n * default state is controlled by {@link Mesh.getWeights}, which can also be overridden for a\n * particular instantiation of a {@link Mesh}, using {@link Node.getWeights}.\n *\n * Reference:\n * - [glTF → Morph Targets](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets)\n */\nexport class PrimitiveTarget extends Property {\n\tpublic readonly propertyType = PropertyType.PRIMITIVE_TARGET;\n\n\t/** @hidden Vertex attributes. */\n\t@GraphChildList private attributes: AttributeLink[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis.clearGraphChildList(this.attributes);\n\t\tother.listSemantics().forEach((semantic) => {\n\t\t\tthis.setAttribute(semantic, resolve(other.getAttribute(semantic)));\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** Returns a morph target vertex attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor {\n\t\tconst link = this.attributes.find((link) => link.semantic === semantic);\n\t\treturn link ? link.getChild() : null;\n\t}\n\n\t/**\n\t * Sets a morph target vertex attribute to an {@link Accessor}.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor): this {\n\t\t// Remove previous attribute.\n\t\tconst prevAccessor = this.getAttribute(semantic);\n\t\tif (prevAccessor) this.removeGraphChild(this.attributes, prevAccessor);\n\n\t\t// Stop if deleting the attribute.\n\t\tif (!accessor) return this;\n\n\t\t// Add next attribute.\n\t\tconst link = this.graph.linkAttribute(semantic.toLowerCase(), this, accessor) as AttributeLink;\n\t\tlink.semantic = semantic;\n\t\treturn this.addGraphChild(this.attributes, link);\n\t}\n\n\t/**\n\t * Lists all morph target vertex attribute {@link Accessor}s associated. Order will be\n\t * consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.attributes.map((link) => link.getChild());\n\t}\n\n\t/**\n\t * Lists all morph target vertex attribute semantics associated. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.attributes.map((link) => link.semantic);\n\t}\n}\n","import { PropertyType, VERSION } from '../constants';\nimport { Extension } from '../extension';\nimport { GraphChildList, Link } from '../graph/index';\nimport { Accessor } from './accessor';\nimport { Animation } from './animation';\nimport { Buffer } from './buffer';\nimport { Camera } from './camera';\nimport { Material } from './material';\nimport { Mesh } from './mesh';\nimport { Node } from './node';\nimport { COPY_IDENTITY, Property } from './property';\nimport { Scene } from './scene';\nimport { Skin } from './skin';\nimport { Texture } from './texture';\n\n/**\n * # Root\n *\n * *Root property of a glTF asset.*\n *\n * Any properties to be exported with a particular asset must be referenced (directly or\n * indirectly) by the root. Metadata about the asset's license, generator, and glTF specification\n * version are stored in the asset, accessible with {@link .getAsset}().\n *\n * Properties are added to the root with factory methods on its {@link Document}, and removed by\n * calling {@link Property.dispose}() on the resource. Any properties that have been created but\n * not disposed will be included when calling the various `root.list*()` methods.\n *\n * A document's root cannot be removed, and no other root may be created. Unlike other\n * {@link Property} types, the `.dispose()`, `.detach()` methods have no useful function on a\n * Root property.\n *\n * Usage:\n *\n * ```ts\n * const root = document.getRoot();\n * const scene = document.createScene('myScene');\n * const node = document.createNode('myNode');\n * scene.addChild(node);\n *\n * console.log(root.listScenes()); // → [scene x 1]\n * ```\n *\n * Reference: [glTF → Concepts](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#concepts)\n *\n * @category Properties\n */\nexport class Root extends Property {\n\tpublic readonly propertyType = PropertyType.ROOT;\n\n\tprivate readonly _asset: GLTF.IAsset = {\n\t\tgenerator: `glTF-Transform ${VERSION}`,\n\t\tversion: '2.0'\n\t};\n\n\tprivate readonly _extensions: Set<Extension> = new Set();\n\n\t@GraphChildList private accessors: Link<Root, Accessor>[] = [];\n\t@GraphChildList private animations: Link<Root, Animation>[] = [];\n\t@GraphChildList private buffers: Link<Root, Buffer>[] = [];\n\t@GraphChildList private cameras: Link<Root, Camera>[] = [];\n\t@GraphChildList private materials: Link<Root, Material>[] = [];\n\t@GraphChildList private meshes: Link<Root, Mesh>[] = [];\n\t@GraphChildList private nodes: Link<Root, Node>[] = [];\n\t@GraphChildList private scenes: Link<Root, Scene>[] = [];\n\t@GraphChildList private skins: Link<Root, Skin>[] = [];\n\t@GraphChildList private textures: Link<Root, Texture>[] = [];\n\n\tpublic clone(): this {\n\t\tthrow new Error('Root cannot be cloned.');\n\t}\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\t// Root cannot be cloned in isolation: only with its Document. Extensions are managed by\n\t\t// the Document during cloning. The Root, and only the Root, should avoid calling\n\t\t// .clearGraphChildList() while copying to avoid overwriting existing links during a merge.\n\t\tif (!resolve) throw new Error('Root cannot be copied.');\n\n\t\tObject.assign(this._asset, other._asset);\n\n\t\tother.accessors.forEach((link) => this._addAccessor(resolve(link.getChild())));\n\t\tother.animations.forEach((link) => this._addAnimation(resolve(link.getChild())));\n\t\tother.buffers.forEach((link) => this._addBuffer(resolve(link.getChild())));\n\t\tother.cameras.forEach((link) => this._addCamera(resolve(link.getChild())));\n\t\tother.materials.forEach((link) => this._addMaterial(resolve(link.getChild())));\n\t\tother.meshes.forEach((link) => this._addMesh(resolve(link.getChild())));\n\t\tother.nodes.forEach((link) => this._addNode(resolve(link.getChild())));\n\t\tother.scenes.forEach((link) => this._addScene(resolve(link.getChild())));\n\t\tother.skins.forEach((link) => this._addSkin(resolve(link.getChild())));\n\t\tother.textures.forEach((link) => this._addTexture(resolve(link.getChild())));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the `asset` object, which specifies the target glTF version of the asset. Additional\n\t * metadata can be stored in optional properties such as `generator` or `copyright`.\n\t *\n\t * Reference: [glTF → Asset](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#asset)\n\t */\n\tpublic getAsset(): GLTF.IAsset { return this._asset; }\n\n\t/**********************************************************************************************\n\t * Extensions.\n\t */\n\n\t/** Lists all {@link Extension} properties enabled for this root. */\n\tpublic listExtensionsUsed(): Extension[] {\n\t\treturn Array.from(this._extensions);\n\t}\n\n\t/** Lists all {@link Extension} properties enabled and required for this root. */\n\tpublic listExtensionsRequired(): Extension[] {\n\t\treturn this.listExtensionsUsed().filter((extension) => extension.isRequired());\n\t}\n\n\t/** @hidden */\n\tpublic _enableExtension(extension: Extension): this {\n\t\tif (this._extensions.has(extension)) {\n\t\t\tthrow new Error(`Extension \"${extension.extensionName}\" is already enabled.`);\n\t\t}\n\t\tthis._extensions.add(extension);\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic _disableExtension(extension: Extension): this {\n\t\tthis._extensions.delete(extension);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Scenes.\n\t */\n\n\t/**\n\t * Adds a new {@link Scene} to the root list.\n\t * @hidden\n\t */\n\tpublic _addScene(scene: Scene): this {\n\t\treturn this.addGraphChild(this.scenes, this.graph.link('scene', this, scene));\n\t}\n\n\t/** Lists all {@link Scene} properties associated with this root. */\n\tpublic listScenes(): Scene[] {\n\t\treturn this.scenes.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Nodes.\n\t */\n\n\t/**\n\t * Adds a new {@link Node} to the root list.\n\t * @hidden\n\t */\n\tpublic _addNode(node: Node): this {\n\t\treturn this.addGraphChild(this.nodes, this.graph.link('node', this, node));\n\t}\n\n\t/** Lists all {@link Node} properties associated with this root. */\n\tpublic listNodes(): Node[] {\n\t\treturn this.nodes.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Cameras.\n\t */\n\n\t/**\n\t * Adds a new {@link Camera} to the root list.\n\t * @hidden\n\t */\n\tpublic _addCamera(camera: Camera): this {\n\t\treturn this.addGraphChild(this.cameras, this.graph.link('camera', this, camera));\n\t}\n\n\t/** Lists all {@link Camera} properties associated with this root. */\n\tpublic listCameras(): Camera[] {\n\t\treturn this.cameras.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Skins.\n\t */\n\n\t/**\n\t * Adds a new {@link Skin} to the root list.\n\t * @hidden\n\t */\n\tpublic _addSkin(skin: Skin): this {\n\t\treturn this.addGraphChild(this.skins, this.graph.link('skin', this, skin));\n\t}\n\n\t/** Lists all {@link Skin} properties associated with this root. */\n\tpublic listSkins(): Skin[] {\n\t\treturn this.skins.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Meshes.\n\t */\n\n\t/**\n\t * Adds a new {@link Mesh} to the root list.\n\t * @hidden\n\t */\n\tpublic _addMesh(mesh: Mesh): this {\n\t\treturn this.addGraphChild(this.meshes, this.graph.link('mesh', this, mesh));\n\t}\n\n\t/** Lists all {@link Mesh} properties associated with this root. */\n\tpublic listMeshes(): Mesh[] {\n\t\treturn this.meshes.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Materials.\n\t */\n\n\t/**\n\t * Adds a new {@link Material} to the root list.\n\t * @hidden\n\t */\n\tpublic _addMaterial(material: Material): this {\n\t\treturn this.addGraphChild(this.materials, this.graph.link('material', this, material));\n\t}\n\n\t/** Lists all {@link Material} properties associated with this root. */\n\tpublic listMaterials(): Material[] {\n\t\treturn this.materials.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Textures.\n\t */\n\n\t/**\n\t * Adds a new {@link Texture} to the root list.\n\t * @hidden\n\t */\n\tpublic _addTexture(texture: Texture): this {\n\t\treturn this.addGraphChild(this.textures, this.graph.link('texture', this, texture));\n\t}\n\n\n\t/** Lists all {@link Texture} properties associated with this root. */\n\tpublic listTextures(): Texture[] {\n\t\treturn this.textures.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Animations.\n\t */\n\n\t/**\n\t * Adds a new {@link Animation} to the root list.\n\t * @hidden\n\t */\n\tpublic _addAnimation(animation: Animation): this {\n\t\treturn this.addGraphChild(this.animations, this.graph.link('animation', this, animation));\n\t}\n\n\t/** Lists all {@link Animation} properties associated with this root. */\n\tpublic listAnimations(): Animation[] {\n\t\treturn this.animations.map((p) => p.getChild());\n\t}\n\n\n\t/**********************************************************************************************\n\t * Accessors.\n\t */\n\n\t/**\n\t * Adds a new {@link Accessor} to the root list.\n\t * @hidden\n\t */\n\tpublic _addAccessor(accessor: Accessor): this {\n\t\treturn this.addGraphChild(this.accessors, this.graph.link('accessor', this, accessor));\n\t}\n\n\t/** Lists all {@link Accessor} properties associated with this root. */\n\tpublic listAccessors(): Accessor[] {\n\t\treturn this.accessors.map((p) => p.getChild());\n\t}\n\n\t/**********************************************************************************************\n\t * Buffers.\n\t */\n\n\t/**\n\t * Adds a new {@link Buffer} to the root list.\n\t * @hidden\n\t */\n\tpublic _addBuffer(buffer: Buffer): this {\n\t\treturn this.addGraphChild(this.buffers, this.graph.link('buffer', this, buffer));\n\t}\n\n\t/** Lists all {@link Buffer} properties associated with this root. */\n\tpublic listBuffers(): Buffer[] {\n\t\treturn this.buffers.map((p) => p.getChild());\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChildList, Link } from '../graph/index';\nimport { ExtensibleProperty } from './extensible-property';\nimport { Node } from './node';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Scene\n *\n * *Scenes represent a set of visual objects to render.*\n *\n * Typically a glTF file contains only a single scene, although more are allowed and useful in some\n * cases. No particular meaning is associated with additional scenes, except as defined by the\n * application. Scenes reference {@link Node}s, and a single node cannot be a member of more than\n * one scene.\n *\n * References:\n * - [glTF → Scenes](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#scenes)\n * - [glTF → Coordinate System and Units](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#coordinate-system-and-units)\n *\n * @category Properties\n */\nexport class Scene extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.SCENE;\n\n\t@GraphChildList private children: Link<Scene, Node>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tif (resolve !== COPY_IDENTITY) {\n\t\t\tthis.clearGraphChildList(this.children);\n\t\t\tother.children.forEach((link) => this.addChild(resolve(link.getChild())));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** Adds a {@link Node} to the scene. */\n\tpublic addChild(node: Node): this {\n\t\t// Remove existing parent.\n\t\tif (node._parent) node._parent.removeChild(node);\n\n\t\t// Link in graph.\n\t\tconst link = this.graph.link('child', this, node);\n\t\tthis.addGraphChild(this.children, link);\n\n\t\t// Set new parent.\n\t\tnode._parent = this;\n\t\tlink.onDispose(() => node._parent = null);\n\t\treturn this;\n\t}\n\n\t/** Removes a {@link Node} from the scene. */\n\tpublic removeChild(node: Node): this {\n\t\treturn this.removeGraphChild(this.children, node);\n\t}\n\n\t/** Lists all root {@link Node}s in the scene. */\n\tpublic listChildren(): Node[] {\n\t\treturn this.children.map((p) => p.getChild());\n\t}\n\n\t/** Visits each {@link Node} in the scene, including descendants, top-down. */\n\tpublic traverse(fn: (node: Node) => void): this {\n\t\tfor (const node of this.listChildren()) node.traverse(fn);\n\t\treturn this;\n\t}\n}\n","import { PropertyType } from '../constants';\nimport { GraphChild, GraphChildList, Link } from '../graph';\nimport { Accessor } from './accessor';\nimport { ExtensibleProperty } from './extensible-property';\nimport { Node } from './node';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Skin\n *\n * *Collection of {@link Node} joints and inverse bind matrices used with skinned {@link Mesh}\n * instances.*\n *\n * Reference\n * - [glTF → Skins](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#skins)\n *\n * @category Properties\n */\nexport class Skin extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.SKIN;\n\n\t@GraphChild private skeleton: Link<Skin, Node> = null;\n\t@GraphChild private inverseBindMatrices: Link<Skin, Accessor> = null;\n\t@GraphChildList private joints: Link<Skin, Node>[] = [];\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tif (other.skeleton) this.setSkeleton(resolve(other.skeleton.getChild()));\n\t\tif (other.inverseBindMatrices) this.setInverseBindMatrices(resolve(other.inverseBindMatrices.getChild()));\n\n\t\tthis.clearGraphChildList(this.joints);\n\t\tother.joints.forEach((link) => this.addJoint(resolve(link.getChild())));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n\t * hierarchy or a direct or indirect parent node of the closest common root.\n\t */\n\tpublic getSkeleton(): Node {\n\t\treturn this.skeleton ? this.skeleton.getChild() : null;\n\t}\n\n\t/**\n\t * {@link Node} used as a skeleton root. The node must be the closest common root of the joints\n\t * hierarchy or a direct or indirect parent node of the closest common root.\n\t */\n\tpublic setSkeleton(skeleton: Node): this {\n\t\tthis.skeleton = this.graph.link('skeleton', this, skeleton);\n\t\treturn this;\n\t}\n\n\t/**\n\t * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n\t * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n\t * pre-applied.\n\t */\n\tpublic getInverseBindMatrices(): Accessor {\n\t\treturn this.inverseBindMatrices ? this.inverseBindMatrices.getChild() : null;\n\t}\n\n\t/**\n\t * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is\n\t * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were\n\t * pre-applied.\n\t */\n\tpublic setInverseBindMatrices(inverseBindMatrices: Accessor): this {\n\t\tthis.inverseBindMatrices = this.graph.link('inverseBindMatrices', this, inverseBindMatrices);\n\t\treturn this;\n\t}\n\n\t/** Adds a joint {@link Node} to this {@link Skin}. */\n\tpublic addJoint(joint: Node): this {\n\t\tconst link = this.graph.link('joint', this, joint);\n\t\treturn this.addGraphChild(this.joints, link);\n\t}\n\n\t/** Removes a joint {@link Node} from this {@link Skin}. */\n\tpublic removeJoint(joint: Node): this {\n\t\treturn this.removeGraphChild(this.joints, joint);\n\t}\n\n\t/** Lists joints ({@link Node}s used as joints or bones) in this {@link Skin}. */\n\tpublic listJoints(): Node[] {\n\t\treturn this.joints.map((link) => link.getChild());\n\t}\n}\n","import { PropertyType, vec2 } from '../constants';\nimport { ImageUtils } from '../utils';\nimport { ExtensibleProperty } from './extensible-property';\nimport { COPY_IDENTITY } from './property';\n\n/**\n * # Texture\n *\n * *Texture, or images, referenced by {@link Material} properties.*\n *\n * Textures in glTF-Transform are a combination of glTF's `texture` and `image` properties, and\n * should be unique within a document, such that no other texture contains the same\n * {@link getImage}() data. Where duplicates may already exist, the `dedup({textures: true})`\n * transform can remove them. A {@link Document} with N texture properties will be exported to a\n * glTF file with N `image` properties, and the minimum number of `texture` properties necessary\n * for the materials that use it.\n *\n * For properties associated with a particular _use_ of a texture, see {@link TextureInfo}.\n *\n * Reference:\n * - [glTF → Textures](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#textures)\n * - [glTF → Images](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#images)\n *\n * @category Properties\n */\nexport class Texture extends ExtensibleProperty {\n\tpublic readonly propertyType = PropertyType.TEXTURE;\n\n\t/** @hidden Raw image data for this texture. */\n\tprivate _image: ArrayBuffer = null;\n\n\t/** @hidden Image MIME type. Required if URI is not set. */\n\tprivate _mimeType = '';\n\n\t/** @hidden Image URI. Required if MIME type is not set. */\n\tprivate _uri = '';\n\n\tpublic copy(other: this, resolve = COPY_IDENTITY): this {\n\t\tsuper.copy(other, resolve);\n\n\t\tthis._mimeType = other._mimeType;\n\t\tthis._uri = other._uri;\n\n\t\tif (other._image) this._image = other._image.slice(0);\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * MIME type / format.\n\t */\n\n\t/** Returns the MIME type for this texture ('image/jpeg' or 'image/png'). */\n\tpublic getMimeType(): string { return this._mimeType; }\n\n\t/**\n\t * Sets the MIME type for this texture ('image/jpeg' or 'image/png'). If the texture does not\n\t * have a URI, a MIME type is required for correct export.\n\t */\n\tpublic setMimeType(mimeType: string): this {\n\t\tthis._mimeType = mimeType;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * URI / filename.\n\t */\n\n\t/** Returns the URI (e.g. 'path/to/file.png') for this texture. */\n\tpublic getURI(): string {\n\t\treturn this._uri;\n\t}\n\n\t/**\n\t * Sets the URI (e.g. 'path/to/file.png') for this texture. If the texture does not have a MIME\n\t * type, a URI is required for correct export.\n\t */\n\tpublic setURI(uri: string): this {\n\t\tthis._uri = uri;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Image data.\n\t */\n\n\t/** Returns the raw image data for this texture. */\n\tpublic getImage(): ArrayBuffer { return this._image; }\n\n\t/** Sets the raw image data for this texture. */\n\tpublic setImage(image: ArrayBuffer): this {\n\t\tthis._image = image;\n\t\treturn this;\n\t}\n\n\t/** Returns the size, in pixels, of this texture. */\n\tpublic getSize(): vec2 {\n\t\tlet isPNG;\n\t\tif (this._mimeType) {\n\t\t\tisPNG = this._mimeType === 'image/png';\n\t\t} else {\n\t\t\tisPNG = this._uri.match(/\\.png$/);\n\t\t}\n\t\treturn isPNG\n\t\t\t? ImageUtils.getSizePNG(this._image)\n\t\t\t: ImageUtils.getSizeJPEG(this._image);\n\t}\n}\n","import { PropertyType } from './constants';\nimport { Extension } from './extension';\nimport { Accessor, Animation, AnimationChannel, AnimationSampler, Buffer, Camera, ExtensionProperty, Material, Mesh, Node, Primitive, PrimitiveTarget, Property, PropertyGraph, Root, Scene, Skin, Texture } from './properties';\nimport { Logger } from './utils';\n\nexport type Transform = (doc: Document) => void;\n\n/**\n * # Document\n *\n * *Wraps a glTF asset and its resources for easier modification.*\n *\n * Documents manage glTF assets and the relationships among dependencies. The document wrapper\n * allow tools to read and write changes without dealing with array indices or byte offsets, which\n * would otherwise require careful management over the course of a file modification. An internal\n * graph structure allows any property in the glTF file to maintain references to its dependencies,\n * and makes it easy to determine where a particular property dependency is being used. For\n * example, finding a list of materials that use a particular texture is as simple as calling\n * {@link Texture.listParents}().\n *\n * A new resource {@link Property} (e.g. a {@link Mesh} or {@link Material}) is created by calling\n * 'create' methods on the document. Resources are destroyed by calling {@link Property.dispose}().\n *\n * ```ts\n * import { Document } from '@gltf-transform/core';\n * import { dedup } from '@gltf-transform/lib';\n *\n * const doc = new Document();\n *\n * const texture1 = doc.createTexture('myTexture')\n * \t.setImage(arrayBuffer)\n * \t.setMimeType('image/png');\n * const texture2 = doc.createTexture('myTexture2')\n * \t.setImage(arrayBuffer)\n * \t.setMimeType('image/png');\n *\n * // Document containing duplicate copies of the same texture.\n * doc.getRoot().listTextures(); // → [texture x 2]\n *\n * await doc.transform(\n * \tdedup({textures: true}),\n * \t// ...\n * );\n *\n * // Document with duplicate textures removed.\n * doc.getRoot().listTextures(); // → [texture x 1]\n * ```\n *\n * Reference:\n * - [glTF → Basics](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#gltf-basics)\n * - [glTF → Concepts](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#concepts)\n *\n * @category Documents\n */\nexport class Document {\n\tprivate _graph: PropertyGraph = new PropertyGraph();\n\tprivate _root: Root = new Root(this._graph);\n\tprivate _logger = Logger.DEFAULT_INSTANCE;\n\n\t/** Returns the glTF {@link Root} property. */\n\tpublic getRoot(): Root {\n\t\treturn this._root;\n\t}\n\n\t/**\n\t * Returns the {@link Graph} representing connectivity of resources within this document.\n\t *\n\t * @hidden\n\t */\n\tpublic getGraph(): PropertyGraph {\n\t\treturn this._graph;\n\t}\n\n\t/** Returns the {@link Logger} instance used for any operations performed on this document. */\n\tpublic getLogger(): Logger {\n\t\treturn this._logger;\n\t}\n\n\t/**\n\t * Overrides the {@link Logger} instance used for any operations performed on this document.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * doc\n\t * \t.setLogger(new Logger(Logger.Verbosity.SILENT))\n\t * \t.transform(split(), ao({samples: 50}));\n\t * ```\n\t */\n\tpublic setLogger(logger: Logger): Document {\n\t\tthis._logger = logger;\n\t\treturn this;\n\t}\n\n\t/** Clones this Document, copying all resources within it. */\n\tpublic clone(): Document {\n\t\treturn new Document().merge(this);\n\t}\n\n\t/** Merges the content of another Document into this one, without affecting the original. */\n\tpublic merge(other: Document): this {\n\t\t// 1. Attach extensions.\n\t\tconst thisExtensions: {[key: string]: Extension} = {};\n\t\tfor (const otherExtension of other.getRoot().listExtensionsUsed()) {\n\t\t\tconst thisExtension = this.createExtension(\n\t\t\t\totherExtension.constructor as new (doc: Document) => Extension\n\t\t\t);\n\t\t\tif (otherExtension.isRequired()) thisExtension.setRequired(true);\n\t\t\tthisExtensions[thisExtension.extensionName] = thisExtension;\n\t\t}\n\n\t\t// 2. Preconfigure the Root and merge history.\n\t\tconst visited = new Set<Property>();\n\t\tconst propertyMap = new Map<Property, Property>();\n\t\tvisited.add(other._root);\n\t\tpropertyMap.set(other._root, this._root);\n\n\t\t// 3. Create stub classes for every Property in other Document.\n\t\tfor (const link of other._graph.getLinks()) {\n\t\t\tfor (const thisProp of [link.getParent() as Property, link.getChild() as Property]) {\n\t\t\t\tif (visited.has(thisProp)) continue;\n\n\t\t\t\tlet otherProp: Property;\n\t\t\t\tif (thisProp.propertyType === PropertyType.TEXTURE_INFO) {\n\t\t\t\t\t// TextureInfo lifecycle is bound to a Material or ExtensionProperty.\n\t\t\t\t\t// TODO(cleanup): Should the lifecycle be decoupled? Maybe just create\n\t\t\t\t\t// TextureInfo automatically when appending a Texture to a Material or\n\t\t\t\t\t// ExtensionProperty that doesn't have one? More work for extensions.\n\t\t\t\t\totherProp = thisProp as Property;\n\t\t\t\t} else {\n\t\t\t\t\t// For other property types, create stub classes.\n\t\t\t\t\tconst PropertyClass = thisProp.constructor as new(g: PropertyGraph, e?: Extension) => Property;\n\t\t\t\t\totherProp = thisProp instanceof ExtensionProperty\n\t\t\t\t\t\t? new PropertyClass(this._graph, thisExtensions[thisProp.extensionName])\n\t\t\t\t\t\t: new PropertyClass(this._graph);\n\t\t\t\t}\n\n\t\t\t\tpropertyMap.set(thisProp as Property, otherProp);\n\t\t\t\tvisited.add(thisProp);\n\t\t\t}\n\t\t}\n\n\t\t// 4. Assemble the links between Properties.\n\t\tconst resolve = (p: Property): Property => propertyMap.get(p);\n\t\tfor (const otherProp of visited) {\n\t\t\tconst thisProp = propertyMap.get(otherProp);\n\t\t\tthisProp.copy(otherProp, resolve);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Applies a series of modifications to this document. Each transformation is synchronous,\n\t * takes the {@link Document} as input, and returns nothing. Transforms are applied in the\n\t * order given, which may affect the final result.\n\t *\n\t * Usage:\n\t *\n\t * ```ts\n\t * await doc.transform(\n\t * \tao({samples: 500}),\n\t * \tprune()\n\t * );\n\t * ```\n\t *\n\t * @param transforms List of synchronous transformation functions to apply.\n\t */\n\tpublic async transform(...transforms: Transform[]): Promise<this> {\n\t\tfor (const transform of transforms) {\n\t\t\tawait transform(this);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Extension factory method.\n\t */\n\n\t/**\n\t * Creates a new {@link Extension}, for the extension type of the given constructor. If the\n\t * extension is already enabled for this Document, the previous Extension reference is reused.\n\t */\n\tcreateExtension<T extends Extension>(ctor: new (doc: Document) => T): T {\n\t\tconst prevExtension = this.getRoot().listExtensionsUsed()\n\t\t\t.find((ext) => ext.extensionName === ctor['EXTENSION_NAME']);\n\t\treturn (prevExtension || new ctor(this)) as T;\n\t}\n\n\t/**********************************************************************************************\n\t * Property factory methods.\n\t */\n\n\t/** Creates a new {@link Scene} attached to this document's {@link Root}. */\n\tcreateScene(name = ''): Scene {\n\t\tconst scene = new Scene(this._graph, name);\n\t\tthis._root._addScene(scene);\n\t\treturn scene;\n\t}\n\n\t/** Creates a new {@link Node} attached to this document's {@link Root}. */\n\tcreateNode(name = ''): Node {\n\t\tconst node = new Node(this._graph, name);\n\t\tthis._root._addNode(node);\n\t\treturn node;\n\t}\n\n\t/** Creates a new {@link Camera} attached to this document's {@link Root}. */\n\tcreateCamera(name = ''): Camera {\n\t\tconst camera = new Camera(this._graph, name);\n\t\tthis._root._addCamera(camera);\n\t\treturn camera;\n\t}\n\n\t/** Creates a new {@link Skin} attached to this document's {@link Root}. */\n\tcreateSkin(name = ''): Skin {\n\t\tconst skin = new Skin(this._graph, name);\n\t\tthis._root._addSkin(skin);\n\t\treturn skin;\n\t}\n\n\t/** Creates a new {@link Mesh} attached to this document's {@link Root}. */\n\tcreateMesh(name = ''): Mesh {\n\t\tconst mesh = new Mesh(this._graph, name);\n\t\tthis._root._addMesh(mesh);\n\t\treturn mesh;\n\t}\n\n\t/**\n\t * Creates a new {@link Primitive}. Primitives must be attached to a {@link Mesh}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreatePrimitive(): Primitive {\n\t\treturn new Primitive(this._graph);\n\t}\n\n\t/**\n\t * Creates a new {@link PrimitiveTarget}, or morph target. Targets must be attached to a\n\t * {@link Primitive} for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreatePrimitiveTarget(name = ''): PrimitiveTarget {\n\t\treturn new PrimitiveTarget(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Material} attached to this document's {@link Root}. */\n\tcreateMaterial(name = ''): Material {\n\t\tconst material = new Material(this._graph, name);\n\t\tthis._root._addMaterial(material);\n\t\treturn material;\n\t}\n\n\t/** Creates a new {@link Texture} attached to this document's {@link Root}. */\n\tcreateTexture(name = ''): Texture {\n\t\tconst texture = new Texture(this._graph, name);\n\t\tthis._root._addTexture(texture);\n\t\treturn texture;\n\t}\n\n\t/** Creates a new {@link Animation} attached to this document's {@link Root}. */\n\tcreateAnimation(name = ''): Animation {\n\t\tconst animation = new Animation(this._graph, name);\n\t\tthis._root._addAnimation(animation);\n\t\treturn animation;\n\t}\n\n\t/**\n\t * Creates a new {@link AnimationChannel}. Channels must be attached to an {@link Animation}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreateAnimationChannel(name = ''): AnimationChannel {\n\t\treturn new AnimationChannel(this._graph, name);\n\t}\n\n\t/**\n\t * Creates a new {@link AnimationSampler}. Samplers must be attached to an {@link Animation}\n\t * for use and export; they are not otherwise associated with a {@link Root}.\n\t */\n\tcreateAnimationSampler(name = ''): AnimationSampler {\n\t\treturn new AnimationSampler(this._graph, name);\n\t}\n\n\t/** Creates a new {@link Accessor} attached to this document's {@link Root}. */\n\tcreateAccessor(name = '', buffer: Buffer = null): Accessor {\n\t\tif (!buffer) {\n\t\t\tbuffer = this.getRoot().listBuffers()[0];\n\t\t}\n\t\tconst accessor = new Accessor(this._graph, name).setBuffer(buffer);\n\t\tthis._root._addAccessor(accessor);\n\t\treturn accessor;\n\t}\n\n\t/** Creates a new {@link Buffer} attached to this document's {@link Root}. */\n\tcreateBuffer(name = ''): Buffer {\n\t\tconst buffer = new Buffer(this._graph, name);\n\t\tthis._root._addBuffer(buffer);\n\t\treturn buffer;\n\t}\n}\n","import { PropertyType } from './constants';\nimport { Document } from './document';\nimport { ReaderContext, WriterContext } from './io';\nimport { ExtensionProperty, ExtensionPropertyParent } from './properties';\n\n/**\n * # Extension\n *\n * *Base class for all Extensions.*\n *\n * Extensions enhance a glTF {@link Document} with additional features and schema, beyond the core\n * glTF specification. Common extensions may be imported from the `@gltf-transform/extensions`\n * package, or custom extensions may be created by extending this base class.\n *\n * An extension is added to a Document by calling {@link Document.createExtension} with the\n * extension constructor. The extension object may then be used to construct\n * {@link ExtensionProperty} instances, which are attached to properties throughout the Document\n * as prescribed by the extension itself.\n *\n * For more information on available extensions and their usage, see [Extensions](/extensions).\n *\n * Reference:\n * - [glTF → Extensions](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#specifying-extensions)\n * - [glTF Extension Registry](https://github.com/KhronosGroup/glTF/blob/master/extensions)\n *\n * @category Extensions\n */\nexport abstract class Extension implements ExtensionPropertyParent {\n\t/** Official name of the extension. */\n\tpublic static EXTENSION_NAME: string;\n\t/** Official name of the extension. */\n\tpublic readonly extensionName: string;\n\t/**\n\t * {@link Property} types this extension will provide. *Most extensions don't need to implement\n\t * this.*\n\t */\n\tpublic readonly provideTypes: PropertyType[] = [];\n\n\t/** Dependency IDs needed by this extension, to be installed before I/O. */\n\tpublic readonly dependencies: string[] = [];\n\n\tprotected required = false;\n\tprotected properties: Set<ExtensionProperty> = new Set();\n\n\t/** @hidden */\n\tconstructor (protected readonly doc: Document) {\n\t\tdoc.getRoot()._enableExtension(this);\n\t}\n\n\t/** Disables and removes the extension from the Document. */\n\tpublic dispose(): void {\n\t\tthis.doc.getRoot()._disableExtension(this);\n\t\tfor (const property of this.properties) {\n\t\t\tproperty.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * Indicates to the client whether it is OK to load the asset when this extension is not\n\t * recognized. Optional extensions are generally preferred, if there is not a good reason\n\t * to require a client to completely fail when an extension isn't known.\n\t */\n\tpublic isRequired(): boolean {\n\t\treturn this.required;\n\t}\n\n\t/**\n\t * Indicates to the client whether it is OK to load the asset when this extension is not\n\t * recognized. Optional extensions are generally preferred, if there is not a good reason\n\t * to require a client to completely fail when an extension isn't known.\n\t */\n\tpublic setRequired(required: boolean): this {\n\t\tthis.required = required;\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * ExtensionPropertyParent implementation.\n\t */\n\n\t/** @hidden */\n\tpublic addExtensionProperty(property: ExtensionProperty): this {\n\t\tthis.properties.add(property);\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic removeExtensionProperty(property: ExtensionProperty): this {\n\t\tthis.properties.delete(property);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * I/O implementation.\n\t */\n\n\t/** Installs dependencies required by the extension. */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic install(key: string, dependency: unknown): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method may\n\t * optionally be implemented by an extension, and should then support any property type\n\t * declared by the Extension's {@link Extension.provideTypes} list. The Extension will\n\t * be given a ReaderContext instance, and is expected to update either the context or its\n\t * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to\n\t * implement this.*\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic provide(readerContext: ReaderContext, propertyType: PropertyType): this {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method must be\n\t * implemented by each extension in order to support reading files. The extension will be\n\t * given a ReaderContext instance, and should update the current {@link Document} accordingly.\n\t */\n\tpublic abstract read(readerContext: ReaderContext): this;\n\n\t/**\n\t * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method must be\n\t * implemented by each extension in order to support writing files. The extension will be\n\t * given a WriterContext instance, and should modify the {@link JSONDocument} output\n\t * accordingly. Adding the extension name to the `extensionsUsed` and `extensionsRequired` list\n\t * is done automatically, and should not be included here.\n\t */\n\tpublic abstract write(writerContext: WriterContext): this;\n}\n","import { JSONDocument } from '../json-document';\nimport { Accessor, Animation, Buffer, Camera, Material, Mesh, Node, Scene, Skin, Texture, TextureInfo } from '../properties';\n\n/**\n * Model class providing glTF-Transform objects representing each definition in the glTF file, used\n * by a {@link Writer} and its {@link Extension} implementations. Indices of all properties will be\n * consistent with the glTF file.\n */\nexport class ReaderContext {\n\tpublic buffers: Buffer[] = [];\n\tpublic bufferViewBuffers: Buffer[] = [];\n\tpublic accessors: Accessor[] = [];\n\tpublic textures: Texture[] = [];\n\tpublic textureInfos: Map<TextureInfo, GLTF.ITextureInfo> = new Map();\n\tpublic materials: Material[] = [];\n\tpublic meshes: Mesh[] = [];\n\tpublic cameras: Camera[] = [];\n\tpublic nodes: Node[] = [];\n\tpublic skins: Skin[] = [];\n\tpublic animations: Animation[] = [];\n\tpublic scenes: Scene[] = [];\n\n\tconstructor (public readonly jsonDoc: JSONDocument) {}\n\n\tpublic setTextureInfo(textureInfo: TextureInfo, textureInfoDef: GLTF.ITextureInfo): void {\n\t\tthis.textureInfos.set(textureInfo, textureInfoDef);\n\n\t\tif (textureInfoDef.texCoord !== undefined) {\n\t\t\ttextureInfo.setTexCoord(textureInfoDef.texCoord);\n\t\t}\n\n\t\tconst textureDef = this.jsonDoc.json.textures[textureInfoDef.index];\n\n\t\tif (textureDef.sampler === undefined) return;\n\n\t\tconst samplerDef = this.jsonDoc.json.samplers[textureDef.sampler];\n\n\t\tif (samplerDef.magFilter !== undefined) {\n\t\t\ttextureInfo.setMagFilter(samplerDef.magFilter);\n\t\t}\n\t\tif (samplerDef.minFilter !== undefined) {\n\t\t\ttextureInfo.setMinFilter(samplerDef.minFilter);\n\t\t}\n\t\tif (samplerDef.wrapS !== undefined) {\n\t\t\ttextureInfo.setWrapS(samplerDef.wrapS);\n\t\t}\n\t\tif (samplerDef.wrapT !== undefined) {\n\t\t\ttextureInfo.setWrapT(samplerDef.wrapT);\n\t\t}\n\t}\n}\n","import { getRotation, getScaling, getTranslation } from 'gl-matrix/mat4'\nimport { GLB_BUFFER, PropertyType, TypedArray, vec3, vec4 } from '../constants';\nimport { Document } from '../document';\nimport { Extension } from '../extension';\nimport { JSONDocument } from '../json-document';\nimport { Accessor } from '../properties';\nimport { FileUtils, ImageUtils, Logger } from '../utils';\nimport { ReaderContext } from './reader-context';\n\nconst ComponentTypeToTypedArray = {\n\t'5120': Int8Array,\n\t'5121': Uint8Array,\n\t'5122': Int16Array,\n\t'5123': Uint16Array,\n\t'5125': Uint32Array,\n\t'5126': Float32Array,\n};\n\nexport interface ReaderOptions {\n\tlogger?: Logger;\n\textensions: (typeof Extension)[];\n\tdependencies: {[key: string]: unknown};\n}\n\nconst DEFAULT_OPTIONS: ReaderOptions = {\n\tlogger: Logger.DEFAULT_INSTANCE,\n\textensions: [],\n\tdependencies: {},\n};\n\n/** @hidden */\nexport class GLTFReader {\n\tpublic static read(jsonDoc: JSONDocument, options: ReaderOptions = DEFAULT_OPTIONS): Document {\n\t\tconst {json} = jsonDoc;\n\t\tconst doc = new Document();\n\n\t\tthis.validate(jsonDoc, options);\n\n\t\t/* Reader context. */\n\n\t\tconst context = new ReaderContext(jsonDoc);\n\n\t\t/** Asset. */\n\n\t\tconst assetDef = jsonDoc.json.asset;\n\t\tconst asset = doc.getRoot().getAsset();\n\n\t\tif (assetDef.copyright) asset.copyright = assetDef.copyright;\n\t\tif (assetDef.extras) asset.extras = assetDef.extras;\n\t\tif (assetDef.generator) asset.generator = assetDef.generator;\n\t\tif (assetDef.minVersion) asset.minVersion = assetDef.minVersion;\n\n\t\t/** Extensions (1/2). */\n\n\t\tconst extensionsUsed = json.extensionsUsed || [];\n\t\tconst extensionsRequired = json.extensionsRequired || [];\n\t\tfor (const Extension of options.extensions) {\n\t\t\tif (extensionsUsed.includes(Extension.EXTENSION_NAME)) {\n\t\t\t\tconst extension = doc.createExtension(Extension as unknown as new (doc: Document) => Extension)\n\t\t\t\t\t.setRequired(extensionsRequired.includes(Extension.EXTENSION_NAME));\n\n\t\t\t\tfor (const key of extension.dependencies) {\n\t\t\t\t\textension.install(key, options.dependencies[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** Buffers. */\n\n\t\tconst bufferDefs = json.buffers || [];\n\t\tcontext.buffers = bufferDefs.map((bufferDef) => {\n\t\t\tconst buffer = doc.createBuffer(bufferDef.name);\n\n\t\t\tif (bufferDef.extras) buffer.setExtras(bufferDef.extras);\n\n\t\t\tif (bufferDef.uri && bufferDef.uri.indexOf('__') !== 0) {\n\t\t\t\tbuffer.setURI(bufferDef.uri);\n\t\t\t}\n\n\t\t\treturn buffer;\n\t\t});\n\n\t\t/** Buffer views. */\n\n\t\tconst bufferViewDefs = json.bufferViews || [];\n\t\tcontext.bufferViewBuffers = bufferViewDefs.map((bufferViewDef) => {\n\t\t\treturn context.buffers[bufferViewDef.buffer];\n\t\t});\n\n\t\t/** Accessors. */\n\n\t\t// Accessor .count and .componentType properties are inferred dynamically.\n\t\tconst accessorDefs = json.accessors || [];\n\t\tcontext.accessors = accessorDefs.map((accessorDef) => {\n\t\t\tconst buffer = context.bufferViewBuffers[accessorDef.bufferView];\n\t\t\tconst accessor = doc.createAccessor(accessorDef.name, buffer).setType(accessorDef.type);\n\n\t\t\tif (accessorDef.extras) accessor.setExtras(accessorDef.extras);\n\n\t\t\tif (accessorDef.normalized !== undefined) {\n\t\t\t\taccessor.setNormalized(accessorDef.normalized);\n\t\t\t}\n\n\t\t\t// KHR_draco_mesh_compression.\n\t\t\tif (accessorDef.bufferView === undefined && !accessorDef.sparse) return accessor;\n\n\t\t\tlet array: TypedArray;\n\n\t\t\tif (accessorDef.sparse !== undefined) {\n\t\t\t\tarray = getSparseArray(accessorDef, jsonDoc);\n\t\t\t} else {\n\t\t\t\t// TODO(cleanup): Relying to much on ArrayBuffers: requires copying.\n\t\t\t\tarray = getAccessorArray(accessorDef, jsonDoc).slice();\n\t\t\t}\n\n\t\t\taccessor.setArray(array);\n\t\t\treturn accessor;\n\t\t});\n\n\t\t/** Textures. */\n\n\t\t// glTF-Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n\t\t// with image files. The glTF file may contain more one texture per image, where images\n\t\t// are reused with different sampler properties.\n\t\tconst imageDefs = json.images || [];\n\t\tconst textureDefs = json.textures || [];\n\t\tdoc.getRoot().listExtensionsUsed()\n\t\t\t.filter((extension) => extension.provideTypes.includes(PropertyType.TEXTURE))\n\t\t\t.forEach((extension) => extension.provide(context, PropertyType.TEXTURE));\n\t\tcontext.textures = imageDefs.map((imageDef) => {\n\t\t\tconst texture = doc.createTexture(imageDef.name);\n\n\t\t\t// glTF Image corresponds 1:1 with glTF-Transform Texture. See `writer.ts`.\n\t\t\tif (imageDef.extras) texture.setExtras(imageDef.extras);\n\n\t\t\tif (imageDef.bufferView !== undefined) {\n\t\t\t\tconst bufferViewDef = json.bufferViews[imageDef.bufferView];\n\t\t\t\tconst bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];\n\t\t\t\tconst bufferData = bufferDef.uri\n\t\t\t\t\t? jsonDoc.resources[bufferDef.uri]\n\t\t\t\t\t: jsonDoc.resources[GLB_BUFFER];\n\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\tconst byteLength = bufferViewDef.byteLength;\n\t\t\t\tconst imageData = bufferData.slice(byteOffset, byteOffset + byteLength);\n\t\t\t\ttexture.setImage(imageData);\n\t\t\t} else if (imageDef.uri !== undefined) {\n\t\t\t\ttexture.setImage(jsonDoc.resources[imageDef.uri]);\n\t\t\t\tif (imageDef.uri.indexOf('__') !== 0) {\n\t\t\t\t\ttexture.setURI(imageDef.uri);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (imageDef.mimeType !== undefined) {\n\t\t\t\ttexture.setMimeType(imageDef.mimeType);\n\t\t\t} else if (imageDef.uri) {\n\t\t\t\tconst extension = FileUtils.extension(imageDef.uri);\n\t\t\t\ttexture.setMimeType(ImageUtils.extensionToMimeType(extension));\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t});\n\n\t\t/** Materials. */\n\n\t\tconst materialDefs = json.materials || [];\n\t\tcontext.materials = materialDefs.map((materialDef) => {\n\t\t\tconst material = doc.createMaterial(materialDef.name);\n\n\t\t\tif (materialDef.extras) material.setExtras(materialDef.extras);\n\n\t\t\t// Program state & blending.\n\n\t\t\tif (materialDef.alphaMode !== undefined) {\n\t\t\t\tmaterial.setAlphaMode(materialDef.alphaMode);\n\t\t\t}\n\n\t\t\tif (materialDef.alphaCutoff !== undefined) {\n\t\t\t\tmaterial.setAlphaCutoff(materialDef.alphaCutoff);\n\t\t\t}\n\n\t\t\tif (materialDef.doubleSided !== undefined) {\n\t\t\t\tmaterial.setDoubleSided(materialDef.doubleSided);\n\t\t\t}\n\n\t\t\t// Factors.\n\n\t\t\tconst pbrDef = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tif (pbrDef.baseColorFactor !== undefined) {\n\t\t\t\tmaterial.setBaseColorFactor(pbrDef.baseColorFactor as vec4);\n\t\t\t}\n\n\t\t\tif (materialDef.emissiveFactor !== undefined) {\n\t\t\t\tmaterial.setEmissiveFactor(materialDef.emissiveFactor as vec3);\n\t\t\t}\n\n\t\t\tif (pbrDef.metallicFactor !== undefined) {\n\t\t\t\tmaterial.setMetallicFactor(pbrDef.metallicFactor);\n\t\t\t}\n\n\t\t\tif (pbrDef.roughnessFactor !== undefined) {\n\t\t\t\tmaterial.setRoughnessFactor(pbrDef.roughnessFactor);\n\t\t\t}\n\n\t\t\t// Textures.\n\n\t\t\tif (pbrDef.baseColorTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = pbrDef.baseColorTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source];\n\t\t\t\tmaterial.setBaseColorTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getBaseColorTextureInfo(), textureInfoDef);\n\t\t\t}\n\n\t\t\tif (materialDef.emissiveTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.emissiveTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source];\n\t\t\t\tmaterial.setEmissiveTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getEmissiveTextureInfo(), textureInfoDef);\n\t\t\t}\n\n\t\t\tif (materialDef.normalTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.normalTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source];\n\t\t\t\tmaterial.setNormalTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getNormalTextureInfo(), textureInfoDef);\n\t\t\t\tif (materialDef.normalTexture.scale !== undefined) {\n\t\t\t\t\tmaterial.setNormalScale(materialDef.normalTexture.scale);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (materialDef.occlusionTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = materialDef.occlusionTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source];\n\t\t\t\tmaterial.setOcclusionTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getOcclusionTextureInfo(), textureInfoDef);\n\t\t\t\tif (materialDef.occlusionTexture.strength !== undefined) {\n\t\t\t\t\tmaterial.setOcclusionStrength(materialDef.occlusionTexture.strength);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pbrDef.metallicRoughnessTexture !== undefined) {\n\t\t\t\tconst textureInfoDef = pbrDef.metallicRoughnessTexture;\n\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source];\n\t\t\t\tmaterial.setMetallicRoughnessTexture(texture);\n\t\t\t\tcontext.setTextureInfo(material.getMetallicRoughnessTextureInfo(), textureInfoDef);\n\t\t\t}\n\n\t\t\treturn material;\n\t\t});\n\n\t\t/** Meshes. */\n\n\t\tconst meshDefs = json.meshes || [];\n\t\tdoc.getRoot().listExtensionsUsed()\n\t\t\t.filter((extension) => extension.provideTypes.includes(PropertyType.PRIMITIVE))\n\t\t\t.forEach((extension) => extension.provide(context, PropertyType.PRIMITIVE));\n\t\tcontext.meshes = meshDefs.map((meshDef) => {\n\t\t\tconst mesh = doc.createMesh(meshDef.name);\n\n\t\t\tif (meshDef.extras) mesh.setExtras(meshDef.extras);\n\n\t\t\tif (meshDef.weights !== undefined) {\n\t\t\t\tmesh.setWeights(meshDef.weights);\n\t\t\t}\n\n\t\t\tmeshDef.primitives.forEach((primitiveDef) => {\n\t\t\t\tconst primitive = doc.createPrimitive();\n\n\t\t\t\tif (primitiveDef.extras) primitive.setExtras(primitiveDef.extras);\n\n\t\t\t\tif (primitiveDef.material !== undefined) {\n\t\t\t\t\tprimitive.setMaterial(context.materials[primitiveDef.material]);\n\t\t\t\t}\n\n\t\t\t\tif (primitiveDef.mode !== undefined) {\n\t\t\t\t\tprimitive.setMode(primitiveDef.mode);\n\t\t\t\t}\n\n\t\t\t\tfor (const [semantic, index] of Object.entries(primitiveDef.attributes || {})) {\n\t\t\t\t\tprimitive.setAttribute(semantic, context.accessors[index]);\n\t\t\t\t}\n\n\t\t\t\tif (primitiveDef.indices !== undefined) {\n\t\t\t\t\tprimitive.setIndices(context.accessors[primitiveDef.indices]);\n\t\t\t\t}\n\n\t\t\t\tconst targetNames = meshDef.extras && meshDef.extras.targetNames || [];\n\t\t\t\tconst targetDefs = primitiveDef.targets || [];\n\t\t\t\ttargetDefs.forEach((targetDef, targetIndex) => {\n\t\t\t\t\tconst targetName = targetNames[targetIndex] || targetIndex.toString();\n\t\t\t\t\tconst target = doc.createPrimitiveTarget(targetName);\n\n\t\t\t\t\tfor (const [semantic, accessorIndex] of Object.entries(targetDef)) {\n\t\t\t\t\t\ttarget.setAttribute(semantic, context.accessors[accessorIndex]);\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitive.addTarget(target);\n\t\t\t\t});\n\n\t\t\t\tmesh.addPrimitive(primitive);\n\t\t\t})\n\n\t\t\treturn mesh;\n\t\t});\n\n\t\t/** Cameras. */\n\n\t\tconst cameraDefs = json.cameras || [];\n\t\tcontext.cameras = cameraDefs.map((cameraDef) => {\n\t\t\tconst camera = doc.createCamera(cameraDef.name).setType(cameraDef.type);\n\n\t\t\tif (cameraDef.extras) camera.setExtras(cameraDef.extras);\n\n\t\t\tif (cameraDef.type === GLTF.CameraType.PERSPECTIVE) {\n\t\t\t\tcamera\n\t\t\t\t\t.setZNear(cameraDef.perspective.znear)\n\t\t\t\t\t.setZFar(cameraDef.perspective.zfar)\n\t\t\t\t\t.setYFov(cameraDef.perspective.yfov)\n\t\t\t\t\t.setAspectRatio(cameraDef.perspective.aspectRatio);\n\t\t\t} else {\n\t\t\t\tcamera\n\t\t\t\t\t.setZNear(cameraDef.orthographic.znear)\n\t\t\t\t\t.setZFar(cameraDef.orthographic.zfar)\n\t\t\t\t\t.setXMag(cameraDef.orthographic.xmag)\n\t\t\t\t\t.setYMag(cameraDef.orthographic.ymag);\n\t\t\t}\n\t\t\treturn camera;\n\t\t});\n\n\t\t/** Nodes. */\n\n\t\tconst nodeDefs = json.nodes || [];\n\t\tcontext.nodes = nodeDefs.map((nodeDef) => {\n\t\t\tconst node = doc.createNode(nodeDef.name);\n\n\t\t\tif (nodeDef.extras) node.setExtras(nodeDef.extras);\n\n\t\t\tif (nodeDef.translation !== undefined) {\n\t\t\t\tnode.setTranslation(nodeDef.translation as vec3);\n\t\t\t}\n\n\t\t\tif (nodeDef.rotation !== undefined) {\n\t\t\t\tnode.setRotation(nodeDef.rotation as vec4);\n\t\t\t}\n\n\t\t\tif (nodeDef.scale !== undefined) {\n\t\t\t\tnode.setScale(nodeDef.scale as vec3);\n\t\t\t}\n\n\t\t\tif (nodeDef.matrix !== undefined) {\n\t\t\t\tnode.setTranslation(getTranslation([], nodeDef.matrix) as vec3);\n\t\t\t\tnode.setRotation(getRotation([], nodeDef.matrix) as vec4);\n\t\t\t\tnode.setScale(getScaling([], nodeDef.matrix) as vec3);\n\t\t\t}\n\n\t\t\tif (nodeDef.weights !== undefined) {\n\t\t\t\tnode.setWeights(nodeDef.weights);\n\t\t\t}\n\n\t\t\t// Attachments (mesh, camera, skin) defined later in reading process.\n\n\t\t\treturn node;\n\t\t});\n\n\t\t/** Skins. */\n\n\t\tconst skinDefs = json.skins || [];\n\t\tcontext.skins = skinDefs.map((skinDef) => {\n\t\t\tconst skin = doc.createSkin(skinDef.name);\n\n\t\t\tif (skinDef.extras) skin.setExtras(skinDef.extras);\n\n\t\t\tif (skinDef.inverseBindMatrices !== undefined) {\n\t\t\t\tskin.setInverseBindMatrices(context.accessors[skinDef.inverseBindMatrices]);\n\t\t\t}\n\n\t\t\tif (skinDef.skeleton !== undefined) {\n\t\t\t\tskin.setSkeleton(context.nodes[skinDef.skeleton]);\n\t\t\t}\n\n\t\t\tfor (const nodeIndex of skinDef.joints) {\n\t\t\t\tskin.addJoint(context.nodes[nodeIndex]);\n\t\t\t}\n\n\t\t\treturn skin;\n\t\t});\n\n\t\t/** Node attachments. */\n\n\t\tnodeDefs.map((nodeDef, nodeIndex) => {\n\t\t\tconst node = context.nodes[nodeIndex];\n\n\t\t\tconst children = nodeDef.children || [];\n\t\t\tchildren.forEach((childIndex) => node.addChild(context.nodes[childIndex]));\n\n\t\t\tif (nodeDef.mesh !== undefined) node.setMesh(context.meshes[nodeDef.mesh]);\n\n\t\t\tif (nodeDef.camera !== undefined) node.setCamera(context.cameras[nodeDef.camera]);\n\n\t\t\tif (nodeDef.skin !== undefined) node.setSkin(context.skins[nodeDef.skin]);\n\t\t})\n\n\t\t/** Animations. */\n\n\t\tconst animationDefs = json.animations || [];\n\t\tcontext.animations = animationDefs.map((animationDef) => {\n\t\t\tconst animation = doc.createAnimation(animationDef.name);\n\n\t\t\tif (animationDef.extras) animation.setExtras(animationDef.extras);\n\n\t\t\tconst samplerDefs = animationDef.samplers || [];\n\t\t\tconst samplers = samplerDefs.map((samplerDef) => {\n\t\t\t\tconst sampler = doc.createAnimationSampler()\n\t\t\t\t\t.setInput(context.accessors[samplerDef.input])\n\t\t\t\t\t.setOutput(context.accessors[samplerDef.output])\n\t\t\t\t\t.setInterpolation(samplerDef.interpolation || GLTF.AnimationSamplerInterpolation.LINEAR);\n\n\t\t\t\tif (samplerDef.extras) sampler.setExtras(samplerDef.extras);\n\n\t\t\t\tanimation.addSampler(sampler);\n\t\t\t\treturn sampler;\n\t\t\t})\n\n\t\t\tconst channels = animationDef.channels || [];\n\t\t\tchannels.forEach((channelDef) => {\n\t\t\t\tconst channel = doc.createAnimationChannel()\n\t\t\t\t\t.setSampler(samplers[channelDef.sampler])\n\t\t\t\t\t.setTargetNode(context.nodes[channelDef.target.node])\n\t\t\t\t\t.setTargetPath(channelDef.target.path);\n\n\t\t\t\tif (channelDef.extras) channel.setExtras(channelDef.extras);\n\n\t\t\t\tanimation.addChannel(channel);\n\t\t\t});\n\n\t\t\treturn animation;\n\t\t});\n\n\t\t/** Scenes. */\n\n\t\tconst sceneDefs = json.scenes || [];\n\t\tcontext.scenes = sceneDefs.map((sceneDef) => {\n\t\t\tconst scene = doc.createScene(sceneDef.name);\n\n\t\t\tif (sceneDef.extras) scene.setExtras(sceneDef.extras);\n\n\t\t\tconst children = sceneDef.nodes || [];\n\n\t\t\tchildren\n\t\t\t.map((nodeIndex) => context.nodes[nodeIndex])\n\t\t\t.forEach((node) => (scene.addChild(node)));\n\n\t\t\treturn scene;\n\t\t});\n\n\t\t/** Extensions (2/2). */\n\n\t\tdoc.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.forEach((extension) => extension.read(context));\n\n\t\treturn doc;\n\t}\n\n\tprivate static validate(jsonDoc: JSONDocument, options: ReaderOptions): void {\n\n\t\tconst json = jsonDoc.json;\n\n\t\tif (json.asset.version !== '2.0') {\n\t\t\tthrow new Error(`Unsupported glTF version, \"${json.asset.version}\".`);\n\t\t}\n\n\t\tif (json.extensionsRequired) {\n\t\t\tfor (const extensionName of json.extensionsRequired) {\n\t\t\t\tif (!options.extensions.find(\n\t\t\t\t\t\t(extension) => extension.EXTENSION_NAME === extensionName)) {\n\t\t\t\t\tthrow new Error(`Missing required extension, \"${extensionName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (json.extensionsUsed) {\n\t\t\tfor (const extensionName of json.extensionsUsed) {\n\t\t\t\tif (!options.extensions.find(\n\t\t\t\t\t\t(extension) => extension.EXTENSION_NAME === extensionName)) {\n\t\t\t\t\toptions.logger.warn(`Missing optional extension, \"${extensionName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n/**\n * Returns the contents of an interleaved accessor, as a typed array.\n * @hidden\n */\nfunction getInterleavedArray(accessorDef: GLTF.IAccessor, jsonDoc: JSONDocument): TypedArray {\n\tconst bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];\n\tconst bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];\n\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\tconst componentSize = TypedArray.BYTES_PER_ELEMENT;\n\tconst accessorByteOffset = accessorDef.byteOffset || 0;\n\n\tconst array = new TypedArray(accessorDef.count * elementSize);\n\tconst view = new DataView(resource, bufferViewDef.byteOffset, bufferViewDef.byteLength);\n\tconst byteStride = bufferViewDef.byteStride;\n\n\tfor (let i = 0; i < accessorDef.count; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tconst byteOffset = accessorByteOffset + i * byteStride + j * componentSize;\n\t\t\tlet value: number;\n\t\t\tswitch (accessorDef.componentType) {\n\t\t\t\tcase GLTF.AccessorComponentType.FLOAT:\n\t\t\t\t\tvalue = view.getFloat32(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_INT:\n\t\t\t\t\tvalue = view.getUint32(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_SHORT:\n\t\t\t\t\tvalue = view.getUint16(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_BYTE:\n\t\t\t\t\tvalue = view.getUint8(byteOffset);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GLTF.AccessorComponentType.SHORT:\n\t\t\t\t\tvalue = view.getInt16(byteOffset, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GLTF.AccessorComponentType.BYTE:\n\t\t\t\t\tvalue = view.getInt8(byteOffset);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected componentType \"${accessorDef.componentType}\".`);\n\t\t\t}\n\t\t\tarray[i * elementSize + j] = value;\n\t\t}\n\t}\n\n\treturn array;\n}\n\n/**\n * Returns the contents of an accessor, as a typed array.\n * @hidden\n */\nfunction getAccessorArray(accessorDef: GLTF.IAccessor, jsonDoc: JSONDocument): TypedArray {\n\tconst bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];\n\tconst bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];\n\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\tconst componentSize = TypedArray.BYTES_PER_ELEMENT;\n\tconst elementStride = elementSize * componentSize;\n\n\t// Interleaved buffer view.\n\tif (bufferViewDef.byteStride !== undefined && bufferViewDef.byteStride !==  elementStride) {\n\t\treturn getInterleavedArray(accessorDef, jsonDoc);\n\t}\n\n\tconst start = (bufferViewDef.byteOffset || 0) + (accessorDef.byteOffset || 0);\n\n\tswitch (accessorDef.componentType) {\n\t\tcase GLTF.AccessorComponentType.FLOAT:\n\t\t\treturn new Float32Array(resource, start, accessorDef.count * elementSize);\n\t\tcase GLTF.AccessorComponentType.UNSIGNED_INT:\n\t\t\treturn new Uint32Array(resource, start, accessorDef.count * elementSize);\n\t\tcase GLTF.AccessorComponentType.UNSIGNED_SHORT:\n\t\t\treturn new Uint16Array(resource, start, accessorDef.count * elementSize);\n\t\tcase GLTF.AccessorComponentType.UNSIGNED_BYTE:\n\t\t\treturn new Uint8Array(resource, start, accessorDef.count * elementSize);\n\t\tcase GLTF.AccessorComponentType.SHORT:\n\t\t\treturn new Int16Array(resource, start, accessorDef.count * elementSize);\n\t\tcase GLTF.AccessorComponentType.BYTE:\n\t\t\treturn new Int8Array(resource, start, accessorDef.count * elementSize);\n\t\tdefault:\n\t\t\tthrow new Error(`Unexpected componentType \"${accessorDef.componentType}\".`);\n\t}\n}\n\n/**\n * Returns the contents of a sparse accessor, as a typed array.\n * @hidden\n */\nfunction getSparseArray(accessorDef: GLTF.IAccessor, jsonDoc: JSONDocument): TypedArray {\n\tconst TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];\n\tconst elementSize = Accessor.getElementSize(accessorDef.type);\n\n\tlet array: TypedArray;\n\tif (accessorDef.bufferView !== undefined) {\n\t\t// TODO(cleanup): Relying to much on ArrayBuffers: requires copying.\n\t\tarray = getAccessorArray(accessorDef, jsonDoc).slice();\n\t} else {\n\t\tarray = new TypedArray(accessorDef.count * elementSize);\n\t}\n\n\tconst count = accessorDef.sparse.count;\n\tconst indicesDef = {...accessorDef, ...accessorDef.sparse.indices, count, type: 'SCALAR'};\n\tconst valuesDef = {...accessorDef, ...accessorDef.sparse.values, count};\n\tconst indices = getAccessorArray(indicesDef as GLTF.IAccessor, jsonDoc);\n\tconst values = getAccessorArray(valuesDef, jsonDoc);\n\n\t// Override indices given in the sparse data.\n\tfor (let i = 0; i < indicesDef.count; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tarray[indices[i] * elementSize + j] = values[i * elementSize + j];\n\t\t}\n\t}\n\n\treturn array;\n}\n","import { JSONDocument } from '../json-document';\nimport { Accessor, Buffer, Camera, Material, Mesh, Node, Property, Skin, Texture, TextureInfo } from '../properties';\nimport { ImageUtils, Logger } from '../utils';\nimport { WriterOptions } from './writer';\n\ntype PropertyDef = GLTF.IScene | GLTF.INode | GLTF.IMaterial | GLTF.ISkin | GLTF.ITexture;\n\n/**\n * Model class providing writing state to a {@link Writer} and its {@link Extension}\n * implementations.\n *\n * @hidden\n */\nexport class WriterContext {\n\tpublic readonly accessorIndexMap = new Map<Accessor, number>();\n\tpublic readonly cameraIndexMap = new Map<Camera, number>();\n\tpublic readonly skinIndexMap = new Map<Skin, number>();\n\tpublic readonly materialIndexMap = new Map<Material, number>();\n\tpublic readonly meshIndexMap = new Map<Mesh, number>();\n\tpublic readonly nodeIndexMap = new Map<Node, number>();\n\tpublic readonly imageIndexMap = new Map<Texture, number>();\n\tpublic readonly textureDefIndexMap = new Map<string, number>(); // textureDef JSON -> index\n\tpublic readonly textureInfoDefMap = new Map<TextureInfo, GLTF.ITextureInfo>();\n\tpublic readonly samplerDefIndexMap = new Map<string, number>(); // samplerDef JSON -> index\n\n\tpublic readonly imageData: ArrayBuffer[] = [];\n\n\tpublic bufferURIGenerator: UniqueURIGenerator;\n\tpublic imageURIGenerator: UniqueURIGenerator;\n\tpublic logger: Logger;\n\n\tconstructor (public readonly jsonDoc: JSONDocument, public readonly options: WriterOptions) {}\n\n\t/**\n\t * Creates a TextureInfo definition, and any Texture or Sampler definitions it requires. If\n\t * possible, Texture and Sampler definitions are shared.\n\t */\n\tpublic createTextureInfoDef(texture: Texture, textureInfo: TextureInfo): GLTF.ITextureInfo {\n\t\tconst samplerDef = {\n\t\t\tmagFilter: textureInfo.getMagFilter() || undefined,\n\t\t\tminFilter: textureInfo.getMinFilter() || undefined,\n\t\t\twrapS: textureInfo.getWrapS(),\n\t\t\twrapT: textureInfo.getWrapT(),\n\t\t} as GLTF.ISampler;\n\n\t\tconst samplerKey = JSON.stringify(samplerDef);\n\t\tif (!this.samplerDefIndexMap.has(samplerKey)) {\n\t\t\tthis.samplerDefIndexMap.set(samplerKey, this.jsonDoc.json.samplers.length);\n\t\t\tthis.jsonDoc.json.samplers.push(samplerDef);\n\t\t}\n\n\t\tconst textureDef = {\n\t\t\tsource: this.imageIndexMap.get(texture),\n\t\t\tsampler: this.samplerDefIndexMap.get(samplerKey)\n\t\t} as GLTF.ITexture;\n\n\t\tconst textureKey = JSON.stringify(textureDef);\n\t\tif (!this.textureDefIndexMap.has(textureKey)) {\n\t\t\tthis.textureDefIndexMap.set(textureKey, this.jsonDoc.json.textures.length);\n\t\t\tthis.jsonDoc.json.textures.push(textureDef);\n\t\t}\n\n\t\tconst textureInfoDef = {\n\t\t\tindex: this.textureDefIndexMap.get(textureKey),\n\t\t\ttexCoord: textureInfo.getTexCoord(),\n\t\t} as GLTF.ITextureInfo;\n\n\t\tthis.textureInfoDefMap.set(textureInfo, textureInfoDef);\n\n\t\treturn textureInfoDef;\n\t}\n\n\tpublic createPropertyDef(property: Property): PropertyDef {\n\t\tconst def = {} as PropertyDef;\n\t\tif (property.getName()) {\n\t\t\tdef.name = property.getName();\n\t\t}\n\t\tif (Object.keys(property.getExtras()).length > 0) {\n\t\t\tdef.extras = property.getExtras();\n\t\t}\n\t\treturn def;\n\t}\n\n\tpublic createAccessorDef(accessor: Accessor): GLTF.IAccessor {\n\t\tconst accessorDef = this.createPropertyDef(accessor) as GLTF.IAccessor;\n\t\taccessorDef.type = accessor.getType();\n\t\taccessorDef.componentType = accessor.getComponentType();\n\t\taccessorDef.count = accessor.getCount();\n\t\taccessor.getMax((accessorDef.max = []));\n\t\taccessor.getMin((accessorDef.min = []));\n\t\taccessorDef.normalized = accessor.getNormalized();\n\t\treturn accessorDef;\n\t}\n\n\tpublic createImageData(imageDef: GLTF.IImage, data: ArrayBuffer, texture: Texture): void {\n\t\tif (this.options.isGLB) {\n\t\t\tthis.imageData.push(data);\n\t\t\timageDef.bufferView = this.jsonDoc.json.bufferViews.length;\n\t\t\tthis.jsonDoc.json.bufferViews.push({\n\t\t\t\tbuffer: 0,\n\t\t\t\tbyteOffset: -1, // determined while iterating buffers, in Writer.ts.\n\t\t\t\tbyteLength: data.byteLength\n\t\t\t});\n\t\t} else {\n\t\t\tconst extension = ImageUtils.mimeTypeToExtension(texture.getMimeType());\n\t\t\timageDef.uri = this.imageURIGenerator.createURI(texture, extension);\n\t\t\tthis.jsonDoc.resources[imageDef.uri] = data;\n\t\t}\n\t}\n}\n\nexport class UniqueURIGenerator {\n\tprivate counter = 1;\n\n\tconstructor (\n\t\tprivate readonly multiple: boolean,\n\t\tprivate readonly basename: string) {}\n\n\tpublic createURI(object: Texture | Buffer, extension: string): string {\n\t\tif (object.getURI()) {\n\t\t\treturn object.getURI();\n\t\t} else if (!this.multiple) {\n\t\t\treturn `${this.basename}.${extension}`;\n\t\t} else {\n\t\t\treturn `${this.basename}_${this.counter++}.${extension}`;\n\t\t}\n\t}\n}\n","import { GLB_BUFFER, NAME, VERSION } from '../constants';\nimport { Document } from '../document';\nimport { Link } from '../graph';\nimport { JSONDocument } from '../json-document';\nimport { Accessor, AnimationSampler, AttributeLink, IndexLink, Primitive, Property, Root } from '../properties';\nimport { BufferUtils, Logger } from '../utils';\nimport { UniqueURIGenerator, WriterContext } from './writer-context';\n\nconst BufferViewTarget = {\n\tARRAY_BUFFER: 34962,\n\tELEMENT_ARRAY_BUFFER: 34963\n};\n\nexport interface WriterOptions {\n\tlogger?: Logger;\n\tbasename?: string;\n\tisGLB?: boolean;\n}\n\nconst DEFAULT_OPTIONS: WriterOptions = {\n\tlogger: Logger.DEFAULT_INSTANCE,\n\tbasename: '',\n\tisGLB: true,\n};\n\n/** @hidden */\nexport class GLTFWriter {\n\tpublic static write(doc: Document, options: WriterOptions = DEFAULT_OPTIONS): JSONDocument {\n\t\tconst root = doc.getRoot();\n\t\tconst jsonDoc = {json: {asset: root.getAsset()}, resources: {}} as JSONDocument;\n\t\tconst logger = options.logger || Logger.DEFAULT_INSTANCE;\n\t\tconst json = jsonDoc.json;\n\t\tjson.asset.generator = `glTF-Transform ${VERSION}`;\n\n\t\t/* Writer context. */\n\n\t\tconst context = new WriterContext(jsonDoc, options);\n\t\tconst numBuffers = root.listBuffers().length;\n\t\tconst numImages = root.listTextures().length;\n\t\tcontext.bufferURIGenerator = new UniqueURIGenerator(numBuffers > 1, options.basename);\n\t\tcontext.imageURIGenerator = new UniqueURIGenerator(numImages > 1, options.basename);\n\t\tcontext.logger = doc.getLogger();\n\n\t\t/* Utilities. */\n\n\t\tinterface BufferViewResult {\n\t\t\tbyteLength: number;\n\t\t\tbuffers: ArrayBuffer[];\n\t\t}\n\n\t\t/**\n\t\t* Pack a group of accessors into a sequential buffer view. Appends accessor and buffer view\n\t\t* definitions to the root JSON lists.\n\t\t*\n\t\t* @param accessors Accessors to be included.\n\t\t* @param bufferIndex Buffer to write to.\n\t\t* @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n\t\t* @param bufferViewTarget (Optional) target use of the buffer view.\n\t\t*/\n\t\tfunction concatAccessors(accessors: Accessor[], bufferIndex: number, bufferByteOffset: number, bufferViewTarget?: number): BufferViewResult {\n\t\t\tconst buffers: ArrayBuffer[] = [];\n\t\t\tlet byteLength = 0;\n\n\t\t\t// Create accessor definitions, determining size of final buffer view.\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\taccessorDef.bufferView = json.bufferViews.length;\n\t\t\t\t// TODO(feat): accessorDef.sparse\n\n\t\t\t\tconst data = BufferUtils.pad(accessor.getArray().buffer);\n\t\t\t\taccessorDef.byteOffset = byteLength;\n\t\t\t\tbyteLength += data.byteLength;\n\t\t\t\tbuffers.push(data);\n\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors.length);\n\t\t\t\tjson.accessors.push(accessorDef);\n\t\t\t}\n\n\t\t\t// Create buffer view definition.\n\t\t\tconst bufferViewData = BufferUtils.concat(buffers);\n\t\t\tconst bufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset,\n\t\t\t\tbyteLength: bufferViewData.byteLength,\n\t\t\t};\n\t\t\tif (bufferViewTarget) bufferViewDef.target = bufferViewTarget;\n\t\t\tjson.bufferViews.push(bufferViewDef);\n\n\t\t\treturn {buffers, byteLength}\n\t\t}\n\n\t\t/**\n\t\t* Pack a group of accessors into an interleaved buffer view. Appends accessor and buffer view\n\t\t* definitions to the root JSON lists. Buffer view target is implicitly attribute data.\n\t\t*\n\t\t* References:\n\t\t* - [Apple • Best Practices for Working with Vertex Data](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html)\n\t\t* - [Khronos • Vertex Specification Best Practices](https://www.khronos.org/opengl/wiki/Vertex_Specification_Best_Practices)\n\t\t*\n\t\t* @param accessors Accessors to be included.\n\t\t* @param bufferIndex Buffer to write to.\n\t\t* @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.\n\t\t*/\n\t\tfunction interleaveAccessors(accessors: Accessor[], bufferIndex: number, bufferByteOffset: number): BufferViewResult {\n\t\t\tconst vertexCount = accessors[0].getCount();\n\t\t\tlet byteStride = 0;\n\n\t\t\t// Create accessor definitions, determining size and stride of final buffer view.\n\t\t\tfor (const accessor of accessors) {\n\t\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\t\taccessorDef.bufferView = json.bufferViews.length;\n\t\t\t\taccessorDef.byteOffset = byteStride;\n\n\t\t\t\tconst elementSize = accessor.getElementSize();\n\t\t\t\tconst componentSize = accessor.getComponentSize();\n\t\t\t\tbyteStride += BufferUtils.padNumber(elementSize * componentSize);\n\n\t\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors.length);\n\t\t\t\tjson.accessors.push(accessorDef);\n\t\t\t}\n\n\t\t\t// Allocate interleaved buffer view.\n\t\t\tconst byteLength = vertexCount * byteStride;\n\t\t\tconst buffer = new ArrayBuffer(byteLength);\n\t\t\tconst view = new DataView(buffer);\n\n\t\t\t// Write interleaved accessor data to the buffer view.\n\t\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\t\tlet vertexByteOffset = 0;\n\t\t\t\tfor (const accessor of accessors) {\n\t\t\t\t\tconst elementSize = accessor.getElementSize();\n\t\t\t\t\tconst componentSize = accessor.getComponentSize();\n\t\t\t\t\tconst componentType = accessor.getComponentType();\n\t\t\t\t\tconst array = accessor.getArray();\n\t\t\t\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\t\t\t\tconst viewByteOffset = i * byteStride + vertexByteOffset + j * componentSize;\n\t\t\t\t\t\tconst value = array[i * elementSize + j];\n\t\t\t\t\t\tswitch (componentType) {\n\t\t\t\t\t\t\tcase GLTF.AccessorComponentType.FLOAT:\n\t\t\t\t\t\t\t\tview.setFloat32(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase GLTF.AccessorComponentType.BYTE:\n\t\t\t\t\t\t\t\tview.setInt8(viewByteOffset, value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase GLTF.AccessorComponentType.SHORT:\n\t\t\t\t\t\t\t\tview.setInt16(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_BYTE:\n\t\t\t\t\t\t\t\tview.setUint8(viewByteOffset, value);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_SHORT:\n\t\t\t\t\t\t\t\tview.setUint16(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase GLTF.AccessorComponentType.UNSIGNED_INT:\n\t\t\t\t\t\t\t\tview.setUint32(viewByteOffset, value, true);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow new Error('Unexpected component type: ' + componentType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvertexByteOffset += BufferUtils.padNumber(elementSize * componentSize);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create buffer view definition.\n\t\t\tconst bufferViewDef: GLTF.IBufferView = {\n\t\t\t\tbuffer: bufferIndex,\n\t\t\t\tbyteOffset: bufferByteOffset,\n\t\t\t\tbyteLength: byteLength,\n\t\t\t\tbyteStride: byteStride,\n\t\t\t\ttarget: BufferViewTarget.ARRAY_BUFFER,\n\t\t\t};\n\t\t\tjson.bufferViews.push(bufferViewDef);\n\n\t\t\treturn {byteLength, buffers: [buffer]};\n\t\t}\n\n\t\t/* Data use pre-processing. */\n\n\t\tconst accessorLinks = new Map<Accessor, Link<Property, Accessor>[]>();\n\n\t\t// Gather all accessors, creating a map to look up their uses.\n\t\tfor (const link of doc.getGraph().getLinks()) {\n\t\t\tif (link.getParent() === root) continue;\n\n\t\t\tconst child = link.getChild();\n\n\t\t\tif (child instanceof Accessor) {\n\t\t\t\tconst uses = accessorLinks.get(child) || [];\n\t\t\t\tuses.push(link as Link<Property, Accessor>);\n\t\t\t\taccessorLinks.set(child, uses);\n\t\t\t}\n\t\t}\n\n\t\tjson.accessors = [];\n\t\tjson.bufferViews = [];\n\n\t\t/* Textures. */\n\n\t\t// glTF-Transform's \"Texture\" properties correspond 1:1 with glTF \"Image\" properties, and\n\t\t// with image files. The glTF file may contain more one texture per image, where images\n\t\t// are reused with different sampler properties.\n\t\tjson.samplers = [];\n\t\tjson.textures = [];\n\t\tjson.images = root.listTextures().map((texture, textureIndex) => {\n\t\t\tconst imageDef = context.createPropertyDef(texture) as GLTF.IImage;\n\n\t\t\tif (texture.getMimeType()) {\n\t\t\t\timageDef.mimeType = texture.getMimeType();\n\t\t\t}\n\n\t\t\tif (texture.getImage()) {\n\t\t\t\tcontext.createImageData(imageDef, texture.getImage(), texture);\n\t\t\t}\n\n\t\t\tcontext.imageIndexMap.set(texture, textureIndex);\n\t\t\treturn imageDef;\n\t\t});\n\n\t\t/* Buffers, buffer views, and accessors. */\n\n\t\tjson.buffers = [];\n\t\troot.listBuffers().forEach((buffer) => {\n\t\t\tconst bufferDef = context.createPropertyDef(buffer) as GLTF.IBuffer;\n\n\t\t\t// Attributes are grouped and interleaved in one buffer view per mesh primitive. Indices for\n\t\t\t// all primitives are grouped into a single buffer view. Everything else goes into a\n\t\t\t// miscellaneous buffer view.\n\t\t\tconst attributeAccessors = new Map<Primitive, Set<Accessor>>();\n\t\t\tconst indexAccessors = new Set<Accessor>();\n\t\t\tconst ibmAccessors = new Set<Accessor>();\n\t\t\tconst otherAccessors = new Set<Accessor>();\n\n\t\t\tconst bufferParents = buffer.listParents()\n\t\t\t\t.filter((property) => !(property instanceof Root)) as Property[];\n\n\t\t\t// Categorize accessors by use.\n\t\t\tfor (const parent of bufferParents) {\n\t\t\t\tif ((!(parent instanceof Accessor))) { // Not expected.\n\t\t\t\t\tthrow new Error('Unimplemented buffer reference: ' + parent);\n\t\t\t\t}\n\n\t\t\t\tlet isAttribute = false;\n\t\t\t\tlet isIndex = false;\n\t\t\t\tlet isIBM = false;\n\t\t\t\tlet isOther = false;\n\n\t\t\t\tconst accessorRefs = accessorLinks.get(parent) || [];\n\n\t\t\t\tfor (const link of accessorRefs) {\n\t\t\t\t\tif (link instanceof AttributeLink) {\n\t\t\t\t\t\tisAttribute = true;\n\t\t\t\t\t} else if (link instanceof IndexLink) {\n\t\t\t\t\t\tisIndex = true;\n\t\t\t\t\t} else if (link.getName() === 'inverseBindMatrices') {\n\t\t\t\t\t\tisIBM = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisOther = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the Accessor isn't used at all, treat it as \"other\".\n\t\t\t\tif (!isAttribute && !isIndex && !isIBM && !isOther) isOther = true;\n\n\t\t\t\tif (isAttribute && !isIndex && !isIBM && !isOther) {\n\t\t\t\t\tconst primitive = accessorRefs[0].getParent() as Primitive;\n\t\t\t\t\tconst primitiveAccessors = attributeAccessors.get(primitive) || new Set<Accessor>();\n\t\t\t\t\tprimitiveAccessors.add(parent);\n\t\t\t\t\tattributeAccessors.set(primitive, primitiveAccessors);\n\t\t\t\t} else if (isIndex && !isAttribute && !isIBM && !isOther) {\n\t\t\t\t\tindexAccessors.add(parent);\n\t\t\t\t} else if (isIBM && !isAttribute && !isIndex && !isOther) {\n\t\t\t\t\tibmAccessors.add(parent);\n\t\t\t\t} else if (isOther && !isAttribute && !isIndex && !isIBM) {\n\t\t\t\t\totherAccessors.add(parent);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Attribute, index, or IBM accessors must be used only for that purpose.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Write accessor groups to buffer views.\n\n\t\t\tconst buffers: ArrayBuffer[] = [];\n\t\t\tconst bufferIndex = json.buffers.length;\n\t\t\tlet bufferByteLength = 0;\n\n\t\t\tif (indexAccessors.size) {\n\t\t\t\tconst indexResult = concatAccessors(Array.from(indexAccessors), bufferIndex, bufferByteLength, BufferViewTarget.ELEMENT_ARRAY_BUFFER);\n\t\t\t\tbufferByteLength += indexResult.byteLength;\n\t\t\t\tbuffers.push(...indexResult.buffers);\n\t\t\t}\n\n\t\t\tfor (const primitiveAccessors of Array.from(attributeAccessors.values())) {\n\t\t\t\tif (primitiveAccessors.size) {\n\t\t\t\t\tconst primitiveResult = interleaveAccessors(Array.from(primitiveAccessors), bufferIndex, bufferByteLength);\n\t\t\t\t\tbufferByteLength += primitiveResult.byteLength;\n\t\t\t\t\tbuffers.push(...primitiveResult.buffers);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ibmAccessors.size) {\n\t\t\t\tconst ibmResult = concatAccessors(Array.from(ibmAccessors), bufferIndex, bufferByteLength);\n\t\t\t\tbufferByteLength += ibmResult.byteLength;\n\t\t\t\tbuffers.push(...ibmResult.buffers);\n\t\t\t}\n\n\t\t\tif (otherAccessors.size) {\n\t\t\t\tconst otherResult = concatAccessors(Array.from(otherAccessors), bufferIndex, bufferByteLength);\n\t\t\t\tbufferByteLength += otherResult.byteLength;\n\t\t\t\tbuffers.push(...otherResult.buffers);\n\t\t\t}\n\n\t\t\t// We only support embedded images in GLB, so we know there is only one buffer.\n\t\t\tif (context.imageData.length) {\n\t\t\t\tfor (let i = 0; i < context.imageData.length; i++) {\n\t\t\t\t\tjson.bufferViews[json.images[i].bufferView].byteOffset = bufferByteLength;\n\t\t\t\t\tbufferByteLength += context.imageData[i].byteLength;\n\t\t\t\t\tbuffers.push(context.imageData[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bufferByteLength) {\n\t\t\t\tcontext.logger.warn(`${NAME}: Skipping empty buffer, \"${buffer.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Assign buffer URI.\n\n\t\t\tlet uri: string;\n\t\t\tif (options.isGLB) {\n\t\t\t\turi = GLB_BUFFER;\n\t\t\t} else {\n\t\t\t\turi = context.bufferURIGenerator.createURI(buffer, 'bin');\n\t\t\t\tbufferDef.uri = uri;\n\t\t\t}\n\n\t\t\t// Write buffer views to buffer.\n\n\t\t\tbufferDef.byteLength = bufferByteLength;\n\t\t\tjsonDoc.resources[uri] = BufferUtils.concat(buffers);\n\n\t\t\tjson.buffers.push(bufferDef);\n\t\t});\n\n\t\tif (root.listAccessors().find((a) => !a.getBuffer())) {\n\t\t\tlogger.warn('Skipped writing one or more Accessors: no Buffer assigned.')\n\t\t}\n\n\t\t/* Materials. */\n\n\t\tjson.materials = root.listMaterials().map((material, index) => {\n\t\t\tconst materialDef = context.createPropertyDef(material) as GLTF.IMaterial;\n\n\t\t\t// Program state & blending.\n\n\t\t\tmaterialDef.alphaMode = material.getAlphaMode();\n\t\t\tif (material.getAlphaMode() === GLTF.MaterialAlphaMode.MASK) {\n\t\t\t\tmaterialDef.alphaCutoff = material.getAlphaCutoff();\n\t\t\t}\n\t\t\tmaterialDef.doubleSided = material.getDoubleSided();\n\n\t\t\t// Factors.\n\n\t\t\tmaterialDef.pbrMetallicRoughness = {};\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = material.getBaseColorFactor();\n\t\t\tmaterialDef.emissiveFactor = material.getEmissiveFactor();\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.getRoughnessFactor();\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.getMetallicFactor();\n\n\t\t\t// Textures.\n\n\t\t\tif (material.getBaseColorTexture()) {\n\t\t\t\tconst texture = material.getBaseColorTexture();\n\t\t\t\tconst textureInfo = material.getBaseColorTextureInfo();\n\t\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tif (material.getEmissiveTexture()) {\n\t\t\t\tconst texture = material.getEmissiveTexture();\n\t\t\t\tconst textureInfo = material.getEmissiveTextureInfo();\n\t\t\t\tmaterialDef.emissiveTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tif (material.getNormalTexture()) {\n\t\t\t\tconst texture = material.getNormalTexture();\n\t\t\t\tconst textureInfo = material.getNormalTextureInfo();\n\t\t\t\tconst textureInfoDef = context.createTextureInfoDef(texture, textureInfo) as GLTF.IMaterialNormalTextureInfo;\n\t\t\t\tif (material.getNormalScale() !== 1) {\n\t\t\t\t\ttextureInfoDef.scale = material.getNormalScale();\n\t\t\t\t}\n\t\t\t\tmaterialDef.normalTexture = textureInfoDef;\n\t\t\t}\n\n\t\t\tif (material.getOcclusionTexture()) {\n\t\t\t\tconst texture = material.getOcclusionTexture();\n\t\t\t\tconst textureInfo = material.getOcclusionTextureInfo();\n\t\t\t\tconst textureInfoDef = context.createTextureInfoDef(texture, textureInfo) as GLTF.IMaterialOcclusionTextureInfo;\n\t\t\t\tif (material.getOcclusionStrength() !== 1) {\n\t\t\t\t\ttextureInfoDef.strength = material.getOcclusionStrength();\n\t\t\t\t}\n\t\t\t\tmaterialDef.occlusionTexture = textureInfoDef;\n\t\t\t}\n\n\t\t\tif (material.getMetallicRoughnessTexture()) {\n\t\t\t\tconst texture = material.getMetallicRoughnessTexture();\n\t\t\t\tconst textureInfo = material.getMetallicRoughnessTextureInfo();\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tcontext.materialIndexMap.set(material, index);\n\t\t\treturn materialDef;\n\t\t});\n\n\t\t/* Meshes. */\n\n\t\tjson.meshes = root.listMeshes().map((mesh, index) => {\n\t\t\tconst meshDef = context.createPropertyDef(mesh) as GLTF.IMesh;\n\n\t\t\tlet targetNames: string[];\n\n\t\t\tmeshDef.primitives = mesh.listPrimitives().map((primitive) => {\n\t\t\t\tconst primitiveDef: GLTF.IMeshPrimitive = {attributes: {}};\n\t\t\t\tprimitiveDef.material = context.materialIndexMap.get(primitive.getMaterial());\n\t\t\t\tprimitiveDef.mode = primitive.getMode();\n\n\t\t\t\tif (Object.keys(primitive.getExtras()).length) {\n\t\t\t\t\tprimitiveDef.extras = primitive.getExtras();\n\t\t\t\t}\n\n\t\t\t\tif (primitive.getIndices()) {\n\t\t\t\t\tprimitiveDef.indices = context.accessorIndexMap.get(primitive.getIndices());\n\t\t\t\t}\n\n\t\t\t\tfor (const semantic of primitive.listSemantics()) {\n\t\t\t\t\tprimitiveDef.attributes[semantic] = context.accessorIndexMap.get(primitive.getAttribute(semantic));\n\t\t\t\t}\n\n\t\t\t\tfor (const target of primitive.listTargets()) {\n\t\t\t\t\tconst targetDef = {};\n\n\t\t\t\t\tfor (const semantic of target.listSemantics()) {\n\t\t\t\t\t\ttargetDef[semantic] = context.accessorIndexMap.get(target.getAttribute(semantic));\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitiveDef.targets = primitiveDef.targets || [];\n\t\t\t\t\tprimitiveDef.targets.push(targetDef);\n\t\t\t\t}\n\n\t\t\t\tif (primitive.listTargets().length && !targetNames) {\n\t\t\t\t\ttargetNames = primitive.listTargets().map((target) => target.getName());\n\t\t\t\t}\n\n\t\t\t\treturn primitiveDef;\n\t\t\t});\n\n\t\t\tif (mesh.getWeights().length) {\n\t\t\t\tmeshDef.weights = mesh.getWeights();\n\t\t\t}\n\n\t\t\tif (targetNames) {\n\t\t\t\tmeshDef.extras = meshDef.extras || {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\t\t\t}\n\n\t\t\tcontext.meshIndexMap.set(mesh, index);\n\t\t\treturn meshDef;\n\t\t});\n\n\t\t/** Cameras. */\n\n\t\tjson.cameras = root.listCameras().map((camera, index) => {\n\t\t\tconst cameraDef = context.createPropertyDef(camera) as GLTF.ICamera;\n\t\t\tcameraDef.type = camera.getType();\n\t\t\tif (cameraDef.type === GLTF.CameraType.PERSPECTIVE) {\n\t\t\t\tcameraDef.perspective = {\n\t\t\t\t\tznear: camera.getZNear(),\n\t\t\t\t\tzfar: camera.getZFar(),\n\t\t\t\t\tyfov: camera.getYFov(),\n\t\t\t\t\taspectRatio: camera.getAspectRatio(),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcameraDef.orthographic = {\n\t\t\t\t\tznear: camera.getZNear(),\n\t\t\t\t\tzfar: camera.getZFar(),\n\t\t\t\t\txmag: camera.getXMag(),\n\t\t\t\t\tymag: camera.getYMag(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcontext.cameraIndexMap.set(camera, index);\n\t\t\treturn cameraDef;\n\t\t});\n\n\t\t/* Nodes. */\n\n\t\tjson.nodes = root.listNodes().map((node, index) => {\n\t\t\tconst nodeDef = context.createPropertyDef(node) as GLTF.INode;\n\t\t\tnodeDef.translation = node.getTranslation();\n\t\t\tnodeDef.rotation = node.getRotation();\n\t\t\tnodeDef.scale = node.getScale();\n\n\t\t\tif (node.getWeights().length) {\n\t\t\t\tnodeDef.weights = node.getWeights();\n\t\t\t}\n\n\t\t\t// Attachments (mesh, camera, skin) defined later in writing process.\n\n\t\t\tcontext.nodeIndexMap.set(node, index);\n\t\t\treturn nodeDef;\n\t\t});\n\n\t\t/** Skins. */\n\n\t\tjson.skins = root.listSkins().map((skin, index) => {\n\t\t\tconst skinDef = context.createPropertyDef(skin) as GLTF.ISkin;\n\n\t\t\tif (skin.getInverseBindMatrices()) {\n\t\t\t\tskinDef.inverseBindMatrices = context.accessorIndexMap.get(skin.getInverseBindMatrices());\n\t\t\t}\n\n\t\t\tif (skin.getSkeleton()) {\n\t\t\t\tskinDef.skeleton = context.nodeIndexMap.get(skin.getSkeleton());\n\t\t\t}\n\n\t\t\tskinDef.joints = skin.listJoints().map((joint) => context.nodeIndexMap.get(joint));\n\n\t\t\tcontext.skinIndexMap.set(skin, index);\n\t\t\treturn skinDef;\n\t\t});\n\n\t\t/** Node attachments. */\n\n\t\troot.listNodes().forEach((node, index) => {\n\t\t\tconst nodeDef = json.nodes[index];\n\n\t\t\tif (node.getMesh()) {\n\t\t\t\tnodeDef.mesh = context.meshIndexMap.get(node.getMesh());\n\t\t\t}\n\n\t\t\tif (node.getCamera()) {\n\t\t\t\tnodeDef.camera = context.cameraIndexMap.get(node.getCamera());\n\t\t\t}\n\n\t\t\tif (node.getSkin()) {\n\t\t\t\tnodeDef.skin = context.skinIndexMap.get(node.getSkin());\n\t\t\t}\n\n\t\t\tif (node.listChildren().length > 0) {\n\t\t\t\tnodeDef.children = node.listChildren().map((node) => context.nodeIndexMap.get(node));\n\t\t\t}\n\t\t});\n\n\t\t/** Animations. */\n\n\t\tjson.animations = root.listAnimations().map((animation) => {\n\t\t\tconst animationDef = context.createPropertyDef(animation) as GLTF.IAnimation;\n\n\t\t\tconst samplerIndexMap: Map<AnimationSampler, number> = new Map();\n\n\t\t\tanimationDef.samplers = animation.listSamplers()\n\t\t\t\t.map((sampler, samplerIndex) => {\n\t\t\t\t\tconst samplerDef = context.createPropertyDef(sampler) as GLTF.IAnimationSampler;\n\t\t\t\t\tsamplerDef.input = context.accessorIndexMap.get(sampler.getInput());\n\t\t\t\t\tsamplerDef.output = context.accessorIndexMap.get(sampler.getOutput());\n\t\t\t\t\tsamplerDef.interpolation = sampler.getInterpolation();\n\t\t\t\t\tsamplerIndexMap.set(sampler, samplerIndex);\n\t\t\t\t\treturn samplerDef;\n\t\t\t\t})\n\n\t\t\tanimationDef.channels = animation.listChannels()\n\t\t\t\t.map((channel) => {\n\t\t\t\t\tconst channelDef = context.createPropertyDef(channel) as GLTF.IAnimationChannel;\n\t\t\t\t\tchannelDef.sampler = samplerIndexMap.get(channel.getSampler());\n\t\t\t\t\tchannelDef.target = {\n\t\t\t\t\t\tnode: context.nodeIndexMap.get(channel.getTargetNode()),\n\t\t\t\t\t\tpath: channel.getTargetPath(),\n\t\t\t\t\t};\n\t\t\t\t\treturn channelDef;\n\t\t\t\t})\n\n\t\t\treturn animationDef;\n\t\t});\n\n\t\t/* Scenes. */\n\n\t\tjson.scenes = root.listScenes().map((scene) => {\n\t\t\tconst sceneDef = context.createPropertyDef(scene) as GLTF.IScene;\n\t\t\tsceneDef.nodes = scene.listChildren().map((node) => context.nodeIndexMap.get(node));\n\t\t\treturn sceneDef;\n\t\t});\n\n\t\t/* Extensions. */\n\n\t\tjson.extensionsUsed = root.listExtensionsUsed().map((ext) => ext.extensionName);\n\t\tjson.extensionsRequired = root.listExtensionsRequired().map((ext) => ext.extensionName);\n\t\troot.listExtensionsUsed().forEach((extension) => extension.write(context));\n\n\t\t//\n\n\t\tclean(json);\n\n\t\treturn jsonDoc;\n\t}\n}\n\n/**\n * Removes empty and null values from an object.\n * @param object\n * @hidden\n */\nfunction clean(object): void {\n\tconst unused: string[] = [];\n\n\tfor (const key in object) {\n\t\tconst value = object[key];\n\t\tif (Array.isArray(value) && value.length === 0) {\n\t\t\tunused.push(key);\n\t\t} else if (value === null || value === '') {\n\t\t\tunused.push(value);\n\t\t}\n\t}\n\n\tfor (const key of unused) {\n\t\tdelete object[key];\n\t}\n}\n","import { GLB_BUFFER } from '../constants';\nimport { Document } from '../document';\nimport { Extension } from '../extension';\nimport { JSONDocument } from '../json-document';\nimport { BufferUtils, Logger } from '../utils/';\nimport { GLTFReader } from './reader';\nimport { GLTFWriter, WriterOptions } from './writer';\n\n/**\n * # PlatformIO\n *\n * *Abstract I/O service.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*ArrayBuffer*) and JSON ({@link JSONDocument}).\n *\n * For platform-specific implementations, see {@link NodeIO} and {@link WebIO}.\n *\n * @category I/O\n */\nexport abstract class PlatformIO {\n\n\tprotected _logger = Logger.DEFAULT_INSTANCE;\n\tprotected _extensions: typeof Extension[] = [];\n\tprotected _dependencies: {[key: string]: unknown} = {};\n\n\t/** Sets the {@link Logger} used by this I/O instance. Defaults to Logger.DEFAULT_INSTANCE. */\n\tpublic setLogger(logger: Logger): this {\n\t\tthis._logger = logger;\n\t\treturn this;\n\t}\n\n\t/** Registers extensions, enabling I/O class to read and write glTF assets requiring them. */\n\tpublic registerExtensions(extensions: typeof Extension[]): this {\n\t\tthis._extensions.push(...extensions);\n\t\treturn this;\n\t}\n\n\t/** Registers dependencies used (e.g. by extensions) in the I/O process. */\n\tpublic registerDependencies(dependencies: {[key: string]: unknown}): this {\n\t\tObject.assign(this._dependencies, dependencies);\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * JSON.\n\t */\n\n\t/** Converts glTF-formatted JSON and a resource map to a {@link Document}. */\n\tpublic readJSON (jsonDoc: JSONDocument): Document {\n\t\treturn GLTFReader.read(jsonDoc, {\n\t\t\textensions: this._extensions,\n\t\t\tdependencies: this._dependencies,\n\t\t\tlogger: this._logger\n\t\t});\n\t}\n\n\t/** Converts a {@link Document} to glTF-formatted JSON and a resource map. */\n\tpublic writeJSON (doc: Document, options: WriterOptions): JSONDocument {\n\t\tif (options.isGLB && doc.getRoot().listBuffers().length !== 1) {\n\t\t\tthrow new Error('GLB must have exactly 1 buffer.');\n\t\t}\n\t\treturn GLTFWriter.write(doc, options);\n\t}\n\n\t/**********************************************************************************************\n\t * Binary -> JSON.\n\t */\n\n\t/** Converts a GLB-formatted ArrayBuffer to a {@link JSONDocument}. */\n\tpublic binaryToJSON(glb: ArrayBuffer): JSONDocument {\n\t\t// Decode and verify GLB header.\n\t\tconst header = new Uint32Array(glb, 0, 3);\n\t\tif (header[0] !== 0x46546C67) {\n\t\t\tthrow new Error('Invalid glTF asset.');\n\t\t} else if (header[1] !== 2) {\n\t\t\tthrow new Error(`Unsupported glTF binary version, \"${header[1]}\".`);\n\t\t}\n\n\t\t// Decode and verify chunk headers.\n\t\tconst jsonChunkHeader = new Uint32Array(glb, 12, 2);\n\t\tconst jsonByteOffset = 20;\n\t\tconst jsonByteLength = jsonChunkHeader[0];\n\t\tconst binaryChunkHeader = new Uint32Array(glb, jsonByteOffset + jsonByteLength, 2);\n\t\tif (jsonChunkHeader[1] !== 0x4E4F534A || binaryChunkHeader[1] !== 0x004E4942) {\n\t\t\tthrow new Error('Unexpected GLB layout.');\n\t\t}\n\n\t\t// Decode content.\n\t\tconst jsonText = BufferUtils.decodeText(\n\t\t\tglb.slice(jsonByteOffset, jsonByteOffset + jsonByteLength)\n\t\t);\n\t\tconst json = JSON.parse(jsonText) as GLTF.IGLTF;\n\t\tconst binaryByteOffset = jsonByteOffset + jsonByteLength + 8;\n\t\tconst binaryByteLength = binaryChunkHeader[0];\n\t\tconst binary = glb.slice(binaryByteOffset, binaryByteOffset + binaryByteLength);\n\n\t\treturn {json, resources: {[GLB_BUFFER]: binary}};\n\t}\n\n\t/**********************************************************************************************\n\t * Binary.\n\t */\n\n\t/** Converts a GLB-formatted ArrayBuffer to a {@link Document}. */\n\tpublic readBinary(glb: ArrayBuffer): Document {\n\t\treturn this.readJSON(this.binaryToJSON(glb));\n\t}\n\n\t/** Converts a {@link Document} to a GLB-formatted ArrayBuffer. */\n\tpublic writeBinary(doc: Document): ArrayBuffer {\n\t\tconst {json, resources} = this.writeJSON(doc, {\n\t\t\tbasename: '',\n\t\t\tisGLB: true,\n\t\t\tlogger: this._logger,\n\t\t});\n\n\t\tconst jsonText = JSON.stringify(json);\n\t\tconst jsonChunkData = BufferUtils.pad( BufferUtils.encodeText(jsonText), 0x20 );\n\t\tconst jsonChunkHeader = new Uint32Array([jsonChunkData.byteLength, 0x4E4F534A]).buffer;\n\t\tconst jsonChunk = BufferUtils.concat([jsonChunkHeader, jsonChunkData]);\n\n\t\tconst binaryChunkData = BufferUtils.pad(Object.values(resources)[0] || new ArrayBuffer(0), 0x00);\n\t\tconst binaryChunkHeader = new Uint32Array([binaryChunkData.byteLength, 0x004E4942]).buffer;\n\t\tconst binaryChunk = BufferUtils.concat([binaryChunkHeader, binaryChunkData]);\n\n\t\tconst header = new Uint32Array([\n\t\t\t0x46546C67, 2, 12 + jsonChunk.byteLength + binaryChunk.byteLength\n\t\t]).buffer;\n\n\t\treturn BufferUtils.concat([header, jsonChunk, binaryChunk]);\n\t}\n}\n","import { Document } from '../document';\nimport { JSONDocument } from '../json-document';\nimport { BufferUtils, FileUtils, uuid } from '../utils/';\nimport { PlatformIO } from './platform-io';\nimport { GLTFReader } from './reader';\nimport { GLTFWriter } from './writer';\n\n/**\n * # NodeIO\n *\n * *I/O service for Node.js.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*ArrayBuffer*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * const fs = require('fs');\n * const path = require('path');\n * const { NodeIO } = require('@gltf-transform/core');\n *\n * const io = new NodeIO();\n *\n * // Read.\n * io.read('model.glb');             // → Document\n * io.readBinary(ArrayBuffer);       // → Document\n *\n * // Write.\n * io.write('model.glb', doc); // → void\n * io.writeBinary(doc);        // → ArrayBuffer\n * ```\n *\n * @category I/O\n */\nexport class NodeIO extends PlatformIO {\n\n\tprivate _fs;\n\tprivate _path;\n\n\t/** Constructs a new NodeIO service. Instances are reusable. */\n\tconstructor() {\n\t\tsuper();\n\t\t// Excluded from browser builds with 'package.browser' field.\n\t\tthis._fs = require('fs');\n\t\tthis._path = require('path');\n\t}\n\n\t/**********************************************************************************************\n\t * Public.\n\t */\n\n\t/** Loads a local path and returns a {@link Document} instance. */\n\tpublic read (uri: string): Document {\n\t\tconst jsonDoc = this.readAsJSON(uri);\n\t\treturn GLTFReader.read(jsonDoc, {\n\t\t\textensions: this._extensions,\n\t\t\tdependencies: this._dependencies,\n\t\t\tlogger: this._logger\n\t\t});\n\t}\n\n\t/** Loads a local path and returns a {@link JSONDocument} struct, without parsing. */\n\tpublic readAsJSON (uri: string): JSONDocument {\n\t\tconst isGLB = !!(uri.match(/\\.glb$/) || uri.match(/^data:application\\/octet-stream;/));\n\t\treturn isGLB ? this._readGLB(uri) : this._readGLTF(uri);\n\t}\n\n\t/** Writes a {@link Document} instance to a local path. */\n\tpublic write (uri: string, doc: Document): void {\n\t\tconst isGLB = !!uri.match(/\\.glb$/);\n\t\tisGLB ? this._writeGLB(uri, doc) : this._writeGLTF(uri, doc);\n\t}\n\n\t/**********************************************************************************************\n\t * Private.\n\t */\n\n\t/** @hidden */\n\tprivate _readGLB (uri: string): JSONDocument {\n\t\tconst buffer: Buffer = this._fs.readFileSync(uri);\n\t\tconst arrayBuffer = BufferUtils.trim(buffer);\n\t\treturn this.binaryToJSON(arrayBuffer);\n\t}\n\n\t/** @hidden */\n\tprivate _readGLTF (uri: string): JSONDocument {\n\t\tconst dir = this._path.dirname(uri);\n\t\tconst jsonDoc = {\n\t\t\tjson: JSON.parse(this._fs.readFileSync(uri, 'utf8')),\n\t\t\tresources: {}\n\t\t} as JSONDocument;\n\t\tconst images = jsonDoc.json.images || [];\n\t\tconst buffers = jsonDoc.json.buffers || [];\n\t\t[...images, ...buffers].forEach((resource: GLTF.IBuffer|GLTF.IImage) => {\n\t\t\tif (!resource.uri) return; // Skip image.bufferView.\n\n\t\t\tif (!resource.uri.match(/data:/)) {\n\t\t\t\tconst absURI = this._path.resolve(dir, resource.uri);\n\t\t\t\tjsonDoc.resources[resource.uri] = BufferUtils.trim(this._fs.readFileSync(absURI));\n\t\t\t} else {\n\t\t\t\t// Rewrite Data URIs to something short and unique.\n\t\t\t\tconst resourceUUID = `__${uuid()}.${FileUtils.extension(resource.uri)}`;\n\t\t\t\tjsonDoc.resources[resourceUUID] = BufferUtils.createBufferFromDataURI(resource.uri);\n\t\t\t\tresource.uri = resourceUUID;\n\t\t\t}\n\t\t});\n\t\treturn jsonDoc;\n\t}\n\n\t/** @hidden */\n\tprivate _writeGLTF (uri: string, doc: Document): void {\n\t\tconst {json, resources} = GLTFWriter.write(doc, {\n\t\t\tbasename: FileUtils.basename(uri),\n\t\t\tisGLB: false,\n\t\t\tlogger: this._logger\n\t\t});\n\t\tconst {_fs: fs, _path: path} = this;\n\t\tconst dir = path.dirname(uri);\n\t\tfs.writeFileSync(uri, JSON.stringify(json, null, 2));\n\t\tObject.keys(resources).forEach((resourceName) => {\n\t\t\tconst resource = Buffer.from(resources[resourceName]);\n\t\t\tfs.writeFileSync(path.join(dir, resourceName), resource);\n\t\t});\n\t}\n\n\t/** @hidden */\n\tprivate _writeGLB (uri: string, doc: Document): void {\n\t\tconst buffer = Buffer.from(this.writeBinary(doc));\n\t\tthis._fs.writeFileSync(uri, buffer);\n\t}\n}\n","import { Document } from '../document';\nimport { JSONDocument } from '../json-document';\nimport { PlatformIO } from './platform-io';\n\nconst DEFAULT_INIT: RequestInit = {};\n\n/**\n * # WebIO\n *\n * *I/O service for Web.*\n *\n * The most common use of the I/O service is to read/write a {@link Document} with a given path.\n * Methods are also available for converting in-memory representations of raw glTF files, both\n * binary (*ArrayBuffer*) and JSON ({@link JSONDocument}).\n *\n * Usage:\n *\n * ```typescript\n * import { WebIO } from '@gltf-transform/core';\n *\n * const io = new WebIO({credentials: 'include'});\n *\n * // Read.\n * const doc = await io.read('model.glb');  // → Document\n * const doc = io.readBinary(ArrayBuffer);  // → Document\n *\n * // Write.\n * const arrayBuffer = io.writeBinary(doc); // → ArrayBuffer\n * ```\n *\n * @category I/O\n */\nexport class WebIO extends PlatformIO {\n\n\t/**\n\t * Constructs a new WebIO service. Instances are reusable.\n\t * @param _fetchConfig Configuration object for Fetch API.\n\t */\n\tconstructor(private readonly _fetchConfig: RequestInit = DEFAULT_INIT) {\n\t\tsuper();\n\t}\n\n\t/**********************************************************************************************\n\t * Public.\n\t */\n\n\t/** Loads a URI and returns a {@link Document} instance. */\n\tpublic read (uri: string): Promise<Document> {\n\t\treturn this.readAsJSON(uri).then((jsonDoc) => this.readJSON(jsonDoc));\n\t}\n\n\t/** Loads a URI and returns a {@link JSONDocument} struct, without parsing. */\n\tpublic readAsJSON (uri: string): Promise<JSONDocument> {\n\t\tconst isGLB = !!(uri.match(/\\.glb$/) || uri.match(/^data:application\\/octet-stream;/));\n\t\treturn isGLB ? this._readGLB(uri) : this._readGLTF(uri);\n\t}\n\n\t/**********************************************************************************************\n\t * Private.\n\t */\n\n\t/** @hidden */\n\tprivate _readGLTF (uri: string): Promise<JSONDocument> {\n\t\tconst jsonDoc = {json: {}, resources: {}} as JSONDocument;\n\t\treturn fetch(uri, this._fetchConfig)\n\t\t.then((response) => response.json())\n\t\t.then((json: GLTF.IGLTF) => {\n\t\t\tjsonDoc.json = json;\n\t\t\tconst images = json.images || [];\n\t\t\tconst buffers = json.buffers || [];\n\t\t\tconst pendingResources: Array<Promise<void>> = [...images, ...buffers]\n\t\t\t.map((resource: GLTF.IBuffer|GLTF.IImage) => {\n\t\t\t\tif (resource.uri) {\n\t\t\t\t\treturn fetch(resource.uri, this._fetchConfig)\n\t\t\t\t\t.then((response) => response.arrayBuffer())\n\t\t\t\t\t.then((arrayBuffer) => {\n\t\t\t\t\t\tjsonDoc.resources[resource.uri] = arrayBuffer;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn Promise.all(pendingResources).then(() => jsonDoc);\n\t\t});\n\t}\n\n\t/** @hidden */\n\tprivate _readGLB (uri: string): Promise<JSONDocument> {\n\t\treturn fetch(uri, this._fetchConfig)\n\t\t\t.then((response) => response.arrayBuffer())\n\t\t\t.then((arrayBuffer) => this.binaryToJSON(arrayBuffer));\n\t}\n}\n"],"names":["PropertyType","__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Link","_name","_parent","_child","this","canLink","Error","getName","getParent","getChild","setChild","child","dispose","_disposed","_listeners","forEach","fn","onDispose","push","isDisposed","EMPTY_SET","Set","Graph","Map","getLinks","Array","from","_links","listParents","node","links","_childRefs","get","map","link","listChildren","_parentRefs","disconnectChildren","disconnectParents","filter","swapChild","parent","prevChild","nextChild","_this","has","set","add","name","a","b","registerLink","_this2","unlink","GraphChild","propertyKey","value","isArray","enumerable","GraphChildList","GraphNode","graph","other","detach","swap","old","replacement","addGraphChild","remaining","l","removeGraphChild","clearGraphChildList","listGraphParents","BufferUtils","createBufferFromDataURI","dataURI","Buffer","byteString","atob","split","ia","Uint8Array","charCodeAt","buffer","data","isBase64","indexOf","trim","encodeText","text","TextEncoder","encode","decodeText","TextDecoder","decode","toString","byteOffset","slice","byteLength","concat","buffers","totalByteLength","result","pad","arrayBuffer","paddingByte","paddedLength","padNumber","array","v","Math","ceil","equals","view1","DataView","view2","getUint8","ColorUtils","hexToFactor","hex","floor","convertSRGBToLinear","factorToHex","factor","convertLinearToSRGB","source","pow","FileUtils","basename","path","pop","shift","extension","ImageUtils","getSizeJPEG","next","view","getUint16","validateBuffer","TypeError","getSizePNG","getUint32","mimeTypeToExtension","mimeType","extensionToMimeType","MathUtils","identity","denormalize","componentType","max","normalize","f","round","Logger","verbosity","debug","Verbosity","DEBUG","console","info","INFO","warn","WARN","error","ERROR","SILENT","ALPHABET","previousIDs","generateOne","rtn","charAt","random","uuid","retries","id","COPY_IDENTITY","t","Property","setName","getExtras","_extras","setExtras","extras","clone","PropertyClass","constructor","copy","resolve","JSON","parse","stringify","n","propertyType","TOKEN_WARNING","ExtensibleProperty","_Property","extensions","setExtension","extensionName","getExtension","find","extensionProperty","prevExtension","_validateParent","listExtensions","Accessor","ACCESSOR","_ExtensibleProperty","_array","_type","_componentType","_normalized","_in","_out","setBuffer","getElementSize","type","getComponentSize","getMinNormalized","elementSize","getMin","j","count","getCount","Infinity","Number","isFinite","min","getMaxNormalized","getMax","getType","setType","BYTES_PER_ELEMENT","getComponentType","getNormalized","setNormalized","normalized","getScalar","index","setScalar","x","getElement","setElement","getBuffer","getArray","setArray","Float32Array","Uint32Array","Uint16Array","Int16Array","Int8Array","arrayToComponentType","getByteLength","SCALAR","VEC2","VEC3","VEC4","MAT3","MAT4","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","UNSIGNED_INT","FLOAT","Animation","ANIMATION","channels","samplers","addChannel","addSampler","channel","removeChannel","listChannels","sampler","removeSampler","listSamplers","AnimationChannel","ANIMATION_CHANNEL","_targetPath","targetNode","setTargetNode","setSampler","getTargetPath","setTargetPath","targetPath","getTargetNode","getSampler","AnimationSampler","ANIMATION_SAMPLER","_interpolation","input","setInput","output","setOutput","getInterpolation","setInterpolation","interpolation","getInput","getOutput","BUFFER","_uri","getURI","setURI","uri","Camera","CAMERA","_znear","_zfar","_aspectRatio","_yfov","_xmag","_ymag","getZNear","setZNear","znear","getZFar","setZFar","zfar","getAspectRatio","setAspectRatio","aspectRatio","getYFov","setYFov","yfov","getXMag","setXMag","xmag","getYMag","setYMag","ymag","ExtensionProperty","_extension","addExtensionProperty","removeExtensionProperty","parentTypes","includes","AttributeLink","semantic","IndexLink","PropertyGraph","linkAttribute","linkIndex","TextureInfo","TEXTURE_INFO","_texCoord","_magFilter","_minFilter","_wrapS","_wrapT","getTexCoord","setTexCoord","texCoord","getMagFilter","setMagFilter","magFilter","getMinFilter","setMinFilter","minFilter","getWrapS","setWrapS","wrapS","getWrapT","setWrapT","wrapT","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","Material","MATERIAL","_alphaMode","_alphaCutoff","_doubleSided","_baseColorFactor","_emissiveFactor","_normalScale","_occlusionStrength","_roughnessFactor","_metallicFactor","baseColorTexture","setBaseColorTexture","getBaseColorTextureInfo","baseColorTextureInfo","emissiveTexture","setEmissiveTexture","getEmissiveTextureInfo","emissiveTextureInfo","normalTexture","setNormalTexture","getNormalTextureInfo","normalTextureInfo","occlusionTexture","setOcclusionTexture","getOcclusionTextureInfo","occlusionTextureInfo","metallicRoughnessTexture","setMetallicRoughnessTexture","getMetallicRoughnessTextureInfo","metallicRoughnessTextureInfo","getDoubleSided","setDoubleSided","doubleSided","getAlpha","setAlpha","alpha","getAlphaMode","setAlphaMode","alphaMode","getAlphaCutoff","setAlphaCutoff","alphaCutoff","getBaseColorFactor","setBaseColorFactor","baseColorFactor","getBaseColorHex","setBaseColorHex","getBaseColorTexture","texture","getEmissiveFactor","setEmissiveFactor","emissiveFactor","getEmissiveHex","setEmissiveHex","getEmissiveTexture","getNormalScale","setNormalScale","normalScale","getNormalTexture","getOcclusionStrength","setOcclusionStrength","occlusionStrength","getOcclusionTexture","getRoughnessFactor","setRoughnessFactor","roughnessFactor","getMetallicFactor","setMetallicFactor","metallicFactor","getMetallicRoughnessTexture","Mesh","MESH","_weights","primitives","addPrimitive","primitive","removePrimitive","listPrimitives","p","getWeights","setWeights","weights","Node","NODE","_translation","_rotation","_scale","camera","setCamera","mesh","setMesh","skin","setSkin","children","addChild","getTranslation","getRotation","getScale","setTranslation","translation","setRotation","rotation","setScale","scale","getMatrix","fromRotationTranslationScale","getWorldTranslation","getWorldMatrix","getWorldRotation","getWorldScale","getScaling","ancestor","ancestors","worldMatrix","multiply","removeChild","getMesh","getCamera","getSkin","traverse","Primitive","PRIMITIVE","_mode","indices","setIndices","material","setMaterial","attributes","listSemantics","setAttribute","getAttribute","targets","addTarget","getIndices","accessor","prevAccessor","toLowerCase","listAttributes","getMaterial","getMode","setMode","mode","listTargets","removeTarget","PrimitiveTarget","PRIMITIVE_TARGET","Root","ROOT","generator","version","assign","_asset","accessors","_addAccessor","animations","_addAnimation","_addBuffer","cameras","_addCamera","materials","_addMaterial","meshes","_addMesh","nodes","_addNode","scenes","_addScene","skins","_addSkin","textures","_addTexture","getAsset","listExtensionsUsed","_extensions","listExtensionsRequired","isRequired","_enableExtension","_disableExtension","scene","listScenes","listNodes","listCameras","listSkins","listMeshes","listMaterials","listTextures","animation","listAnimations","listAccessors","listBuffers","Scene","SCENE","Skin","SKIN","skeleton","setSkeleton","inverseBindMatrices","setInverseBindMatrices","joints","addJoint","getSkeleton","getInverseBindMatrices","joint","removeJoint","listJoints","Texture","TEXTURE","_mimeType","_image","getMimeType","setMimeType","getImage","setImage","image","getSize","match","observer","pact","thenable","done","values","reject","Document","_graph","DEFAULT_INSTANCE","getRoot","_root","getGraph","getLogger","_logger","setLogger","logger","merge","thisExtensions","otherExtension","thisExtension","createExtension","setRequired","visited","propertyMap","thisProp","otherProp","transform","ctor","ext","createScene","createNode","createCamera","createSkin","createMesh","createPrimitive","createPrimitiveTarget","createMaterial","createTexture","createAnimation","createAnimationChannel","createAnimationSampler","createAccessor","createBuffer","Extension","doc","properties","required","property","install","dependency","provide","readerContext","ReaderContext","jsonDoc","setTextureInfo","textureInfo","textureInfoDef","textureInfos","undefined","textureDef","json","samplerDef","ComponentTypeToTypedArray","5120","5121","5122","5123","5125","5126","DEFAULT_OPTIONS","dependencies","GLTFReader","read","options","validate","context","assetDef","asset","copyright","minVersion","extensionsUsed","extensionsRequired","EXTENSION_NAME","bufferDef","bufferViewBuffers","bufferViews","bufferViewDef","accessorDef","bufferView","sparse","TypedArray","getAccessorArray","indicesDef","valuesDef","getSparseArray","imageDefs","images","textureDefs","provideTypes","imageDef","imageData","resources","materialDef","pbrDef","pbrMetallicRoughness","strength","meshDefs","meshDef","primitiveDef","entries","targetNames","targetDef","targetIndex","targetName","cameraDef","perspective","orthographic","nodeDefs","nodeDef","matrix","skinDef","nodeIndex","childIndex","animationDef","channelDef","sceneDef","resource","byteStride","componentSize","accessorByteOffset","getFloat32","getInt16","getInt8","getInterleavedArray","start","WriterContext","createTextureInfoDef","samplerKey","samplerDefIndexMap","imageIndexMap","textureKey","textureDefIndexMap","textureInfoDefMap","createPropertyDef","def","keys","createAccessorDef","createImageData","isGLB","imageURIGenerator","createURI","UniqueURIGenerator","multiple","object","counter","GLTFWriter","write","root","numBuffers","numImages","concatAccessors","bufferIndex","bufferByteOffset","bufferViewTarget","accessorIndexMap","interleaveAccessors","vertexCount","ArrayBuffer","vertexByteOffset","viewByteOffset","setFloat32","setInt8","setInt16","setUint8","setUint16","setUint32","bufferURIGenerator","accessorLinks","uses","textureIndex","attributeAccessors","indexAccessors","ibmAccessors","otherAccessors","isAttribute","isIndex","isIBM","isOther","accessorRefs","primitiveAccessors","bufferByteLength","size","indexResult","primitiveResult","ibmResult","otherResult","NAME","materialIndexMap","meshIndexMap","cameraIndexMap","nodeIndexMap","skinIndexMap","samplerIndexMap","samplerIndex","unused","clean","PlatformIO","registerExtensions","registerDependencies","_dependencies","readJSON","writeJSON","binaryToJSON","glb","header","jsonChunkHeader","jsonByteLength","binaryChunkHeader","jsonText","binaryByteOffset","binary","readBinary","writeBinary","jsonChunkData","jsonChunk","binaryChunkData","binaryChunk","NodeIO","_fs","require","_path","readAsJSON","_readGLB","_readGLTF","_writeGLB","_writeGLTF","readFileSync","dir","dirname","resourceUUID","absURI","fs","writeFileSync","resourceName","join","DEFAULT_INIT","WebIO","_fetchConfig","then","fetch","response","pendingResources","_this3","Promise","all","_this4"],"mappings":"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"}