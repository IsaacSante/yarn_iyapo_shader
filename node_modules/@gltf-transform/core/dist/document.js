var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Accessor, Animation, AnimationChannel, AnimationSampler, Buffer, Camera, ExtensionProperty, Material, Mesh, Node, Primitive, PrimitiveTarget, PropertyGraph, Root, Scene, Skin, Texture } from './properties';
import { Logger } from './utils';
/**
 * # Document
 *
 * *Wraps a glTF asset and its resources for easier modification.*
 *
 * Documents manage glTF assets and the relationships among dependencies. The document wrapper
 * allow tools to read and write changes without dealing with array indices or byte offsets, which
 * would otherwise require careful management over the course of a file modification. An internal
 * graph structure allows any property in the glTF file to maintain references to its dependencies,
 * and makes it easy to determine where a particular property dependency is being used. For
 * example, finding a list of materials that use a particular texture is as simple as calling
 * {@link Texture.listParents}().
 *
 * A new resource {@link Property} (e.g. a {@link Mesh} or {@link Material}) is created by calling
 * 'create' methods on the document. Resources are destroyed by calling {@link Property.dispose}().
 *
 * ```ts
 * import { Document } from '@gltf-transform/core';
 * import { dedup } from '@gltf-transform/lib';
 *
 * const doc = new Document();
 *
 * const texture1 = doc.createTexture('myTexture')
 * 	.setImage(arrayBuffer)
 * 	.setMimeType('image/png');
 * const texture2 = doc.createTexture('myTexture2')
 * 	.setImage(arrayBuffer)
 * 	.setMimeType('image/png');
 *
 * // Document containing duplicate copies of the same texture.
 * doc.getRoot().listTextures(); // → [texture x 2]
 *
 * await doc.transform(
 * 	dedup({textures: true}),
 * 	// ...
 * );
 *
 * // Document with duplicate textures removed.
 * doc.getRoot().listTextures(); // → [texture x 1]
 * ```
 *
 * Reference:
 * - [glTF → Basics](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#gltf-basics)
 * - [glTF → Concepts](https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#concepts)
 *
 * @category Documents
 */
export class Document {
    constructor() {
        this._graph = new PropertyGraph();
        this._root = new Root(this._graph);
        this._logger = Logger.DEFAULT_INSTANCE;
    }
    /** Returns the glTF {@link Root} property. */
    getRoot() {
        return this._root;
    }
    /**
     * Returns the {@link Graph} representing connectivity of resources within this document.
     *
     * @hidden
     */
    getGraph() {
        return this._graph;
    }
    /** Returns the {@link Logger} instance used for any operations performed on this document. */
    getLogger() {
        return this._logger;
    }
    /**
     * Overrides the {@link Logger} instance used for any operations performed on this document.
     *
     * Usage:
     *
     * ```ts
     * doc
     * 	.setLogger(new Logger(Logger.Verbosity.SILENT))
     * 	.transform(split(), ao({samples: 50}));
     * ```
     */
    setLogger(logger) {
        this._logger = logger;
        return this;
    }
    /** Clones this Document, copying all resources within it. */
    clone() {
        return new Document().merge(this);
    }
    /** Merges the content of another Document into this one, without affecting the original. */
    merge(other) {
        // 1. Attach extensions.
        const thisExtensions = {};
        for (const otherExtension of other.getRoot().listExtensionsUsed()) {
            const thisExtension = this.createExtension(otherExtension.constructor);
            if (otherExtension.isRequired())
                thisExtension.setRequired(true);
            thisExtensions[thisExtension.extensionName] = thisExtension;
        }
        // 2. Preconfigure the Root and merge history.
        const visited = new Set();
        const propertyMap = new Map();
        visited.add(other._root);
        propertyMap.set(other._root, this._root);
        // 3. Create stub classes for every Property in other Document.
        for (const link of other._graph.getLinks()) {
            for (const thisProp of [link.getParent(), link.getChild()]) {
                if (!visited.has(thisProp)) {
                    const PropertyClass = thisProp.constructor;
                    const otherProp = thisProp instanceof ExtensionProperty
                        ? new PropertyClass(this._graph, thisExtensions[thisProp.extensionName])
                        : new PropertyClass(this._graph);
                    propertyMap.set(thisProp, otherProp);
                    visited.add(thisProp);
                }
            }
        }
        // 4. Assemble the links between Properties.
        const resolve = (p) => propertyMap.get(p);
        for (const otherProp of visited) {
            const thisProp = propertyMap.get(otherProp);
            thisProp.copy(otherProp, resolve);
        }
        return this;
    }
    /**
     * Applies a series of modifications to this document. Each transformation is synchronous,
     * takes the {@link Document} as input, and returns nothing. Transforms are applied in the
     * order given, which may affect the final result.
     *
     * Usage:
     *
     * ```ts
     * await doc.transform(
     * 	ao({samples: 500}),
     * 	prune()
     * );
     * ```
     *
     * @param transforms List of synchronous transformation functions to apply.
     */
    transform(...transforms) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const transform of transforms) {
                yield transform(this);
            }
            return this;
        });
    }
    /**********************************************************************************************
     * Extension factory method.
     */
    /**
     * Creates a new {@link Extension}, for the extension type of the given constructor. If the
     * extension is already enabled for this Document, the previous Extension reference is reused.
     */
    createExtension(ctor) {
        const prevExtension = this.getRoot().listExtensionsUsed()
            .find((ext) => ext.extensionName === ctor['EXTENSION_NAME']);
        return (prevExtension || new ctor(this));
    }
    /**********************************************************************************************
     * Property factory methods.
     */
    /** Creates a new {@link Scene} attached to this document's {@link Root}. */
    createScene(name = '') {
        const scene = new Scene(this._graph, name);
        this._root._addScene(scene);
        return scene;
    }
    /** Creates a new {@link Node} attached to this document's {@link Root}. */
    createNode(name = '') {
        const node = new Node(this._graph, name);
        this._root._addNode(node);
        return node;
    }
    /** Creates a new {@link Camera} attached to this document's {@link Root}. */
    createCamera(name = '') {
        const camera = new Camera(this._graph, name);
        this._root._addCamera(camera);
        return camera;
    }
    /** Creates a new {@link Skin} attached to this document's {@link Root}. */
    createSkin(name = '') {
        const skin = new Skin(this._graph, name);
        this._root._addSkin(skin);
        return skin;
    }
    /** Creates a new {@link Mesh} attached to this document's {@link Root}. */
    createMesh(name = '') {
        const mesh = new Mesh(this._graph, name);
        this._root._addMesh(mesh);
        return mesh;
    }
    /**
     * Creates a new {@link Primitive}. Primitives must be attached to a {@link Mesh}
     * for use and export; they are not otherwise associated with a {@link Root}.
     */
    createPrimitive() {
        return new Primitive(this._graph);
    }
    /**
     * Creates a new {@link PrimitiveTarget}, or morph target. Targets must be attached to a
     * {@link Primitive} for use and export; they are not otherwise associated with a {@link Root}.
     */
    createPrimitiveTarget(name = '') {
        return new PrimitiveTarget(this._graph, name);
    }
    /** Creates a new {@link Material} attached to this document's {@link Root}. */
    createMaterial(name = '') {
        const material = new Material(this._graph, name);
        this._root._addMaterial(material);
        return material;
    }
    /** Creates a new {@link Texture} attached to this document's {@link Root}. */
    createTexture(name = '') {
        const texture = new Texture(this._graph, name);
        this._root._addTexture(texture);
        return texture;
    }
    /** Creates a new {@link Animation} attached to this document's {@link Root}. */
    createAnimation(name = '') {
        const animation = new Animation(this._graph, name);
        this._root._addAnimation(animation);
        return animation;
    }
    /**
     * Creates a new {@link AnimationChannel}. Channels must be attached to an {@link Animation}
     * for use and export; they are not otherwise associated with a {@link Root}.
     */
    createAnimationChannel(name = '') {
        return new AnimationChannel(this._graph, name);
    }
    /**
     * Creates a new {@link AnimationSampler}. Samplers must be attached to an {@link Animation}
     * for use and export; they are not otherwise associated with a {@link Root}.
     */
    createAnimationSampler(name = '') {
        return new AnimationSampler(this._graph, name);
    }
    /** Creates a new {@link Accessor} attached to this document's {@link Root}. */
    createAccessor(name = '', buffer = null) {
        if (!buffer) {
            buffer = this.getRoot().listBuffers()[0];
        }
        const accessor = new Accessor(this._graph, name).setBuffer(buffer);
        this._root._addAccessor(accessor);
        return accessor;
    }
    /** Creates a new {@link Buffer} attached to this document's {@link Root}. */
    createBuffer(name = '') {
        const buffer = new Buffer(this._graph, name);
        this._root._addBuffer(buffer);
        return buffer;
    }
}
