{"version":3,"file":"lib.modern.js","sources":["../src/ao.ts","../src/bounds.ts","../src/center.ts","../src/colorspace.ts","../src/dedup.ts","../src/utils.ts","../src/metal-rough.ts","../src/partition.ts","../src/sequence.ts","../src/inspect.ts"],"sourcesContent":["import * as geoaoNamespace from 'geo-ambient-occlusion';\nimport * as reglNamespace from 'regl';\nimport { Document, Primitive, Transform } from '@gltf-transform/core';\n\nconst NAME = 'ao';\nconst geoao = geoaoNamespace['default'] as Function;\nconst REGL = reglNamespace['default'] as Function;\n\ninterface GLFactory {\n\t(w: number, h: number): WebGLRenderingContext;\n}\n\nexport interface AOOptions {\n\tgl?: GLFactory;\n\tresolution?: number;\n\tsamples?: number;\n}\n\nconst DEFAULT_OPTIONS: AOOptions = {\n\tresolution: 512,\n\tsamples: 500,\n};\n\n// A greyscale 256x1 gradient.\nconst TEXTURE_MIME_TYPE = 'image/png';\nconst TEXTURE_DATA = new Uint8Array([\n\t137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 1, 0, 0, 0, 0, 1, 8, 6, 0,\n\t0, 0, 49, 89, 112, 119, 0, 0, 0, 32, 73, 68, 65, 84, 56, 79, 99, 100, 96, 96, 248, 207, 196,\n\t196, 196, 0, 2, 163, 244, 104, 56, 140, 166, 131, 145, 147, 15, 24, 25, 25, 25, 0, 254, 131,\n\t3, 254, 243, 176, 75, 70, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130\n]).buffer;\n\n/**\n * Options:\n * - **gl**: Callback taking `(width, height)` as parameters, and returning a GL instance. Optional on web; Requires `headless-gl` in Node.js.\n * - **resolution**: Resolution of depth buffer. Default: 512.\n * - **samples**: Number of samples to draw. Default: 500.\n */\nexport function ao (options: AOOptions = DEFAULT_OPTIONS): Transform {\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\treturn (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\t\tconst {resolution, samples} = options;\n\n\t\tlogger.debug(`${NAME}: resolution = ${resolution}; samples = ${samples}`);\n\n\t\tconst primitives = new Set<Primitive>();\n\t\tdoc.getRoot().listMeshes().forEach((mesh) => {\n\t\t\tmesh.listPrimitives().forEach((primitive) => (primitives.add(primitive)));\n\t\t});\n\n\t\tif (primitives.size === 0) {\n\t\t\tlogger.warn(`${NAME}: No primitives found.`);\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst texture = doc.createTexture('occlusion')\n\t\t.setImage(TEXTURE_DATA)\n\t\t.setMimeType(TEXTURE_MIME_TYPE);\n\n\t\tlet regl;\n\t\tif (options.gl) {\n\t\t\tconst gl = options.gl(resolution, resolution);\n\t\t\tgl.getExtension('OES_texture_float');\n\t\t\tgl.getExtension('OES_element_index_uint');\n\t\t\tregl = REGL({gl, extensions: ['OES_texture_float', 'OES_element_index_uint']});\n\t\t}\n\n\t\t// TODO: Implement baking such that primitives affect other primitives, and respect\n\t\t// world transforms.\n\t\tArray.from(primitives).forEach((primitive, index) => {\n\t\t\tlogger.debug(`${NAME}: Baking primitive ${index} / ${primitives.size}.`);\n\n\t\t\tif (primitive.getMaterial().getOcclusionTexture()) {\n\t\t\t\t// TODO: Duplicate the material if needed.\n\t\t\t\tlogger.warn(`${NAME}: Primitive already has AO. Is it sharing a material? Skipping.`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Bake vertex AO.\n\t\t\tconst position = primitive.getAttribute('POSITION').getArray();\n\t\t\tconst cells = primitive.getIndices() ? primitive.getIndices().getArray() : undefined;\n\t\t\tconst aoSampler = geoao(position, {cells, resolution, regl});\n\t\t\tfor (let i = 0; i < samples; i++) aoSampler.sample();\n\t\t\tconst ao = aoSampler.report();\n\t\t\taoSampler.dispose();\n\n\t\t\t// Write UV set and add AO map.\n\t\t\tconst numVertices = ao.length;\n\t\t\tconst uv2Data = new Float32Array(numVertices * 2);\n\t\t\tfor (let i = 0; i < numVertices; i++) {\n\t\t\t\tuv2Data[i * 2] = uv2Data[i * 2 + 1] = 1 - ao[i];\n\t\t\t}\n\n\t\t\tconst buffer = doc.getRoot().listBuffers()[0] || doc.createBuffer('');\n\t\t\tconst uv2 = doc.createAccessor('uv2', buffer)\n\t\t\t.setArray(uv2Data)\n\t\t\t.setType(GLTF.AccessorType.VEC2);\n\n\t\t\tprimitive.setAttribute('TEXCOORD_1', uv2);\n\t\t\tif (!primitive.getAttribute['TEXCOORD_0']) {\n\t\t\t\tprimitive.setAttribute('TEXCOORD_0', uv2);\n\t\t\t}\n\n\t\t\tprimitive.getMaterial().setOcclusionTexture(texture);\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n}\n","import { transformMat4 } from 'gl-matrix/vec3';\nimport { Mesh, Node, Scene, mat4, vec3 } from '@gltf-transform/core';\n\n/** Computes bounding box in world space for the given {@link Node} or {@link Scene}. */\nexport function bounds (node: Node | Scene): {min: vec3; max: vec3} {\n\tconst resultBounds = createBounds();\n\tconst parents = node instanceof Node ? [node] : node.listChildren();\n\n\tfor (const parent of parents) {\n\t\tparent.traverse((node) => {\n\t\t\tif (!node.getMesh()) return;\n\n\t\t\t// Compute mesh bounds and update result.\n\t\t\tconst meshBounds = getMeshBounds(node.getMesh(), node.getWorldMatrix());\n\t\t\texpandBounds(meshBounds.min, resultBounds);\n\t\t\texpandBounds(meshBounds.max, resultBounds);\n\t\t});\n\t}\n\n\treturn resultBounds;\n}\n\n/** Computes mesh bounds in local space. */\nfunction getMeshBounds(mesh: Mesh, worldMatrix: mat4): {min: vec3; max: vec3} {\n\tconst meshBounds = createBounds();\n\n\t// We can't transform a local AABB into world space and still have a tight AABB in world space,\n\t// so we need to compute the world AABB vertex by vertex here.\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst position = prim.getAttribute('POSITION');\n\t\tlet localPos: vec3 = [0, 0, 0];\n\t\tlet worldPos: vec3 = [0, 0, 0];\n\t\tfor (let i = 0; i < position.getCount(); i++) {\n\t\t\tlocalPos = position.getElement(i, localPos) as vec3;\n\t\t\tworldPos = transformMat4(worldPos, localPos, worldMatrix);\n\t\t\texpandBounds(worldPos, meshBounds);\n\t\t}\n\t}\n\n\treturn meshBounds;\n}\n\n/** Expands bounds of target by given source. */\nfunction expandBounds(point: vec3, target: {min: vec3; max: vec3}): void {\n\tfor (let i = 0; i < 3; i++) {\n\t\ttarget.min[i] = Math.min(point[i], target.min[i]);\n\t\ttarget.max[i] = Math.max(point[i], target.max[i]);\n\t}\n}\n\n/** Creates new bounds with min=Infinity, max=-Infinity. */\nfunction createBounds(): {min: vec3; max: vec3} {\n\treturn {\n\t\tmin: [Infinity, Infinity, Infinity] as vec3,\n\t\tmax: [-Infinity, -Infinity, -Infinity] as vec3,\n\t};\n}\n","import { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { bounds } from './bounds';\n\nconst NAME = 'center';\n\nexport interface CenterOptions {\n\tpivot?: 'center' | 'above' | 'below' | vec3;\n}\n\nconst DEFAULT_OPTIONS: CenterOptions = {pivot: 'center'};\n\n/**\n * Options:\n * - **pivot**: Location on the model to be considered the pivot, and recentered at the origin.\n */\nexport function center (options: CenterOptions = DEFAULT_OPTIONS): Transform {\n\n\treturn (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst isAnimated = root.listAnimations().length > 0 || root.listSkins().length > 0;\n\n\t\tdoc.getRoot().listScenes().forEach((scene, index) => {\n\t\t\tlogger.debug(`${NAME}: Scene ${index + 1} / ${root.listScenes().length}.`);\n\n\t\t\tlet pivot: vec3;\n\t\t\tif (typeof options.pivot === 'string') {\n\t\t\t\tconst bbox = bounds(scene);\n\t\t\t\tpivot = [\n\t\t\t\t\t(bbox.max[0] - bbox.min[0]) / 2 + bbox.min[0],\n\t\t\t\t\t(bbox.max[1] - bbox.min[1]) / 2 + bbox.min[1],\n\t\t\t\t\t(bbox.max[2] - bbox.min[2]) / 2 + bbox.min[2],\n\t\t\t\t];\n\t\t\t\tif (options.pivot === 'above') pivot[1] = bbox.max[1];\n\t\t\t\tif (options.pivot === 'below') pivot[1] = bbox.min[1];\n\t\t\t} else {\n\t\t\t\tpivot = options.pivot;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Pivot \"${pivot.join(', ')}\".`);\n\n\t\t\tconst offset: vec3 = [-1 * pivot[0], -1 * pivot[1], -1 * pivot[2]];\n\n\t\t\tif (isAnimated) {\n\t\t\t\tlogger.debug(`${NAME}: Model contains animation or skin. Adding a wrapper node.`);\n\t\t\t\tconst offsetNode = doc.createNode('Pivot').setTranslation(offset);\n\t\t\t\tscene.listChildren().forEach((child) => offsetNode.addChild(child));\n\t\t\t\tscene.addChild(offsetNode);\n\t\t\t} else {\n\t\t\t\tlogger.debug(`${NAME}: Skipping wrapper, offsetting all root nodes.`);\n\t\t\t\tscene.listChildren().forEach((child) => {\n\t\t\t\t\tconst t = child.getTranslation();\n\t\t\t\t\tchild.setTranslation([\n\t\t\t\t\t\tt[0] + offset[0],\n\t\t\t\t\t\tt[1] + offset[1],\n\t\t\t\t\t\tt[2] + offset[2],\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n}\n","import { Accessor, Document, Primitive, Transform } from '@gltf-transform/core';\n\nconst NAME = 'colorspace';\n\nexport interface ColorspaceOptions {\n    inputEncoding: string;\n}\n\n/**\n * Options:\n * - **inputEncoding**: Currently accepts only `\"sRGB\"`. Required.\n */\nexport function colorspace (options: ColorspaceOptions): Transform {\n\n\treturn (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.inputEncoding === 'linear') {\n\t\t\tlogger.info(`${NAME}: Vertex colors already linear. Skipping conversion.`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.inputEncoding !== 'sRGB') {\n\t\t\tlogger.error(\n\t\t\t\t`${NAME}: Unknown input encoding \"${options.inputEncoding}\" â€“ should be \"sRGB\" or `\n\t\t\t\t+ '\"linear\". Skipping conversion.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst converted = new Set<Accessor>();\n\n\t\t// Source: THREE.Color\n\t\tfunction sRGBToLinear( c: number ): number {\n\n\t\t\treturn ( c < 0.04045 )\n\t\t\t\t? c * 0.0773993808\n\t\t\t\t: Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t}\n\n\t\tfunction updatePrimitive(primitive: Primitive): void {\n\t\t\tconst color = [];\n\t\t\tlet attribute: Accessor;\n\t\t\tfor (let i = 0; (attribute = primitive.getAttribute(`COLOR_${i}`)); i++) {\n\t\t\t\tif (converted.has(attribute)) continue;\n\n\t\t\t\tfor (let j = 0; j < attribute.getCount(); j++) {\n\t\t\t\t\tattribute.getElement(j, color);\n\t\t\t\t\tcolor[0] = sRGBToLinear(color[0]);\n\t\t\t\t\tcolor[1] = sRGBToLinear(color[1]);\n\t\t\t\t\tcolor[2] = sRGBToLinear(color[2]);\n\t\t\t\t\tattribute.setElement(j, color);\n\t\t\t\t}\n\n\t\t\t\tconverted.add(attribute);\n\t\t\t}\n\t\t}\n\n\t\tdoc.getRoot()\n\t\t\t.listMeshes()\n\t\t\t.forEach((mesh) => mesh.listPrimitives().forEach(updatePrimitive));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t};\n\n}\n","import { Accessor, BufferUtils, Document, Logger, Material, Texture, Transform } from '@gltf-transform/core';\n\nconst NAME = 'dedup';\n\nexport interface DedupOptions {\n\taccessors?: boolean;\n\ttextures?: boolean;\n}\n\nconst DEFAULT_OPTIONS: DedupOptions = {\n\taccessors: true,\n\ttextures: true\n};\n\n/**\n * Options:\n * - **accessors**: Whether to remove duplicate accessors. Default `true`.\n * - **textures**: Whether to remove duplicate textures. Default `true`.\n */\nexport const dedup = function (options: DedupOptions = DEFAULT_OPTIONS): Transform {\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\treturn (doc: Document): void =>  {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.accessors !== false) dedupAccessors(logger, doc);\n\t\tif (options.textures !== false) dedupImages(logger, doc);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n}\n\nfunction dedupAccessors(logger: Logger, doc: Document): void {\n\t// Find all accessors used for mesh data.\n\tconst indicesAccessors: Set<Accessor> = new Set();\n\tconst attributeAccessors: Set<Accessor> = new Set();\n\n\tconst meshes = doc.getRoot().listMeshes();\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => (attributeAccessors.add(accessor)));\n\t\t\tif (primitive.getIndices()) {\n\t\t\t\tindicesAccessors.add(primitive.getIndices());\n\t\t\t}\n\t\t})\n\t});\n\n\t// Find duplicate mesh accessors.\n\tfunction detectDuplicates(accessors: Accessor[]): Map<Accessor, Accessor> {\n\t\tconst duplicateAccessors: Map<Accessor, Accessor> = new Map();\n\n\t\tfor (let i = 0; i < accessors.length; i++) {\n\t\t\tconst a = accessors[i];\n\t\t\tconst aData = a.getArray().slice().buffer;\n\n\t\t\tif (duplicateAccessors.has(a)) continue;\n\n\t\t\tfor (let j = 0; j < accessors.length; j++) {\n\t\t\t\tconst b = accessors[j];\n\n\t\t\t\tif (a === b) continue;\n\t\t\t\tif (duplicateAccessors.has(b)) continue;\n\n\t\t\t\tif (a.getType() !== b.getType()) continue;\n\t\t\t\tif (a.getComponentType() !== b.getComponentType()) continue;\n\t\t\t\tif (a.getCount() !== b.getCount()) continue;\n\t\t\t\tif (a.getNormalized() !== b.getNormalized()) continue;\n\t\t\t\tif (BufferUtils.equals(aData, b.getArray().slice().buffer)) {\n\t\t\t\t\tduplicateAccessors.set(b, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn duplicateAccessors;\n\t}\n\n\tconst duplicateIndices = detectDuplicates(Array.from(indicesAccessors));\n\tlogger.debug(`${NAME}: Found ${duplicateIndices.size} duplicates among ${indicesAccessors.size} indices.`);\n\n\tconst duplicateAttributes = detectDuplicates(Array.from(attributeAccessors));\n\tlogger.debug(`${NAME}: Found ${duplicateAttributes.size} duplicates among ${attributeAccessors.size} attributes.`);\n\n\t// Dissolve duplicates.\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => {\n\t\t\t\tif (duplicateAttributes.has(accessor)) {\n\t\t\t\t\tprimitive.swap(accessor, duplicateAttributes.get(accessor));\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices && duplicateIndices.has(indices)) {\n\t\t\t\tprimitive.swap(indices, duplicateIndices.get(indices));\n\t\t\t}\n\t\t})\n\t});\n\tArray.from(duplicateIndices.keys()).forEach((indices) => indices.dispose());\n\tArray.from(duplicateAttributes.keys()).forEach((attribute) => attribute.dispose());\n}\n\nfunction dedupImages(logger: Logger, doc: Document): void {\n\tconst root = doc.getRoot();\n\tconst textures = root.listTextures();\n\tconst duplicates: Map<Texture, Texture> = new Map();\n\n\tfor (let i = 0; i < textures.length; i++) {\n\t\tconst a = textures[i];\n\t\tconst aData = a.getImage();\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = 0; j < textures.length; j++) {\n\t\t\tconst b = textures[j];\n\t\t\tconst bData = b.getImage();\n\n\t\t\tif (a === b) continue;\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// URIs are intentionally not compared.\n\t\t\tif (a.getMimeType() !== b.getMimeType()) continue;\n\t\t\tif (a.getSize()[0] !== b.getSize()[0]) continue;\n\t\t\tif (a.getSize()[1] !== b.getSize()[1]) continue;\n\t\t\tif (BufferUtils.equals(aData, bData)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Found ${duplicates.size} duplicates among ${root.listTextures().length} textures.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\t// Skip Root.\n\t\t\tif (property instanceof Material) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n","import * as getPixelsNamespace from 'get-pixels';\nimport * as ndarray from 'ndarray';\nimport * as savePixelsNamespace from 'save-pixels';\nimport { BufferUtils, Texture } from '@gltf-transform/core';\n\nconst getPixels = getPixelsNamespace['default'] as Function;\nconst savePixels = savePixelsNamespace['default'] as Function;\n\n/** Maps pixels from source to target textures, with a per-pixel callback. */\nexport async function rewriteTexture(\n\t\tsource: Texture,\n\t\ttarget: Texture,\n\t\tfn: (pixels: ndarray, i: number, j: number) => void): Promise<Texture> {\n\n\tif (!source) return null;\n\n\tconst pixels: ndarray = await new Promise((resolve, reject) => {\n\t\t(getPixels as unknown as Function)(\n\t\t\tBuffer.from(source.getImage()),\n\t\t\tsource.getMimeType(),\n\t\t\t(err, pixels) => err ? reject(err) : resolve(pixels)\n\t\t);\n\t});\n\n\tfor(let i = 0; i < pixels.shape[0]; ++i) {\n\t\tfor(let j = 0; j < pixels.shape[1]; ++j) {\n\t\t\tfn(pixels, i, j);\n\t\t}\n\t}\n\n\tconst image: ArrayBuffer = await new Promise((resolve, reject) => {\n\t\tconst chunks: Buffer[] = [];\n\t\tsavePixels(pixels, 'png')\n\t\t\t.on('data', (d) => chunks.push(d))\n\t\t\t.on('end', () => resolve(BufferUtils.trim(Buffer.concat(chunks))))\n\t\t\t.on('error', (e) => reject(e));\n\t});\n\n\treturn target.setImage(image).setMimeType('image/png');\n}\n","import { Document, Texture } from '@gltf-transform/core';\nimport { MaterialsIOR, MaterialsPBRSpecularGlossiness, MaterialsSpecular, PBRSpecularGlossiness } from '@gltf-transform/extensions';\nimport { rewriteTexture } from './utils';\n\nconst NAME = 'metalRough';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MetalRoughOptions {}\n\n/**\n * Converts a spec/gloss PBR workflow to a metal/rough PBR workflow, relying on the IOR and\n * specular extensions to base glTF 2.0.\n */\nexport function metalRough (options: MetalRoughOptions = {}) {\n\n\treturn async (doc: Document): Promise<void> => {\n\n\t\tconst logger = doc.getLogger();\n\n\t\tconst extensionName = MaterialsPBRSpecularGlossiness.EXTENSION_NAME;\n\t\tconst extensionsUsed = doc.getRoot().listExtensionsUsed().map((ext) => ext.extensionName);\n\t\tif (!extensionsUsed.includes(extensionName)) {\n\t\t\tlogger.warn(`${NAME}: Extension ${extensionName} not found on given document.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst iorExtension = doc.createExtension(MaterialsIOR) as MaterialsIOR;\n\t\tconst specExtension = doc.createExtension(MaterialsSpecular) as MaterialsSpecular;\n\t\tconst specGlossExtension = doc.createExtension(MaterialsPBRSpecularGlossiness) as MaterialsPBRSpecularGlossiness;\n\n\t\tconst inputTextures = new Set<Texture>();\n\n\t\tfor (const material of doc.getRoot().listMaterials()) {\n\t\t\tconst specGloss = material.getExtension('KHR_materials_pbrSpecularGlossiness') as PBRSpecularGlossiness;\n\t\t\tif (!specGloss) continue;\n\n\t\t\t// Create specular extension.\n\t\t\tconst specular = specExtension.createSpecular()\n\t\t\t\t.setSpecularFactor(1.0)\n\t\t\t\t.setSpecularColorFactor(specGloss.getSpecularFactor());\n\n\t\t\t// Stash textures that might become unused, to check and clean up later.\n\t\t\tinputTextures.add(specGloss.getSpecularGlossinessTexture());\n\t\t\tinputTextures.add(material.getBaseColorTexture());\n\t\t\tinputTextures.add(material.getMetallicRoughnessTexture());\n\n\t\t\t// Set up a metal/rough PBR material with IOR=Infinity (or 0), metallic=0. This\n\t\t\t// representation is precise and reliable, but perhaps less convenient for artists\n\t\t\t// than deriving a metalness value. Unfortunately we can't do that without imprecise\n\t\t\t// heuristics, and perhaps user tuning.\n\t\t\t// See: https://github.com/KhronosGroup/glTF/pull/1719#issuecomment-674365677\n\t\t\tmaterial\n\t\t\t\t.setBaseColorFactor(specGloss.getDiffuseFactor())\n\t\t\t\t.setMetallicFactor(0)\n\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t.setExtension('KHR_materials_ior', iorExtension.createIOR().setIOR(1000))\n\t\t\t\t.setExtension('KHR_materials_specular', specular);\n\n\t\t\t// Move diffuse -> baseColor.\n\t\t\tconst diffuseTexture = specGloss.getDiffuseTexture();\n\t\t\tif (diffuseTexture) {\n\t\t\t\tmaterial.setBaseColorTexture(diffuseTexture);\n\t\t\t\tmaterial.getBaseColorTextureInfo().copy(specGloss.getDiffuseTextureInfo());\n\t\t\t}\n\n\t\t\t// Move specular + gloss -> specular + roughness.\n\t\t\tconst sgTexture = specGloss.getSpecularGlossinessTexture();\n\t\t\tif (sgTexture) {\n\t\t\t\t// specularGlossiness -> specular.\n\t\t\t\tconst sgTextureInfo = specGloss.getSpecularGlossinessTextureInfo();\n\t\t\t\tconst specularTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, specularTexture, (pixels, i, j) => {\n\t\t\t\t\tpixels.set(i, j, 3, 255); // Remove glossiness.\n\t\t\t\t});\n\t\t\t\tspecular.setSpecularTexture(specularTexture);\n\t\t\t\tspecular.getSpecularTextureInfo().copy(sgTextureInfo);\n\n\t\t\t\t// specularGlossiness -> roughness.\n\t\t\t\tconst glossinessFactor = specGloss.getGlossinessFactor();\n\t\t\t\tconst metalRoughTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, metalRoughTexture, (pixels, i, j) => {\n\t\t\t\t\t// Invert glossiness.\n\t\t\t\t\tconst roughness = 255 - Math.round(pixels.get(i, j, 3) * glossinessFactor);\n\t\t\t\t\tpixels.set(i, j, 0, 0);\n\t\t\t\t\tpixels.set(i, j, 1, roughness);\n\t\t\t\t\tpixels.set(i, j, 2, 0);\n\t\t\t\t\tpixels.set(i, j, 3, 255);\n\t\t\t\t});\n\t\t\t\tmaterial.setMetallicRoughnessTexture(metalRoughTexture);\n\t\t\t\tmaterial.getMetallicRoughnessTextureInfo().copy(sgTextureInfo);\n\t\t\t} else {\n\t\t\t\tspecular.setSpecularColorFactor(specGloss.getSpecularFactor());\n\t\t\t\tmaterial.setRoughnessFactor(1 - specGloss.getGlossinessFactor());\n\t\t\t}\n\n\t\t\t// Remove KHR_materials_pbrSpecularGlossiness from the material.\n\t\t\tmaterial.setExtension('KHR_materials_pbrSpecularGlossiness', null);\n\t\t}\n\n\t\t// Remove KHR_materials_pbrSpecularGlossiness from the document.\n\t\tspecGlossExtension.dispose();\n\n\t\t// Clean up unused textures.\n\t\tfor (const tex of inputTextures) {\n\t\t\tif (tex && tex.listParents().length === 1) tex.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t};\n\n}\n","import { Document, Logger, Transform } from '@gltf-transform/core';\n\nconst NAME = 'partition';\n\nexport interface PartitionOptions {\n\tanimations?: boolean | Array<string>;\n\tmeshes?: boolean | Array<string>;\n}\n\nconst DEFAULT_OPTIONS: PartitionOptions =  {\n\tanimations: true,\n\tmeshes: true,\n};\n\nconst partition = (options: PartitionOptions): Transform => {\n\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\treturn (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.meshes !== false) partitionMeshes(doc, logger, options);\n\t\tif (options.animations !== false) partitionAnimations(doc, logger, options);\n\n\t\tif (!options.meshes && !options.animations) {\n\t\t\tlogger.warn(`${NAME}: Select animations or meshes to create a partition.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n}\n\nfunction partitionMeshes (doc: Document, logger: Logger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(doc.getRoot().listBuffers().map((b) => b.getURI()));\n\n\tdoc.getRoot().listMeshes()\n\t\t.forEach((mesh, meshIndex) => {\n\t\t\tif (Array.isArray(options.meshes) && !options.meshes.includes(mesh.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping mesh at index ${meshIndex} with name \"${mesh.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for mesh \"${mesh.getName()}\".`);\n\n\t\t\tconst buffer = doc.createBuffer(mesh.getName())\n\t\t\t\t.setURI(createBufferURI(mesh.getName() || 'mesh', existingURIs));\n\n\t\t\tmesh.listPrimitives()\n\t\t\t\t.forEach((primitive) => {\n\t\t\t\t\tif (primitive.getIndices()) primitive.getIndices().setBuffer(buffer);\n\t\t\t\t\tprimitive.listAttributes()\n\t\t\t\t\t\t.forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t\tprimitive.listTargets()\n\t\t\t\t\t\t.forEach((primTarget) => {\n\t\t\t\t\t\t\tprimTarget.listAttributes()\n\t\t\t\t\t\t\t\t.forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t\t\t})\n\t\t\t\t});\n\t\t});\n}\n\nfunction partitionAnimations (doc: Document, logger: Logger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(doc.getRoot().listBuffers().map((b) => b.getURI()));\n\n\tdoc.getRoot().listAnimations()\n\t\t.forEach((anim, animIndex) => {\n\t\t\tif (Array.isArray(options.animations) && !options.animations.includes(anim.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping animation at index ${animIndex} with name \"${anim.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for animation \"${anim.getName()}\".`);\n\n\t\t\tconst buffer = doc.createBuffer(anim.getName())\n\t\t\t\t.setURI(createBufferURI(anim.getName() || 'animation', existingURIs));\n\n\t\t\tanim.listSamplers()\n\t\t\t\t.forEach((sampler) => {\n\t\t\t\t\tsampler.getInput().setBuffer(buffer);\n\t\t\t\t\tsampler.getOutput().setBuffer(buffer);\n\t\t\t\t});\n\t\t});\n}\n\nfunction createBufferURI (basename: string, existing: Set<string>): string {\n\tlet uri = `${basename}.bin`;\n\tlet i = 1;\n\twhile (existing.has(uri)) uri = `${basename}_${i++}.bin`;\n\treturn uri;\n}\n\nexport { partition };\n","import { Document, Transform } from '@gltf-transform/core';\n\nconst NAME = 'sequence';\n\nexport interface SequenceOptions {\n\tfps?: number;\n\tpattern: RegExp;\n\tname?: string;\n\tsort?: boolean;\n}\n\nconst DEFAULT_OPTIONS: SequenceOptions = {\n\tname: '',\n\tfps: 10,\n\tpattern: null,\n\tsort: true,\n};\n\n/**\n * Options:\n * - **name**: Name of the new animation.\n * - **fps**: Frames per second, where one node is shown each frame. Default 10.\n * - **pattern**: Pattern (regex) used to filter nodes for the sequence. Required.\n * - **sort**: Whether to sort the nodes by name, or use original order. Default true.\n */\nexport function sequence (options: SequenceOptions): Transform {\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\treturn (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst fps = options.fps;\n\n\t\t// Collect sequence nodes.\n\t\tconst sequenceNodes = root.listNodes()\n\t\t\t.filter((node) => node.getName().match(options.pattern));\n\n\t\t// Sort by node name.\n\t\tif (options.sort) {\n\t\t\tsequenceNodes.sort((a, b) => a.getName() > b.getName() ? 1 : -1);\n\t\t}\n\n\t\t// Create animation cycling visibility of each node.\n\t\tconst anim = doc.createAnimation(options.name);\n\t\tconst animBuffer = root.listBuffers()[0];\n\t\tsequenceNodes.forEach((node, i) => {\n\t\t\t// Create keyframe tracks that show each node for a single frame.\n\t\t\tlet inputArray;\n\t\t\tlet outputArray;\n\t\t\tif (i === 0) {\n\t\t\t\tinputArray = [i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [1,1,1, 0,0,0];\n\t\t\t} else if (i === sequenceNodes.length - 1) {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps];\n\t\t\t\toutputArray = [0,0,0, 1,1,1];\n\t\t\t} else {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [0,0,0, 1,1,1, 0,0,0];\n\t\t\t}\n\n\t\t\t// Append channel to animation sequence.\n\t\t\tconst input = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(inputArray))\n\t\t\t\t.setBuffer(animBuffer);\n\t\t\tconst output = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(outputArray))\n\t\t\t\t.setBuffer(animBuffer)\n\t\t\t\t.setType(GLTF.AccessorType.VEC3);\n\t\t\tconst sampler = doc.createAnimationSampler()\n\t\t\t\t.setInterpolation(GLTF.AnimationSamplerInterpolation.STEP)\n\t\t\t\t.setInput(input)\n\t\t\t\t.setOutput(output);\n\t\t\tconst channel = doc.createAnimationChannel()\n\t\t\t\t.setTargetNode(node)\n\t\t\t\t.setTargetPath(GLTF.AnimationChannelTargetPath.SCALE)\n\t\t\t\t.setSampler(sampler);\n\t\t\tanim.addSampler(sampler).addChannel(channel);\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t};\n\n}\n","import { Accessor, Document, ExtensionProperty, ImageUtils, Primitive, Texture, vec2 } from '@gltf-transform/core';\nimport { bounds } from './bounds';\n\nexport function inspect (doc: Document): Report {\n\treturn {\n\t\tscenes: listScenes(doc),\n\t\tmeshes: listMeshes(doc),\n\t\tmaterials: listMaterials(doc),\n\t\ttextures: listTextures(doc),\n\t\tanimations: listAnimations(doc),\n\t};\n}\n\n/** List scenes. */\nfunction listScenes (doc): PropertyReport<SceneReport> {\n\tconst scenes = doc.getRoot().listScenes().map((scene) => {\n\t\tconst root = scene.listChildren()[0];\n\t\tconst sceneBounds = bounds(scene);\n\t\treturn {\n\t\t\tname: scene.getName(),\n\t\t\trootName: root ? root.getName() : '',\n\t\t\tbboxMin: toPrecision(sceneBounds.min),\n\t\t\tbboxMax: toPrecision(sceneBounds.max),\n\t\t};\n\t});\n\treturn {properties: scenes};\n}\n\n/** List meshes. */\nfunction listMeshes (doc: Document): PropertyReport<MeshReport> {\n\tconst meshes: MeshReport[] = doc.getRoot().listMeshes().map((mesh) => {\n\t\tconst instances = mesh.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\t\tlet glPrimitives = 0;\n\t\tlet verts = 0;\n\t\tlet indexed = 0;\n\t\tconst componentTypes: Set<string> = new Set();\n\t\tconst semantics: Set<string> = new Set();\n\t\tconst meshAccessors: Set<Accessor> = new Set();\n\n\t\tmesh.listPrimitives().forEach((prim) => {\n\t\t\tprim.listSemantics().forEach((s) => semantics.add(s));\n\t\t\tfor (const attr of prim.listAttributes()) {\n\t\t\t\tcomponentTypes.add(attr.getArray().constructor.name);\n\t\t\t\tmeshAccessors.add(attr);\n\t\t\t}\n\t\t\tfor (const targ of prim.listTargets()) {\n\t\t\t\tfor (const attr of targ.listAttributes()) {\n\t\t\t\t\tcomponentTypes.add(attr.getArray().constructor.name);\n\t\t\t\t\tmeshAccessors.add(attr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (prim.getIndices()) {\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tcomponentTypes.add(indices.getArray().constructor.name);\n\t\t\t\tindexed++;\n\t\t\t\tmeshAccessors.add(indices);\n\t\t\t}\n\t\t\tverts += prim.getAttribute('POSITION').getCount();\n\t\t\tglPrimitives += getGLPrimitiveCount(prim);\n\t\t});\n\n\t\tlet size = 0;\n\t\tArray.from(meshAccessors).forEach((a) => (size += a.getArray().byteLength));\n\n\t\tconst modes = mesh.listPrimitives()\n\t\t\t.map((prim) => MeshPrimitiveModeLabels[prim.getMode()])\n\n\t\treturn {\n\t\t\tname: mesh.getName(),\n\t\t\tmode: Array.from(new Set(modes)),\n\t\t\tprimitives: mesh.listPrimitives().length,\n\t\t\tglPrimitives: glPrimitives,\n\t\t\tvertices: verts,\n\t\t\tindexed: mesh.listPrimitives().length === indexed,\n\t\t\tcomponents: Array.from(componentTypes).sort().map((s) => s.replace('Array', '')),\n\t\t\tattributes: Array.from(semantics).sort(),\n\t\t\tinstances: instances,\n\t\t\tsize: size,\n\t\t};\n\t});\n\n\treturn {properties: meshes};\n}\n\n/** List materials. */\nfunction listMaterials (doc: Document): PropertyReport<MaterialReport> {\n\tconst materials: MaterialReport[] = doc.getRoot().listMaterials().map((material) => {\n\t\tconst instances = material.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\n\t\t// Find all texture slots attached to this material or its extensions.\n\t\tconst extensions = new Set<ExtensionProperty>(material.listExtensions());\n\t\tconst slots = doc.getGraph().getLinks()\n\t\t\t.filter((link) => {\n\t\t\t\tconst child = link.getChild();\n\t\t\t\tconst parent = link.getParent();\n\t\t\t\tif (child instanceof Texture && parent === material) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (child instanceof Texture\n\t\t\t\t\t\t&& parent instanceof ExtensionProperty\n\t\t\t\t\t\t&& extensions.has(parent)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t})\n\t\t\t.map((link) => link.getName());\n\n\t\treturn {\n\t\t\tname: material.getName(),\n\t\t\tinstances,\n\t\t\ttextures: slots,\n\t\t\talphaMode: material.getAlphaMode(),\n\t\t\tdoubleSided: material.getDoubleSided(),\n\t\t};\n\t});\n\n\treturn {properties: materials};\n}\n\n/** List textures. */\nfunction listTextures (doc: Document): PropertyReport<TextureReport> {\n\tconst textures: TextureReport[] = doc.getRoot().listTextures().map((texture) => {\n\t\tconst instances = texture.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\n\t\tconst slots = doc.getGraph().getLinks()\n\t\t\t.filter((link) => link.getChild() === texture)\n\t\t\t.map((link) => link.getName())\n\t\t\t.filter((name) => name !== 'texture');\n\n\t\tlet resolution: vec2;\n\t\tlet channels: number;\n\t\tif (texture.getMimeType() === 'image/png') {\n\t\t\tresolution = ImageUtils.getSizePNG(texture.getImage());\n\t\t\tchannels = 4;\n\t\t} else if (texture.getMimeType() === 'image/jpeg') {\n\t\t\tresolution = ImageUtils.getSizeJPEG(texture.getImage());\n\t\t\tchannels = 3;\n\t\t}\n\n\t\treturn {\n\t\t\tname: texture.getName(),\n\t\t\turi: texture.getURI(),\n\t\t\tslots: Array.from(new Set(slots)),\n\t\t\tinstances,\n\t\t\tmimeType: texture.getMimeType(),\n\t\t\tresolution: resolution ? resolution.join('x') : '',\n\t\t\tsize: texture.getImage().byteLength,\n\t\t\tmemSize: resolution ? resolution[0] * resolution[1] * channels : null,\n\t\t};\n\t});\n\n\treturn {properties: textures};\n}\n\n/** List animations. */\nfunction listAnimations (doc: Document): PropertyReport<AnimationReport> {\n\tconst animations: AnimationReport[] = doc.getRoot().listAnimations().map((anim) => {\n\t\tlet minTime = Infinity;\n\t\tlet maxTime = -Infinity;\n\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\tminTime = Math.min(minTime, sampler.getInput().getMin([])[0]);\n\t\t\tmaxTime = Math.max(maxTime, sampler.getInput().getMax([])[0]);\n\t\t});\n\n\t\tlet size = 0;\n\t\tconst accessors: Set<Accessor> = new Set();\n\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\taccessors.add(sampler.getInput());\n\t\t\taccessors.add(sampler.getOutput());\n\t\t});\n\t\tArray.from(accessors).forEach((accessor) => {\n\t\t\tsize += accessor.getArray().byteLength;\n\t\t});\n\n\t\treturn {\n\t\t\tname: anim.getName(),\n\t\t\tchannels: anim.listChannels().length,\n\t\t\tsamplers: anim.listSamplers().length,\n\t\t\tduration: Math.round((maxTime - minTime) * 1000) / 1000,\n\t\t\tsize: size,\n\t\t};\n\t});\n\n\treturn {properties: animations}\n}\n\ninterface Report {\n\tscenes: PropertyReport<SceneReport>;\n\tmeshes: PropertyReport<MeshReport>;\n\tmaterials: PropertyReport<MaterialReport>;\n\ttextures: PropertyReport<TextureReport>;\n\tanimations: PropertyReport<AnimationReport>;\n}\n\ninterface PropertyReport<T> {\n\tproperties: T[];\n\terrors?: string[];\n\twarnings?: string[];\n}\n\ninterface SceneReport {\n\tname: string;\n\trootName: string;\n\tbboxMin: number[];\n\tbboxMax: number[];\n}\n\ninterface MeshReport {\n\tname: string;\n\tprimitives: number;\n\tindexed: boolean;\n\tmode: string[];\n\tvertices: number;\n\tglPrimitives: number;\n\tcomponents: string[];\n\tattributes: string[];\n\tinstances: number;\n\tsize: number;\n}\n\ninterface MaterialReport {\n\tname: string;\n\tinstances: number;\n\ttextures: string[];\n\talphaMode: GLTF.MaterialAlphaMode;\n\tdoubleSided: boolean;\n}\n\ninterface TextureReport {\n\tname: string;\n\turi: string;\n\tslots: string[];\n\tinstances: number;\n\tmimeType: string;\n\tresolution: string;\n\tsize: number;\n\tmemSize: number;\n}\n\ninterface AnimationReport {\n\tname: string;\n\tchannels: number;\n\tsamplers: number;\n\tduration: number;\n\tsize: number;\n}\n\nconst MeshPrimitiveModeLabels = [\n\t'POINTS',\n\t'LINES',\n\t'LINE_LOOP',\n\t'LINE_STRIP',\n\t'TRIANGLES',\n\t'TRIANGLE_STRIP',\n\t'TRIANGLE_FAN',\n];\n\nfunction getGLPrimitiveCount(prim: Primitive): number {\n\t// Reference: https://www.khronos.org/opengl/wiki/Primitive\n\tswitch (prim.getMode()) {\n\t\tcase GLTF.MeshPrimitiveMode.POINTS:\n\t\t\treturn prim.getAttribute('POSITION').getCount();\n\t\tcase GLTF.MeshPrimitiveMode.LINES:\n\t\t\treturn prim.getIndices()\n\t\t\t\t? prim.getIndices().getCount() / 2\n\t\t\t\t: prim.getAttribute('POSITION').getCount() / 2;\n\t\tcase GLTF.MeshPrimitiveMode.LINE_LOOP:\n\t\t\treturn prim.getAttribute('POSITION').getCount();\n\t\tcase GLTF.MeshPrimitiveMode.LINE_STRIP:\n\t\t\treturn prim.getAttribute('POSITION').getCount() - 1;\n\t\tcase GLTF.MeshPrimitiveMode.TRIANGLES:\n\t\t\treturn prim.getIndices()\n\t\t\t\t? prim.getIndices().getCount() / 3\n\t\t\t\t: prim.getAttribute('POSITION').getCount() / 3;\n\t\tcase GLTF.MeshPrimitiveMode.TRIANGLE_STRIP:\n\t\tcase GLTF.MeshPrimitiveMode.TRIANGLE_FAN:\n\t\t\treturn prim.getAttribute('POSITION').getCount() - 2;\n\t\tdefault:\n\t\t\tthrow new Error('Unexpected mode: ' + prim.getMode());\n\t}\n}\n\n/** Maps values in a vector to a finite precision. */\nfunction toPrecision(v: number[]): number[] {\n\tfor (let i = 0; i < v.length; i++) {\n\t\tif (v[i].toFixed) v[i] = Number(v[i].toFixed(5));\n\t}\n\treturn v;\n}\n"],"names":["geoao","geoaoNamespace","REGL","reglNamespace","DEFAULT_OPTIONS","resolution","samples","TEXTURE_DATA","Uint8Array","buffer","ao","options","doc","logger","getLogger","debug","primitives","Set","getRoot","listMeshes","forEach","mesh","listPrimitives","primitive","add","size","warn","texture","createTexture","setImage","setMimeType","regl","gl","getExtension","extensions","Array","from","index","getMaterial","getOcclusionTexture","position","getAttribute","getArray","cells","getIndices","undefined","aoSampler","i","sample","report","dispose","numVertices","length","uv2Data","Float32Array","listBuffers","createBuffer","uv2","createAccessor","setArray","setType","setAttribute","setOcclusionTexture","bounds","node","resultBounds","min","Infinity","max","parents","Node","listChildren","parent","traverse","getMesh","meshBounds","getMeshBounds","getWorldMatrix","expandBounds","worldMatrix","prim","localPos","worldPos","getCount","getElement","transformMat4","point","target","Math","pivot","center","root","isAnimated","listAnimations","listSkins","listScenes","scene","bbox","join","offset","offsetNode","createNode","setTranslation","child","addChild","t","getTranslation","colorspace","inputEncoding","info","error","converted","sRGBToLinear","c","pow","updatePrimitive","color","attribute","has","j","setElement","accessors","textures","dedup","indicesAccessors","attributeAccessors","meshes","detectDuplicates","duplicateAccessors","Map","a","aData","slice","b","getType","getComponentType","getNormalized","BufferUtils","equals","set","listAttributes","accessor","duplicateIndices","duplicateAttributes","swap","get","indices","keys","dedupAccessors","listTextures","duplicates","getImage","bData","getMimeType","getSize","entries","src","dst","listParents","property","Material","dedupImages","getPixels","getPixelsNamespace","savePixels","savePixelsNamespace","rewriteTexture","source","fn","pixels","Promise","resolve","reject","Buffer","err","shape","image","chunks","on","d","push","trim","concat","e","metalRough","extensionName","MaterialsPBRSpecularGlossiness","EXTENSION_NAME","listExtensionsUsed","map","ext","includes","iorExtension","createExtension","MaterialsIOR","specExtension","MaterialsSpecular","specGlossExtension","inputTextures","material","listMaterials","specGloss","specular","createSpecular","setSpecularFactor","setSpecularColorFactor","getSpecularFactor","getSpecularGlossinessTexture","getBaseColorTexture","getMetallicRoughnessTexture","setBaseColorFactor","getDiffuseFactor","setMetallicFactor","setRoughnessFactor","setExtension","createIOR","setIOR","diffuseTexture","getDiffuseTexture","setBaseColorTexture","getBaseColorTextureInfo","copy","getDiffuseTextureInfo","sgTexture","sgTextureInfo","getSpecularGlossinessTextureInfo","specularTexture","setSpecularTexture","getSpecularTextureInfo","glossinessFactor","getGlossinessFactor","metalRoughTexture","roughness","round","setMetallicRoughnessTexture","getMetallicRoughnessTextureInfo","tex","animations","partition","existingURIs","getURI","meshIndex","isArray","getName","setURI","createBufferURI","setBuffer","listTargets","primTarget","partitionMeshes","anim","animIndex","listSamplers","sampler","getInput","getOutput","partitionAnimations","basename","existing","uri","name","fps","pattern","sort","sequence","sequenceNodes","listNodes","filter","match","createAnimation","animBuffer","inputArray","outputArray","input","output","createAnimationSampler","setInterpolation","setInput","setOutput","channel","createAnimationChannel","setTargetNode","setTargetPath","setSampler","addSampler","addChannel","inspect","scenes","materials","properties","sceneBounds","rootName","bboxMin","toPrecision","bboxMax","instances","propertyType","glPrimitives","verts","indexed","componentTypes","semantics","meshAccessors","listSemantics","s","attr","constructor","targ","getMode","Error","getGLPrimitiveCount","byteLength","modes","MeshPrimitiveModeLabels","mode","vertices","components","replace","attributes","listExtensions","slots","getGraph","getLinks","link","getChild","getParent","Texture","ExtensionProperty","alphaMode","getAlphaMode","doubleSided","getDoubleSided","channels","ImageUtils","getSizePNG","getSizeJPEG","mimeType","memSize","minTime","maxTime","getMin","getMax","listChannels","samplers","duration","v","toFixed","Number"],"mappings":"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"}