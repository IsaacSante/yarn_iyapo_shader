{"version":3,"file":"lib.js","sources":["../src/ao.ts","../src/bounds.ts","../src/center.ts","../src/dedup.ts","../src/utils.ts","../src/metal-rough.ts","../src/partition.ts","../src/sequence.ts","../src/inspect.ts","../src/colorspace.ts"],"sourcesContent":["import * as geoaoNamespace from 'geo-ambient-occlusion';\nimport * as reglNamespace from 'regl';\nimport { Document, Primitive, Transform } from '@gltf-transform/core';\n\nconst NAME = 'ao';\nconst geoao = geoaoNamespace['default'] as Function;\nconst REGL = reglNamespace['default'] as Function;\n\ninterface GLFactory {\n\t(w: number, h: number): WebGLRenderingContext;\n}\n\nexport interface AOOptions {\n\tgl?: GLFactory;\n\tresolution?: number;\n\tsamples?: number;\n}\n\nconst DEFAULT_OPTIONS: AOOptions = {\n\tresolution: 512,\n\tsamples: 500,\n};\n\n// A greyscale 256x1 gradient.\nconst TEXTURE_MIME_TYPE = 'image/png';\nconst TEXTURE_DATA = new Uint8Array([\n\t137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 1, 0, 0, 0, 0, 1, 8, 6, 0,\n\t0, 0, 49, 89, 112, 119, 0, 0, 0, 32, 73, 68, 65, 84, 56, 79, 99, 100, 96, 96, 248, 207, 196,\n\t196, 196, 0, 2, 163, 244, 104, 56, 140, 166, 131, 145, 147, 15, 24, 25, 25, 25, 0, 254, 131,\n\t3, 254, 243, 176, 75, 70, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130\n]).buffer;\n\n/**\n * Options:\n * - **gl**: Callback taking `(width, height)` as parameters, and returning a GL instance. Optional on web; Requires `headless-gl` in Node.js.\n * - **resolution**: Resolution of depth buffer. Default: 512.\n * - **samples**: Number of samples to draw. Default: 500.\n */\nexport function ao (options: AOOptions = DEFAULT_OPTIONS): Transform {\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\treturn (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\t\tconst {resolution, samples} = options;\n\n\t\tlogger.debug(`${NAME}: resolution = ${resolution}; samples = ${samples}`);\n\n\t\tconst primitives = new Set<Primitive>();\n\t\tdoc.getRoot().listMeshes().forEach((mesh) => {\n\t\t\tmesh.listPrimitives().forEach((primitive) => (primitives.add(primitive)));\n\t\t});\n\n\t\tif (primitives.size === 0) {\n\t\t\tlogger.warn(`${NAME}: No primitives found.`);\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst texture = doc.createTexture('occlusion')\n\t\t.setImage(TEXTURE_DATA)\n\t\t.setMimeType(TEXTURE_MIME_TYPE);\n\n\t\tlet regl;\n\t\tif (options.gl) {\n\t\t\tconst gl = options.gl(resolution, resolution);\n\t\t\tgl.getExtension('OES_texture_float');\n\t\t\tgl.getExtension('OES_element_index_uint');\n\t\t\tregl = REGL({gl, extensions: ['OES_texture_float', 'OES_element_index_uint']});\n\t\t}\n\n\t\t// TODO: Implement baking such that primitives affect other primitives, and respect\n\t\t// world transforms.\n\t\tArray.from(primitives).forEach((primitive, index) => {\n\t\t\tlogger.debug(`${NAME}: Baking primitive ${index} / ${primitives.size}.`);\n\n\t\t\tif (primitive.getMaterial().getOcclusionTexture()) {\n\t\t\t\t// TODO: Duplicate the material if needed.\n\t\t\t\tlogger.warn(`${NAME}: Primitive already has AO. Is it sharing a material? Skipping.`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Bake vertex AO.\n\t\t\tconst position = primitive.getAttribute('POSITION').getArray();\n\t\t\tconst cells = primitive.getIndices() ? primitive.getIndices().getArray() : undefined;\n\t\t\tconst aoSampler = geoao(position, {cells, resolution, regl});\n\t\t\tfor (let i = 0; i < samples; i++) aoSampler.sample();\n\t\t\tconst ao = aoSampler.report();\n\t\t\taoSampler.dispose();\n\n\t\t\t// Write UV set and add AO map.\n\t\t\tconst numVertices = ao.length;\n\t\t\tconst uv2Data = new Float32Array(numVertices * 2);\n\t\t\tfor (let i = 0; i < numVertices; i++) {\n\t\t\t\tuv2Data[i * 2] = uv2Data[i * 2 + 1] = 1 - ao[i];\n\t\t\t}\n\n\t\t\tconst buffer = doc.getRoot().listBuffers()[0] || doc.createBuffer('');\n\t\t\tconst uv2 = doc.createAccessor('uv2', buffer)\n\t\t\t.setArray(uv2Data)\n\t\t\t.setType(GLTF.AccessorType.VEC2);\n\n\t\t\tprimitive.setAttribute('TEXCOORD_1', uv2);\n\t\t\tif (!primitive.getAttribute['TEXCOORD_0']) {\n\t\t\t\tprimitive.setAttribute('TEXCOORD_0', uv2);\n\t\t\t}\n\n\t\t\tprimitive.getMaterial().setOcclusionTexture(texture);\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n}\n","import { transformMat4 } from 'gl-matrix/vec3';\nimport { Mesh, Node, Scene, mat4, vec3 } from '@gltf-transform/core';\n\n/** Computes bounding box in world space for the given {@link Node} or {@link Scene}. */\nexport function bounds (node: Node | Scene): {min: vec3; max: vec3} {\n\tconst resultBounds = createBounds();\n\tconst parents = node instanceof Node ? [node] : node.listChildren();\n\n\tfor (const parent of parents) {\n\t\tparent.traverse((node) => {\n\t\t\tif (!node.getMesh()) return;\n\n\t\t\t// Compute mesh bounds and update result.\n\t\t\tconst meshBounds = getMeshBounds(node.getMesh(), node.getWorldMatrix());\n\t\t\texpandBounds(meshBounds.min, resultBounds);\n\t\t\texpandBounds(meshBounds.max, resultBounds);\n\t\t});\n\t}\n\n\treturn resultBounds;\n}\n\n/** Computes mesh bounds in local space. */\nfunction getMeshBounds(mesh: Mesh, worldMatrix: mat4): {min: vec3; max: vec3} {\n\tconst meshBounds = createBounds();\n\n\t// We can't transform a local AABB into world space and still have a tight AABB in world space,\n\t// so we need to compute the world AABB vertex by vertex here.\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst position = prim.getAttribute('POSITION');\n\t\tlet localPos: vec3 = [0, 0, 0];\n\t\tlet worldPos: vec3 = [0, 0, 0];\n\t\tfor (let i = 0; i < position.getCount(); i++) {\n\t\t\tlocalPos = position.getElement(i, localPos) as vec3;\n\t\t\tworldPos = transformMat4(worldPos, localPos, worldMatrix);\n\t\t\texpandBounds(worldPos, meshBounds);\n\t\t}\n\t}\n\n\treturn meshBounds;\n}\n\n/** Expands bounds of target by given source. */\nfunction expandBounds(point: vec3, target: {min: vec3; max: vec3}): void {\n\tfor (let i = 0; i < 3; i++) {\n\t\ttarget.min[i] = Math.min(point[i], target.min[i]);\n\t\ttarget.max[i] = Math.max(point[i], target.max[i]);\n\t}\n}\n\n/** Creates new bounds with min=Infinity, max=-Infinity. */\nfunction createBounds(): {min: vec3; max: vec3} {\n\treturn {\n\t\tmin: [Infinity, Infinity, Infinity] as vec3,\n\t\tmax: [-Infinity, -Infinity, -Infinity] as vec3,\n\t};\n}\n","import { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { bounds } from './bounds';\n\nconst NAME = 'center';\n\nexport interface CenterOptions {\n\tpivot?: 'center' | 'above' | 'below' | vec3;\n}\n\nconst DEFAULT_OPTIONS: CenterOptions = {pivot: 'center'};\n\n/**\n * Options:\n * - **pivot**: Location on the model to be considered the pivot, and recentered at the origin.\n */\nexport function center (options: CenterOptions = DEFAULT_OPTIONS): Transform {\n\n\treturn (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst isAnimated = root.listAnimations().length > 0 || root.listSkins().length > 0;\n\n\t\tdoc.getRoot().listScenes().forEach((scene, index) => {\n\t\t\tlogger.debug(`${NAME}: Scene ${index + 1} / ${root.listScenes().length}.`);\n\n\t\t\tlet pivot: vec3;\n\t\t\tif (typeof options.pivot === 'string') {\n\t\t\t\tconst bbox = bounds(scene);\n\t\t\t\tpivot = [\n\t\t\t\t\t(bbox.max[0] - bbox.min[0]) / 2 + bbox.min[0],\n\t\t\t\t\t(bbox.max[1] - bbox.min[1]) / 2 + bbox.min[1],\n\t\t\t\t\t(bbox.max[2] - bbox.min[2]) / 2 + bbox.min[2],\n\t\t\t\t];\n\t\t\t\tif (options.pivot === 'above') pivot[1] = bbox.max[1];\n\t\t\t\tif (options.pivot === 'below') pivot[1] = bbox.min[1];\n\t\t\t} else {\n\t\t\t\tpivot = options.pivot;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Pivot \"${pivot.join(', ')}\".`);\n\n\t\t\tconst offset: vec3 = [-1 * pivot[0], -1 * pivot[1], -1 * pivot[2]];\n\n\t\t\tif (isAnimated) {\n\t\t\t\tlogger.debug(`${NAME}: Model contains animation or skin. Adding a wrapper node.`);\n\t\t\t\tconst offsetNode = doc.createNode('Pivot').setTranslation(offset);\n\t\t\t\tscene.listChildren().forEach((child) => offsetNode.addChild(child));\n\t\t\t\tscene.addChild(offsetNode);\n\t\t\t} else {\n\t\t\t\tlogger.debug(`${NAME}: Skipping wrapper, offsetting all root nodes.`);\n\t\t\t\tscene.listChildren().forEach((child) => {\n\t\t\t\t\tconst t = child.getTranslation();\n\t\t\t\t\tchild.setTranslation([\n\t\t\t\t\t\tt[0] + offset[0],\n\t\t\t\t\t\tt[1] + offset[1],\n\t\t\t\t\t\tt[2] + offset[2],\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n}\n","import { Accessor, BufferUtils, Document, Logger, Material, Texture, Transform } from '@gltf-transform/core';\n\nconst NAME = 'dedup';\n\nexport interface DedupOptions {\n\taccessors?: boolean;\n\ttextures?: boolean;\n}\n\nconst DEFAULT_OPTIONS: DedupOptions = {\n\taccessors: true,\n\ttextures: true\n};\n\n/**\n * Options:\n * - **accessors**: Whether to remove duplicate accessors. Default `true`.\n * - **textures**: Whether to remove duplicate textures. Default `true`.\n */\nexport const dedup = function (options: DedupOptions = DEFAULT_OPTIONS): Transform {\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\treturn (doc: Document): void =>  {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.accessors !== false) dedupAccessors(logger, doc);\n\t\tif (options.textures !== false) dedupImages(logger, doc);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n}\n\nfunction dedupAccessors(logger: Logger, doc: Document): void {\n\t// Find all accessors used for mesh data.\n\tconst indicesAccessors: Set<Accessor> = new Set();\n\tconst attributeAccessors: Set<Accessor> = new Set();\n\n\tconst meshes = doc.getRoot().listMeshes();\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => (attributeAccessors.add(accessor)));\n\t\t\tif (primitive.getIndices()) {\n\t\t\t\tindicesAccessors.add(primitive.getIndices());\n\t\t\t}\n\t\t})\n\t});\n\n\t// Find duplicate mesh accessors.\n\tfunction detectDuplicates(accessors: Accessor[]): Map<Accessor, Accessor> {\n\t\tconst duplicateAccessors: Map<Accessor, Accessor> = new Map();\n\n\t\tfor (let i = 0; i < accessors.length; i++) {\n\t\t\tconst a = accessors[i];\n\t\t\tconst aData = a.getArray().slice().buffer;\n\n\t\t\tif (duplicateAccessors.has(a)) continue;\n\n\t\t\tfor (let j = 0; j < accessors.length; j++) {\n\t\t\t\tconst b = accessors[j];\n\n\t\t\t\tif (a === b) continue;\n\t\t\t\tif (duplicateAccessors.has(b)) continue;\n\n\t\t\t\tif (a.getType() !== b.getType()) continue;\n\t\t\t\tif (a.getComponentType() !== b.getComponentType()) continue;\n\t\t\t\tif (a.getCount() !== b.getCount()) continue;\n\t\t\t\tif (a.getNormalized() !== b.getNormalized()) continue;\n\t\t\t\tif (BufferUtils.equals(aData, b.getArray().slice().buffer)) {\n\t\t\t\t\tduplicateAccessors.set(b, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn duplicateAccessors;\n\t}\n\n\tconst duplicateIndices = detectDuplicates(Array.from(indicesAccessors));\n\tlogger.debug(`${NAME}: Found ${duplicateIndices.size} duplicates among ${indicesAccessors.size} indices.`);\n\n\tconst duplicateAttributes = detectDuplicates(Array.from(attributeAccessors));\n\tlogger.debug(`${NAME}: Found ${duplicateAttributes.size} duplicates among ${attributeAccessors.size} attributes.`);\n\n\t// Dissolve duplicates.\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => {\n\t\t\t\tif (duplicateAttributes.has(accessor)) {\n\t\t\t\t\tprimitive.swap(accessor, duplicateAttributes.get(accessor));\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices && duplicateIndices.has(indices)) {\n\t\t\t\tprimitive.swap(indices, duplicateIndices.get(indices));\n\t\t\t}\n\t\t})\n\t});\n\tArray.from(duplicateIndices.keys()).forEach((indices) => indices.dispose());\n\tArray.from(duplicateAttributes.keys()).forEach((attribute) => attribute.dispose());\n}\n\nfunction dedupImages(logger: Logger, doc: Document): void {\n\tconst root = doc.getRoot();\n\tconst textures = root.listTextures();\n\tconst duplicates: Map<Texture, Texture> = new Map();\n\n\tfor (let i = 0; i < textures.length; i++) {\n\t\tconst a = textures[i];\n\t\tconst aData = a.getImage();\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = 0; j < textures.length; j++) {\n\t\t\tconst b = textures[j];\n\t\t\tconst bData = b.getImage();\n\n\t\t\tif (a === b) continue;\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// URIs are intentionally not compared.\n\t\t\tif (a.getMimeType() !== b.getMimeType()) continue;\n\t\t\tif (a.getSize()[0] !== b.getSize()[0]) continue;\n\t\t\tif (a.getSize()[1] !== b.getSize()[1]) continue;\n\t\t\tif (BufferUtils.equals(aData, bData)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Found ${duplicates.size} duplicates among ${root.listTextures().length} textures.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\t// Skip Root.\n\t\t\tif (property instanceof Material) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n","import * as getPixelsNamespace from 'get-pixels';\nimport * as ndarray from 'ndarray';\nimport * as savePixelsNamespace from 'save-pixels';\nimport { BufferUtils, Texture } from '@gltf-transform/core';\n\nconst getPixels = getPixelsNamespace['default'] as Function;\nconst savePixels = savePixelsNamespace['default'] as Function;\n\n/** Maps pixels from source to target textures, with a per-pixel callback. */\nexport async function rewriteTexture(\n\t\tsource: Texture,\n\t\ttarget: Texture,\n\t\tfn: (pixels: ndarray, i: number, j: number) => void): Promise<Texture> {\n\n\tif (!source) return null;\n\n\tconst pixels: ndarray = await new Promise((resolve, reject) => {\n\t\t(getPixels as unknown as Function)(\n\t\t\tBuffer.from(source.getImage()),\n\t\t\tsource.getMimeType(),\n\t\t\t(err, pixels) => err ? reject(err) : resolve(pixels)\n\t\t);\n\t});\n\n\tfor(let i = 0; i < pixels.shape[0]; ++i) {\n\t\tfor(let j = 0; j < pixels.shape[1]; ++j) {\n\t\t\tfn(pixels, i, j);\n\t\t}\n\t}\n\n\tconst image: ArrayBuffer = await new Promise((resolve, reject) => {\n\t\tconst chunks: Buffer[] = [];\n\t\tsavePixels(pixels, 'png')\n\t\t\t.on('data', (d) => chunks.push(d))\n\t\t\t.on('end', () => resolve(BufferUtils.trim(Buffer.concat(chunks))))\n\t\t\t.on('error', (e) => reject(e));\n\t});\n\n\treturn target.setImage(image).setMimeType('image/png');\n}\n","import { Document, Texture } from '@gltf-transform/core';\nimport { MaterialsIOR, MaterialsPBRSpecularGlossiness, MaterialsSpecular, PBRSpecularGlossiness } from '@gltf-transform/extensions';\nimport { rewriteTexture } from './utils';\n\nconst NAME = 'metalRough';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MetalRoughOptions {}\n\n/**\n * Converts a spec/gloss PBR workflow to a metal/rough PBR workflow, relying on the IOR and\n * specular extensions to base glTF 2.0.\n */\nexport function metalRough (options: MetalRoughOptions = {}) {\n\n\treturn async (doc: Document): Promise<void> => {\n\n\t\tconst logger = doc.getLogger();\n\n\t\tconst extensionName = MaterialsPBRSpecularGlossiness.EXTENSION_NAME;\n\t\tconst extensionsUsed = doc.getRoot().listExtensionsUsed().map((ext) => ext.extensionName);\n\t\tif (!extensionsUsed.includes(extensionName)) {\n\t\t\tlogger.warn(`${NAME}: Extension ${extensionName} not found on given document.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst iorExtension = doc.createExtension(MaterialsIOR) as MaterialsIOR;\n\t\tconst specExtension = doc.createExtension(MaterialsSpecular) as MaterialsSpecular;\n\t\tconst specGlossExtension = doc.createExtension(MaterialsPBRSpecularGlossiness) as MaterialsPBRSpecularGlossiness;\n\n\t\tconst inputTextures = new Set<Texture>();\n\n\t\tfor (const material of doc.getRoot().listMaterials()) {\n\t\t\tconst specGloss = material.getExtension('KHR_materials_pbrSpecularGlossiness') as PBRSpecularGlossiness;\n\t\t\tif (!specGloss) continue;\n\n\t\t\t// Create specular extension.\n\t\t\tconst specular = specExtension.createSpecular()\n\t\t\t\t.setSpecularFactor(1.0)\n\t\t\t\t.setSpecularColorFactor(specGloss.getSpecularFactor());\n\n\t\t\t// Stash textures that might become unused, to check and clean up later.\n\t\t\tinputTextures.add(specGloss.getSpecularGlossinessTexture());\n\t\t\tinputTextures.add(material.getBaseColorTexture());\n\t\t\tinputTextures.add(material.getMetallicRoughnessTexture());\n\n\t\t\t// Set up a metal/rough PBR material with IOR=Infinity (or 0), metallic=0. This\n\t\t\t// representation is precise and reliable, but perhaps less convenient for artists\n\t\t\t// than deriving a metalness value. Unfortunately we can't do that without imprecise\n\t\t\t// heuristics, and perhaps user tuning.\n\t\t\t// See: https://github.com/KhronosGroup/glTF/pull/1719#issuecomment-674365677\n\t\t\tmaterial\n\t\t\t\t.setBaseColorFactor(specGloss.getDiffuseFactor())\n\t\t\t\t.setMetallicFactor(0)\n\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t.setExtension('KHR_materials_ior', iorExtension.createIOR().setIOR(1000))\n\t\t\t\t.setExtension('KHR_materials_specular', specular);\n\n\t\t\t// Move diffuse -> baseColor.\n\t\t\tconst diffuseTexture = specGloss.getDiffuseTexture();\n\t\t\tif (diffuseTexture) {\n\t\t\t\tmaterial.setBaseColorTexture(diffuseTexture);\n\t\t\t\tmaterial.getBaseColorTextureInfo().copy(specGloss.getDiffuseTextureInfo());\n\t\t\t}\n\n\t\t\t// Move specular + gloss -> specular + roughness.\n\t\t\tconst sgTexture = specGloss.getSpecularGlossinessTexture();\n\t\t\tif (sgTexture) {\n\t\t\t\t// specularGlossiness -> specular.\n\t\t\t\tconst sgTextureInfo = specGloss.getSpecularGlossinessTextureInfo();\n\t\t\t\tconst specularTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, specularTexture, (pixels, i, j) => {\n\t\t\t\t\tpixels.set(i, j, 3, 255); // Remove glossiness.\n\t\t\t\t});\n\t\t\t\tspecular.setSpecularTexture(specularTexture);\n\t\t\t\tspecular.getSpecularTextureInfo().copy(sgTextureInfo);\n\n\t\t\t\t// specularGlossiness -> roughness.\n\t\t\t\tconst glossinessFactor = specGloss.getGlossinessFactor();\n\t\t\t\tconst metalRoughTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, metalRoughTexture, (pixels, i, j) => {\n\t\t\t\t\t// Invert glossiness.\n\t\t\t\t\tconst roughness = 255 - Math.round(pixels.get(i, j, 3) * glossinessFactor);\n\t\t\t\t\tpixels.set(i, j, 0, 0);\n\t\t\t\t\tpixels.set(i, j, 1, roughness);\n\t\t\t\t\tpixels.set(i, j, 2, 0);\n\t\t\t\t\tpixels.set(i, j, 3, 255);\n\t\t\t\t});\n\t\t\t\tmaterial.setMetallicRoughnessTexture(metalRoughTexture);\n\t\t\t\tmaterial.getMetallicRoughnessTextureInfo().copy(sgTextureInfo);\n\t\t\t} else {\n\t\t\t\tspecular.setSpecularColorFactor(specGloss.getSpecularFactor());\n\t\t\t\tmaterial.setRoughnessFactor(1 - specGloss.getGlossinessFactor());\n\t\t\t}\n\n\t\t\t// Remove KHR_materials_pbrSpecularGlossiness from the material.\n\t\t\tmaterial.setExtension('KHR_materials_pbrSpecularGlossiness', null);\n\t\t}\n\n\t\t// Remove KHR_materials_pbrSpecularGlossiness from the document.\n\t\tspecGlossExtension.dispose();\n\n\t\t// Clean up unused textures.\n\t\tfor (const tex of inputTextures) {\n\t\t\tif (tex && tex.listParents().length === 1) tex.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t};\n\n}\n","import { Document, Logger, Transform } from '@gltf-transform/core';\n\nconst NAME = 'partition';\n\nexport interface PartitionOptions {\n\tanimations?: boolean | Array<string>;\n\tmeshes?: boolean | Array<string>;\n}\n\nconst DEFAULT_OPTIONS: PartitionOptions =  {\n\tanimations: true,\n\tmeshes: true,\n};\n\nconst partition = (options: PartitionOptions): Transform => {\n\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\treturn (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.meshes !== false) partitionMeshes(doc, logger, options);\n\t\tif (options.animations !== false) partitionAnimations(doc, logger, options);\n\n\t\tif (!options.meshes && !options.animations) {\n\t\t\tlogger.warn(`${NAME}: Select animations or meshes to create a partition.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t};\n\n}\n\nfunction partitionMeshes (doc: Document, logger: Logger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(doc.getRoot().listBuffers().map((b) => b.getURI()));\n\n\tdoc.getRoot().listMeshes()\n\t\t.forEach((mesh, meshIndex) => {\n\t\t\tif (Array.isArray(options.meshes) && !options.meshes.includes(mesh.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping mesh at index ${meshIndex} with name \"${mesh.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for mesh \"${mesh.getName()}\".`);\n\n\t\t\tconst buffer = doc.createBuffer(mesh.getName())\n\t\t\t\t.setURI(createBufferURI(mesh.getName() || 'mesh', existingURIs));\n\n\t\t\tmesh.listPrimitives()\n\t\t\t\t.forEach((primitive) => {\n\t\t\t\t\tif (primitive.getIndices()) primitive.getIndices().setBuffer(buffer);\n\t\t\t\t\tprimitive.listAttributes()\n\t\t\t\t\t\t.forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t\tprimitive.listTargets()\n\t\t\t\t\t\t.forEach((primTarget) => {\n\t\t\t\t\t\t\tprimTarget.listAttributes()\n\t\t\t\t\t\t\t\t.forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t\t\t})\n\t\t\t\t});\n\t\t});\n}\n\nfunction partitionAnimations (doc: Document, logger: Logger, options: PartitionOptions): void {\n\tconst existingURIs = new Set<string>(doc.getRoot().listBuffers().map((b) => b.getURI()));\n\n\tdoc.getRoot().listAnimations()\n\t\t.forEach((anim, animIndex) => {\n\t\t\tif (Array.isArray(options.animations) && !options.animations.includes(anim.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping animation at index ${animIndex} with name \"${anim.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for animation \"${anim.getName()}\".`);\n\n\t\t\tconst buffer = doc.createBuffer(anim.getName())\n\t\t\t\t.setURI(createBufferURI(anim.getName() || 'animation', existingURIs));\n\n\t\t\tanim.listSamplers()\n\t\t\t\t.forEach((sampler) => {\n\t\t\t\t\tsampler.getInput().setBuffer(buffer);\n\t\t\t\t\tsampler.getOutput().setBuffer(buffer);\n\t\t\t\t});\n\t\t});\n}\n\nfunction createBufferURI (basename: string, existing: Set<string>): string {\n\tlet uri = `${basename}.bin`;\n\tlet i = 1;\n\twhile (existing.has(uri)) uri = `${basename}_${i++}.bin`;\n\treturn uri;\n}\n\nexport { partition };\n","import { Document, Transform } from '@gltf-transform/core';\n\nconst NAME = 'sequence';\n\nexport interface SequenceOptions {\n\tfps?: number;\n\tpattern: RegExp;\n\tname?: string;\n\tsort?: boolean;\n}\n\nconst DEFAULT_OPTIONS: SequenceOptions = {\n\tname: '',\n\tfps: 10,\n\tpattern: null,\n\tsort: true,\n};\n\n/**\n * Options:\n * - **name**: Name of the new animation.\n * - **fps**: Frames per second, where one node is shown each frame. Default 10.\n * - **pattern**: Pattern (regex) used to filter nodes for the sequence. Required.\n * - **sort**: Whether to sort the nodes by name, or use original order. Default true.\n */\nexport function sequence (options: SequenceOptions): Transform {\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\treturn (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst fps = options.fps;\n\n\t\t// Collect sequence nodes.\n\t\tconst sequenceNodes = root.listNodes()\n\t\t\t.filter((node) => node.getName().match(options.pattern));\n\n\t\t// Sort by node name.\n\t\tif (options.sort) {\n\t\t\tsequenceNodes.sort((a, b) => a.getName() > b.getName() ? 1 : -1);\n\t\t}\n\n\t\t// Create animation cycling visibility of each node.\n\t\tconst anim = doc.createAnimation(options.name);\n\t\tconst animBuffer = root.listBuffers()[0];\n\t\tsequenceNodes.forEach((node, i) => {\n\t\t\t// Create keyframe tracks that show each node for a single frame.\n\t\t\tlet inputArray;\n\t\t\tlet outputArray;\n\t\t\tif (i === 0) {\n\t\t\t\tinputArray = [i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [1,1,1, 0,0,0];\n\t\t\t} else if (i === sequenceNodes.length - 1) {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps];\n\t\t\t\toutputArray = [0,0,0, 1,1,1];\n\t\t\t} else {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [0,0,0, 1,1,1, 0,0,0];\n\t\t\t}\n\n\t\t\t// Append channel to animation sequence.\n\t\t\tconst input = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(inputArray))\n\t\t\t\t.setBuffer(animBuffer);\n\t\t\tconst output = doc.createAccessor()\n\t\t\t\t.setArray(new Float32Array(outputArray))\n\t\t\t\t.setBuffer(animBuffer)\n\t\t\t\t.setType(GLTF.AccessorType.VEC3);\n\t\t\tconst sampler = doc.createAnimationSampler()\n\t\t\t\t.setInterpolation(GLTF.AnimationSamplerInterpolation.STEP)\n\t\t\t\t.setInput(input)\n\t\t\t\t.setOutput(output);\n\t\t\tconst channel = doc.createAnimationChannel()\n\t\t\t\t.setTargetNode(node)\n\t\t\t\t.setTargetPath(GLTF.AnimationChannelTargetPath.SCALE)\n\t\t\t\t.setSampler(sampler);\n\t\t\tanim.addSampler(sampler).addChannel(channel);\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t};\n\n}\n","import { Accessor, Document, ExtensionProperty, ImageUtils, Primitive, Texture, vec2 } from '@gltf-transform/core';\nimport { bounds } from './bounds';\n\nexport function inspect (doc: Document): Report {\n\treturn {\n\t\tscenes: listScenes(doc),\n\t\tmeshes: listMeshes(doc),\n\t\tmaterials: listMaterials(doc),\n\t\ttextures: listTextures(doc),\n\t\tanimations: listAnimations(doc),\n\t};\n}\n\n/** List scenes. */\nfunction listScenes (doc): PropertyReport<SceneReport> {\n\tconst scenes = doc.getRoot().listScenes().map((scene) => {\n\t\tconst root = scene.listChildren()[0];\n\t\tconst sceneBounds = bounds(scene);\n\t\treturn {\n\t\t\tname: scene.getName(),\n\t\t\trootName: root ? root.getName() : '',\n\t\t\tbboxMin: toPrecision(sceneBounds.min),\n\t\t\tbboxMax: toPrecision(sceneBounds.max),\n\t\t};\n\t});\n\treturn {properties: scenes};\n}\n\n/** List meshes. */\nfunction listMeshes (doc: Document): PropertyReport<MeshReport> {\n\tconst meshes: MeshReport[] = doc.getRoot().listMeshes().map((mesh) => {\n\t\tconst instances = mesh.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\t\tlet glPrimitives = 0;\n\t\tlet verts = 0;\n\t\tlet indexed = 0;\n\t\tconst componentTypes: Set<string> = new Set();\n\t\tconst semantics: Set<string> = new Set();\n\t\tconst meshAccessors: Set<Accessor> = new Set();\n\n\t\tmesh.listPrimitives().forEach((prim) => {\n\t\t\tprim.listSemantics().forEach((s) => semantics.add(s));\n\t\t\tfor (const attr of prim.listAttributes()) {\n\t\t\t\tcomponentTypes.add(attr.getArray().constructor.name);\n\t\t\t\tmeshAccessors.add(attr);\n\t\t\t}\n\t\t\tfor (const targ of prim.listTargets()) {\n\t\t\t\tfor (const attr of targ.listAttributes()) {\n\t\t\t\t\tcomponentTypes.add(attr.getArray().constructor.name);\n\t\t\t\t\tmeshAccessors.add(attr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (prim.getIndices()) {\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tcomponentTypes.add(indices.getArray().constructor.name);\n\t\t\t\tindexed++;\n\t\t\t\tmeshAccessors.add(indices);\n\t\t\t}\n\t\t\tverts += prim.getAttribute('POSITION').getCount();\n\t\t\tglPrimitives += getGLPrimitiveCount(prim);\n\t\t});\n\n\t\tlet size = 0;\n\t\tArray.from(meshAccessors).forEach((a) => (size += a.getArray().byteLength));\n\n\t\tconst modes = mesh.listPrimitives()\n\t\t\t.map((prim) => MeshPrimitiveModeLabels[prim.getMode()])\n\n\t\treturn {\n\t\t\tname: mesh.getName(),\n\t\t\tmode: Array.from(new Set(modes)),\n\t\t\tprimitives: mesh.listPrimitives().length,\n\t\t\tglPrimitives: glPrimitives,\n\t\t\tvertices: verts,\n\t\t\tindexed: mesh.listPrimitives().length === indexed,\n\t\t\tcomponents: Array.from(componentTypes).sort().map((s) => s.replace('Array', '')),\n\t\t\tattributes: Array.from(semantics).sort(),\n\t\t\tinstances: instances,\n\t\t\tsize: size,\n\t\t};\n\t});\n\n\treturn {properties: meshes};\n}\n\n/** List materials. */\nfunction listMaterials (doc: Document): PropertyReport<MaterialReport> {\n\tconst materials: MaterialReport[] = doc.getRoot().listMaterials().map((material) => {\n\t\tconst instances = material.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\n\t\t// Find all texture slots attached to this material or its extensions.\n\t\tconst extensions = new Set<ExtensionProperty>(material.listExtensions());\n\t\tconst slots = doc.getGraph().getLinks()\n\t\t\t.filter((link) => {\n\t\t\t\tconst child = link.getChild();\n\t\t\t\tconst parent = link.getParent();\n\t\t\t\tif (child instanceof Texture && parent === material) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (child instanceof Texture\n\t\t\t\t\t\t&& parent instanceof ExtensionProperty\n\t\t\t\t\t\t&& extensions.has(parent)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t})\n\t\t\t.map((link) => link.getName());\n\n\t\treturn {\n\t\t\tname: material.getName(),\n\t\t\tinstances,\n\t\t\ttextures: slots,\n\t\t\talphaMode: material.getAlphaMode(),\n\t\t\tdoubleSided: material.getDoubleSided(),\n\t\t};\n\t});\n\n\treturn {properties: materials};\n}\n\n/** List textures. */\nfunction listTextures (doc: Document): PropertyReport<TextureReport> {\n\tconst textures: TextureReport[] = doc.getRoot().listTextures().map((texture) => {\n\t\tconst instances = texture.listParents()\n\t\t\t.filter((parent) => parent.propertyType !== 'Root')\n\t\t\t.length;\n\n\t\tconst slots = doc.getGraph().getLinks()\n\t\t\t.filter((link) => link.getChild() === texture)\n\t\t\t.map((link) => link.getName())\n\t\t\t.filter((name) => name !== 'texture');\n\n\t\tlet resolution: vec2;\n\t\tlet channels: number;\n\t\tif (texture.getMimeType() === 'image/png') {\n\t\t\tresolution = ImageUtils.getSizePNG(texture.getImage());\n\t\t\tchannels = 4;\n\t\t} else if (texture.getMimeType() === 'image/jpeg') {\n\t\t\tresolution = ImageUtils.getSizeJPEG(texture.getImage());\n\t\t\tchannels = 3;\n\t\t}\n\n\t\treturn {\n\t\t\tname: texture.getName(),\n\t\t\turi: texture.getURI(),\n\t\t\tslots: Array.from(new Set(slots)),\n\t\t\tinstances,\n\t\t\tmimeType: texture.getMimeType(),\n\t\t\tresolution: resolution ? resolution.join('x') : '',\n\t\t\tsize: texture.getImage().byteLength,\n\t\t\tmemSize: resolution ? resolution[0] * resolution[1] * channels : null,\n\t\t};\n\t});\n\n\treturn {properties: textures};\n}\n\n/** List animations. */\nfunction listAnimations (doc: Document): PropertyReport<AnimationReport> {\n\tconst animations: AnimationReport[] = doc.getRoot().listAnimations().map((anim) => {\n\t\tlet minTime = Infinity;\n\t\tlet maxTime = -Infinity;\n\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\tminTime = Math.min(minTime, sampler.getInput().getMin([])[0]);\n\t\t\tmaxTime = Math.max(maxTime, sampler.getInput().getMax([])[0]);\n\t\t});\n\n\t\tlet size = 0;\n\t\tconst accessors: Set<Accessor> = new Set();\n\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\taccessors.add(sampler.getInput());\n\t\t\taccessors.add(sampler.getOutput());\n\t\t});\n\t\tArray.from(accessors).forEach((accessor) => {\n\t\t\tsize += accessor.getArray().byteLength;\n\t\t});\n\n\t\treturn {\n\t\t\tname: anim.getName(),\n\t\t\tchannels: anim.listChannels().length,\n\t\t\tsamplers: anim.listSamplers().length,\n\t\t\tduration: Math.round((maxTime - minTime) * 1000) / 1000,\n\t\t\tsize: size,\n\t\t};\n\t});\n\n\treturn {properties: animations}\n}\n\ninterface Report {\n\tscenes: PropertyReport<SceneReport>;\n\tmeshes: PropertyReport<MeshReport>;\n\tmaterials: PropertyReport<MaterialReport>;\n\ttextures: PropertyReport<TextureReport>;\n\tanimations: PropertyReport<AnimationReport>;\n}\n\ninterface PropertyReport<T> {\n\tproperties: T[];\n\terrors?: string[];\n\twarnings?: string[];\n}\n\ninterface SceneReport {\n\tname: string;\n\trootName: string;\n\tbboxMin: number[];\n\tbboxMax: number[];\n}\n\ninterface MeshReport {\n\tname: string;\n\tprimitives: number;\n\tindexed: boolean;\n\tmode: string[];\n\tvertices: number;\n\tglPrimitives: number;\n\tcomponents: string[];\n\tattributes: string[];\n\tinstances: number;\n\tsize: number;\n}\n\ninterface MaterialReport {\n\tname: string;\n\tinstances: number;\n\ttextures: string[];\n\talphaMode: GLTF.MaterialAlphaMode;\n\tdoubleSided: boolean;\n}\n\ninterface TextureReport {\n\tname: string;\n\turi: string;\n\tslots: string[];\n\tinstances: number;\n\tmimeType: string;\n\tresolution: string;\n\tsize: number;\n\tmemSize: number;\n}\n\ninterface AnimationReport {\n\tname: string;\n\tchannels: number;\n\tsamplers: number;\n\tduration: number;\n\tsize: number;\n}\n\nconst MeshPrimitiveModeLabels = [\n\t'POINTS',\n\t'LINES',\n\t'LINE_LOOP',\n\t'LINE_STRIP',\n\t'TRIANGLES',\n\t'TRIANGLE_STRIP',\n\t'TRIANGLE_FAN',\n];\n\nfunction getGLPrimitiveCount(prim: Primitive): number {\n\t// Reference: https://www.khronos.org/opengl/wiki/Primitive\n\tswitch (prim.getMode()) {\n\t\tcase GLTF.MeshPrimitiveMode.POINTS:\n\t\t\treturn prim.getAttribute('POSITION').getCount();\n\t\tcase GLTF.MeshPrimitiveMode.LINES:\n\t\t\treturn prim.getIndices()\n\t\t\t\t? prim.getIndices().getCount() / 2\n\t\t\t\t: prim.getAttribute('POSITION').getCount() / 2;\n\t\tcase GLTF.MeshPrimitiveMode.LINE_LOOP:\n\t\t\treturn prim.getAttribute('POSITION').getCount();\n\t\tcase GLTF.MeshPrimitiveMode.LINE_STRIP:\n\t\t\treturn prim.getAttribute('POSITION').getCount() - 1;\n\t\tcase GLTF.MeshPrimitiveMode.TRIANGLES:\n\t\t\treturn prim.getIndices()\n\t\t\t\t? prim.getIndices().getCount() / 3\n\t\t\t\t: prim.getAttribute('POSITION').getCount() / 3;\n\t\tcase GLTF.MeshPrimitiveMode.TRIANGLE_STRIP:\n\t\tcase GLTF.MeshPrimitiveMode.TRIANGLE_FAN:\n\t\t\treturn prim.getAttribute('POSITION').getCount() - 2;\n\t\tdefault:\n\t\t\tthrow new Error('Unexpected mode: ' + prim.getMode());\n\t}\n}\n\n/** Maps values in a vector to a finite precision. */\nfunction toPrecision(v: number[]): number[] {\n\tfor (let i = 0; i < v.length; i++) {\n\t\tif (v[i].toFixed) v[i] = Number(v[i].toFixed(5));\n\t}\n\treturn v;\n}\n","import { Accessor, Document, Primitive, Transform } from '@gltf-transform/core';\n\nconst NAME = 'colorspace';\n\nexport interface ColorspaceOptions {\n    inputEncoding: string;\n}\n\n/**\n * Options:\n * - **inputEncoding**: Currently accepts only `\"sRGB\"`. Required.\n */\nexport function colorspace (options: ColorspaceOptions): Transform {\n\n\treturn (doc: Document): void => {\n\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.inputEncoding === 'linear') {\n\t\t\tlogger.info(`${NAME}: Vertex colors already linear. Skipping conversion.`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.inputEncoding !== 'sRGB') {\n\t\t\tlogger.error(\n\t\t\t\t`${NAME}: Unknown input encoding \"${options.inputEncoding}\" â€“ should be \"sRGB\" or `\n\t\t\t\t+ '\"linear\". Skipping conversion.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst converted = new Set<Accessor>();\n\n\t\t// Source: THREE.Color\n\t\tfunction sRGBToLinear( c: number ): number {\n\n\t\t\treturn ( c < 0.04045 )\n\t\t\t\t? c * 0.0773993808\n\t\t\t\t: Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t}\n\n\t\tfunction updatePrimitive(primitive: Primitive): void {\n\t\t\tconst color = [];\n\t\t\tlet attribute: Accessor;\n\t\t\tfor (let i = 0; (attribute = primitive.getAttribute(`COLOR_${i}`)); i++) {\n\t\t\t\tif (converted.has(attribute)) continue;\n\n\t\t\t\tfor (let j = 0; j < attribute.getCount(); j++) {\n\t\t\t\t\tattribute.getElement(j, color);\n\t\t\t\t\tcolor[0] = sRGBToLinear(color[0]);\n\t\t\t\t\tcolor[1] = sRGBToLinear(color[1]);\n\t\t\t\t\tcolor[2] = sRGBToLinear(color[2]);\n\t\t\t\t\tattribute.setElement(j, color);\n\t\t\t\t}\n\n\t\t\t\tconverted.add(attribute);\n\t\t\t}\n\t\t}\n\n\t\tdoc.getRoot()\n\t\t\t.listMeshes()\n\t\t\t.forEach((mesh) => mesh.listPrimitives().forEach(updatePrimitive));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\n\t};\n\n}\n"],"names":["geoao","geoaoNamespace","REGL","reglNamespace","DEFAULT_OPTIONS","resolution","samples","TEXTURE_DATA","Uint8Array","buffer","bounds","node","resultBounds","min","Infinity","max","Node","listChildren","traverse","getMesh","meshBounds","getMeshBounds","getWorldMatrix","expandBounds","mesh","worldMatrix","listPrimitives","position","getAttribute","localPos","worldPos","i","getCount","getElement","transformMat4","point","target","Math","pivot","accessors","textures","rewriteTexture","source","fn","Promise","resolve","reject","getPixels","Buffer","from","getImage","getMimeType","err","pixels","shape","j","chunks","savePixels","on","d","push","BufferUtils","trim","concat","e","image","setImage","setMimeType","getPixelsNamespace","savePixelsNamespace","value","bind","_settle","o","result","_this","thenable","NAME","animations","meshes","createBufferURI","basename","existing","uri","has","name","fps","pattern","sort","listScenes","doc","properties","getRoot","map","scene","root","sceneBounds","getName","rootName","bboxMin","toPrecision","bboxMax","listMeshes","instances","listParents","filter","parent","propertyType","length","glPrimitives","verts","indexed","componentTypes","Set","semantics","meshAccessors","forEach","prim","listSemantics","s","add","listAttributes","attr","getArray","constructor","listTargets","getIndices","indices","getMode","Error","getGLPrimitiveCount","size","Array","a","byteLength","modes","MeshPrimitiveModeLabels","mode","primitives","vertices","components","replace","attributes","listMaterials","material","extensions","listExtensions","slots","getGraph","getLinks","link","child","getChild","getParent","Texture","ExtensionProperty","alphaMode","getAlphaMode","doubleSided","getDoubleSided","listTextures","texture","channels","ImageUtils","getSizePNG","getSizeJPEG","getURI","mimeType","join","memSize","listAnimations","anim","minTime","maxTime","listSamplers","sampler","getInput","getMin","getMax","getOutput","accessor","listChannels","samplers","duration","round","v","toFixed","Number","options","logger","getLogger","debug","primitive","warn","regl","createTexture","gl","getExtension","index","getMaterial","getOcclusionTexture","cells","undefined","aoSampler","sample","ao","report","dispose","numVertices","uv2Data","Float32Array","listBuffers","createBuffer","uv2","createAccessor","setArray","setType","setAttribute","setOcclusionTexture","isAnimated","listSkins","bbox","offset","offsetNode","createNode","setTranslation","addChild","t","getTranslation","inputEncoding","converted","updatePrimitive","error","info","sRGBToLinear","c","pow","attribute","color","setElement","indicesAccessors","attributeAccessors","detectDuplicates","duplicateAccessors","Map","aData","slice","b","getType","getComponentType","getNormalized","equals","set","duplicateIndices","duplicateAttributes","swap","get","keys","dedupAccessors","duplicates","bData","getSize","entries","src","dst","property","Material","dedupImages","scenes","materials","specGlossExtension","inputTextures","tex","extensionName","MaterialsPBRSpecularGlossiness","EXTENSION_NAME","listExtensionsUsed","ext","includes","iorExtension","createExtension","MaterialsIOR","specExtension","MaterialsSpecular","setExtension","specGloss","specular","createSpecular","setSpecularFactor","setSpecularColorFactor","getSpecularFactor","getSpecularGlossinessTexture","getBaseColorTexture","getMetallicRoughnessTexture","setBaseColorFactor","getDiffuseFactor","setMetallicFactor","setRoughnessFactor","createIOR","setIOR","diffuseTexture","getDiffuseTexture","setBaseColorTexture","getBaseColorTextureInfo","copy","getDiffuseTextureInfo","sgTexture","sgTextureInfo","getSpecularGlossinessTextureInfo","specularTexture","setSpecularTexture","getSpecularTextureInfo","glossinessFactor","getGlossinessFactor","metalRoughTexture","roughness","setMetallicRoughnessTexture","getMetallicRoughnessTextureInfo","existingURIs","meshIndex","isArray","setURI","setBuffer","primTarget","partitionMeshes","animIndex","partitionAnimations","sequenceNodes","listNodes","match","createAnimation","animBuffer","inputArray","outputArray","input","output","createAnimationSampler","setInterpolation","setInput","setOutput","channel","createAnimationChannel","setTargetNode","setTargetPath","setSampler","addSampler","addChannel"],"mappings":"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"}