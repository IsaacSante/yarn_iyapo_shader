import e from"geo-ambient-occlusion";import t from"regl";import{transformMat4 as n}from"gl-matrix/vec3";import{Node as r,BufferUtils as o,Material as s,Texture as i,ExtensionProperty as a,ImageUtils as c}from"@gltf-transform/core";import{MaterialsIOR as g,MaterialsSpecular as l,MaterialsPBRSpecularGlossiness as u}from"@gltf-transform/extensions";import m from"get-pixels";import f from"save-pixels";const p=e,d=t,h={resolution:512,samples:500},I=new Uint8Array([137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,1,0,0,0,0,1,8,6,0,0,0,49,89,112,119,0,0,0,32,73,68,65,84,56,79,99,100,96,96,248,207,196,196,196,0,2,163,244,104,56,140,166,131,145,147,15,24,25,25,25,0,254,131,3,254,243,176,75,70,0,0,0,0,73,69,78,68,174,66,96,130]).buffer;function y(e=h){return e={...h,...e},t=>{const n=t.getLogger(),{resolution:r,samples:o}=e;n.debug(`ao: resolution = ${r}; samples = ${o}`);const s=new Set;if(t.getRoot().listMeshes().forEach(e=>{e.listPrimitives().forEach(e=>s.add(e))}),0===s.size)return n.warn("ao: No primitives found."),void n.debug("ao: Complete.");const i=t.createTexture("occlusion").setImage(I).setMimeType("image/png");let a;if(e.gl){const t=e.gl(r,r);t.getExtension("OES_texture_float"),t.getExtension("OES_element_index_uint"),a=d({gl:t,extensions:["OES_texture_float","OES_element_index_uint"]})}Array.from(s).forEach((e,c)=>{if(n.debug(`ao: Baking primitive ${c} / ${s.size}.`),e.getMaterial().getOcclusionTexture())return void n.warn("ao: Primitive already has AO. Is it sharing a material? Skipping.");const g=e.getAttribute("POSITION").getArray(),l=e.getIndices()?e.getIndices().getArray():void 0,u=p(g,{cells:l,resolution:r,regl:a});for(let e=0;e<o;e++)u.sample();const m=u.report();u.dispose();const f=m.length,d=new Float32Array(2*f);for(let e=0;e<f;e++)d[2*e]=d[2*e+1]=1-m[e];const h=t.getRoot().listBuffers()[0]||t.createBuffer(""),I=t.createAccessor("uv2",h).setArray(d).setType("VEC2");e.setAttribute("TEXCOORD_1",I),e.getAttribute.TEXCOORD_0||e.setAttribute("TEXCOORD_0",I),e.getMaterial().setOcclusionTexture(i)}),n.debug("ao: Complete.")}}function S(e){const t={min:[Infinity,Infinity,Infinity],max:[-Infinity,-Infinity,-Infinity]},n=e instanceof r?[e]:e.listChildren();for(const e of n)e.traverse(e=>{if(!e.getMesh())return;const n=x(e.getMesh(),e.getWorldMatrix());E(n.min,t),E(n.max,t)});return t}function x(e,t){const r={min:[Infinity,Infinity,Infinity],max:[-Infinity,-Infinity,-Infinity]};for(const o of e.listPrimitives()){const e=o.getAttribute("POSITION");let s=[0,0,0],i=[0,0,0];for(let o=0;o<e.getCount();o++)s=e.getElement(o,s),i=n(i,s,t),E(i,r)}return r}function E(e,t){for(let n=0;n<3;n++)t.min[n]=Math.min(e[n],t.min[n]),t.max[n]=Math.max(e[n],t.max[n])}const A={pivot:"center"};function T(e=A){return t=>{const n=t.getLogger(),r=t.getRoot(),o=r.listAnimations().length>0||r.listSkins().length>0;t.getRoot().listScenes().forEach((s,i)=>{let a;if(n.debug(`center: Scene ${i+1} / ${r.listScenes().length}.`),"string"==typeof e.pivot){const t=S(s);a=[(t.max[0]-t.min[0])/2+t.min[0],(t.max[1]-t.min[1])/2+t.min[1],(t.max[2]-t.min[2])/2+t.min[2]],"above"===e.pivot&&(a[1]=t.max[1]),"below"===e.pivot&&(a[1]=t.min[1])}else a=e.pivot;n.debug(`center: Pivot "${a.join(", ")}".`);const c=[-1*a[0],-1*a[1],-1*a[2]];if(o){n.debug("center: Model contains animation or skin. Adding a wrapper node.");const e=t.createNode("Pivot").setTranslation(c);s.listChildren().forEach(t=>e.addChild(t)),s.addChild(e)}else n.debug("center: Skipping wrapper, offsetting all root nodes."),s.listChildren().forEach(e=>{const t=e.getTranslation();e.setTranslation([t[0]+c[0],t[1]+c[1],t[2]+c[2]])})}),n.debug("center: Complete.")}}function b(e){return t=>{const n=t.getLogger();if("linear"===e.inputEncoding)return void n.info("colorspace: Vertex colors already linear. Skipping conversion.");if("sRGB"!==e.inputEncoding)return void n.error(`colorspace: Unknown input encoding "${e.inputEncoding}" â€“ should be "sRGB" or "linear". Skipping conversion.`);const r=new Set;function o(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function s(e){const t=[];let n;for(let s=0;n=e.getAttribute("COLOR_"+s);s++)if(!r.has(n)){for(let e=0;e<n.getCount();e++)n.getElement(e,t),t[0]=o(t[0]),t[1]=o(t[1]),t[2]=o(t[2]),n.setElement(e,t);r.add(n)}}t.getRoot().listMeshes().forEach(e=>e.listPrimitives().forEach(s)),n.debug("colorspace: Complete.")}}const N={accessors:!0,textures:!0},R=function(e=N){return e={...N,...e},t=>{const n=t.getLogger();!1!==e.accessors&&function(e,t){const n=new Set,r=new Set,s=t.getRoot().listMeshes();function i(e){const t=new Map;for(let n=0;n<e.length;n++){const r=e[n],s=r.getArray().slice().buffer;if(!t.has(r))for(let n=0;n<e.length;n++){const i=e[n];r!==i&&(t.has(i)||r.getType()===i.getType()&&r.getComponentType()===i.getComponentType()&&r.getCount()===i.getCount()&&r.getNormalized()===i.getNormalized()&&o.equals(s,i.getArray().slice().buffer)&&t.set(i,r))}}return t}s.forEach(e=>{e.listPrimitives().forEach(e=>{e.listAttributes().forEach(e=>r.add(e)),e.getIndices()&&n.add(e.getIndices())})});const a=i(Array.from(n));e.debug(`dedup: Found ${a.size} duplicates among ${n.size} indices.`);const c=i(Array.from(r));e.debug(`dedup: Found ${c.size} duplicates among ${r.size} attributes.`),s.forEach(e=>{e.listPrimitives().forEach(e=>{e.listAttributes().forEach(t=>{c.has(t)&&e.swap(t,c.get(t))});const t=e.getIndices();t&&a.has(t)&&e.swap(t,a.get(t))})}),Array.from(a.keys()).forEach(e=>e.dispose()),Array.from(c.keys()).forEach(e=>e.dispose())}(n,t),!1!==e.textures&&function(e,t){const n=t.getRoot(),r=n.listTextures(),i=new Map;for(let e=0;e<r.length;e++){const t=r[e],n=t.getImage();if(!i.has(t))for(let e=0;e<r.length;e++){const s=r[e],a=s.getImage();t!==s&&(i.has(s)||t.getMimeType()===s.getMimeType()&&t.getSize()[0]===s.getSize()[0]&&t.getSize()[1]===s.getSize()[1]&&o.equals(n,a)&&i.set(s,t))}}e.debug(`dedup: Found ${i.size} duplicates among ${n.listTextures().length} textures.`),Array.from(i.entries()).forEach(([e,t])=>{e.listParents().forEach(n=>{n instanceof s&&n.swap(e,t)}),e.dispose()})}(n,t),n.debug("dedup: Complete.")}},C=m,M=f;async function w(e,t,n){if(!e)return null;const r=await new Promise((t,n)=>{C(Buffer.from(e.getImage()),e.getMimeType(),(e,r)=>e?n(e):t(r))});for(let e=0;e<r.shape[0];++e)for(let t=0;t<r.shape[1];++t)n(r,e,t);const s=await new Promise((e,t)=>{const n=[];M(r,"png").on("data",e=>n.push(e)).on("end",()=>e(o.trim(Buffer.concat(n)))).on("error",e=>t(e))});return t.setImage(s).setMimeType("image/png")}function O(e={}){return async e=>{const t=e.getLogger(),n=u.EXTENSION_NAME;if(!e.getRoot().listExtensionsUsed().map(e=>e.extensionName).includes(n))return void t.warn(`metalRough: Extension ${n} not found on given document.`);const r=e.createExtension(g),o=e.createExtension(l),s=e.createExtension(u),i=new Set;for(const t of e.getRoot().listMaterials()){const n=t.getExtension("KHR_materials_pbrSpecularGlossiness");if(!n)continue;const s=o.createSpecular().setSpecularFactor(1).setSpecularColorFactor(n.getSpecularFactor());i.add(n.getSpecularGlossinessTexture()),i.add(t.getBaseColorTexture()),i.add(t.getMetallicRoughnessTexture()),t.setBaseColorFactor(n.getDiffuseFactor()).setMetallicFactor(0).setRoughnessFactor(1).setExtension("KHR_materials_ior",r.createIOR().setIOR(1e3)).setExtension("KHR_materials_specular",s);const a=n.getDiffuseTexture();a&&(t.setBaseColorTexture(a),t.getBaseColorTextureInfo().copy(n.getDiffuseTextureInfo()));const c=n.getSpecularGlossinessTexture();if(c){const r=n.getSpecularGlossinessTextureInfo(),o=e.createTexture();await w(c,o,(e,t,n)=>{e.set(t,n,3,255)}),s.setSpecularTexture(o),s.getSpecularTextureInfo().copy(r);const i=n.getGlossinessFactor(),a=e.createTexture();await w(c,a,(e,t,n)=>{const r=255-Math.round(e.get(t,n,3)*i);e.set(t,n,0,0),e.set(t,n,1,r),e.set(t,n,2,0),e.set(t,n,3,255)}),t.setMetallicRoughnessTexture(a),t.getMetallicRoughnessTextureInfo().copy(r)}else s.setSpecularColorFactor(n.getSpecularFactor()),t.setRoughnessFactor(1-n.getGlossinessFactor());t.setExtension("KHR_materials_pbrSpecularGlossiness",null)}s.dispose();for(const e of i)e&&1===e.listParents().length&&e.dispose();t.debug("metalRough: Complete.")}}const v={animations:!0,meshes:!0},P=e=>(e={...v,...e},t=>{const n=t.getLogger();!1!==e.meshes&&function(e,t,n){const r=new Set(e.getRoot().listBuffers().map(e=>e.getURI()));e.getRoot().listMeshes().forEach((o,s)=>{if(Array.isArray(n.meshes)&&!n.meshes.includes(o.getName()))return void t.debug(`partition: Skipping mesh at index ${s} with name "${o.getName()}".`);t.debug(`partition: Creating buffer for mesh "${o.getName()}".`);const i=e.createBuffer(o.getName()).setURI(_(o.getName()||"mesh",r));o.listPrimitives().forEach(e=>{e.getIndices()&&e.getIndices().setBuffer(i),e.listAttributes().forEach(e=>e.setBuffer(i)),e.listTargets().forEach(e=>{e.listAttributes().forEach(e=>e.setBuffer(i))})})})}(t,n,e),!1!==e.animations&&function(e,t,n){const r=new Set(e.getRoot().listBuffers().map(e=>e.getURI()));e.getRoot().listAnimations().forEach((o,s)=>{if(Array.isArray(n.animations)&&!n.animations.includes(o.getName()))return void t.debug(`partition: Skipping animation at index ${s} with name "${o.getName()}".`);t.debug(`partition: Creating buffer for animation "${o.getName()}".`);const i=e.createBuffer(o.getName()).setURI(_(o.getName()||"animation",r));o.listSamplers().forEach(e=>{e.getInput().setBuffer(i),e.getOutput().setBuffer(i)})})}(t,n,e),e.meshes||e.animations||n.warn("partition: Select animations or meshes to create a partition."),n.debug("partition: Complete.")});function _(e,t){let n=e+".bin",r=1;for(;t.has(n);)n=`${e}_${r++}.bin`;return n}const B={name:"",fps:10,pattern:null,sort:!0};function $(e){return e={...B,...e},t=>{const n=t.getLogger(),r=t.getRoot(),o=e.fps,s=r.listNodes().filter(t=>t.getName().match(e.pattern));e.sort&&s.sort((e,t)=>e.getName()>t.getName()?1:-1);const i=t.createAnimation(e.name),a=r.listBuffers()[0];s.forEach((e,n)=>{let r,c;0===n?(r=[n/o,(n+1)/o],c=[1,1,1,0,0,0]):n===s.length-1?(r=[(n-1)/o,n/o],c=[0,0,0,1,1,1]):(r=[(n-1)/o,n/o,(n+1)/o],c=[0,0,0,1,1,1,0,0,0]);const g=t.createAccessor().setArray(new Float32Array(r)).setBuffer(a),l=t.createAccessor().setArray(new Float32Array(c)).setBuffer(a).setType("VEC3"),u=t.createAnimationSampler().setInterpolation("STEP").setInput(g).setOutput(l),m=t.createAnimationChannel().setTargetNode(e).setTargetPath("scale").setSampler(u);i.addSampler(u).addChannel(m)}),n.debug("sequence: Complete.")}}function F(e){return{scenes:L(e),meshes:z(e),materials:G(e),textures:k(e),animations:U(e)}}function L(e){return{properties:e.getRoot().listScenes().map(e=>{const t=e.listChildren()[0],n=S(e);return{name:e.getName(),rootName:t?t.getName():"",bboxMin:H(n.min),bboxMax:H(n.max)}})}}function z(e){return{properties:e.getRoot().listMeshes().map(e=>{const t=e.listParents().filter(e=>"Root"!==e.propertyType).length;let n=0,r=0,o=0;const s=new Set,i=new Set,a=new Set;e.listPrimitives().forEach(e=>{e.listSemantics().forEach(e=>i.add(e));for(const t of e.listAttributes())s.add(t.getArray().constructor.name),a.add(t);for(const t of e.listTargets())for(const e of t.listAttributes())s.add(e.getArray().constructor.name),a.add(e);if(e.getIndices()){const t=e.getIndices();s.add(t.getArray().constructor.name),o++,a.add(t)}r+=e.getAttribute("POSITION").getCount(),n+=function(e){switch(e.getMode()){case 0:return e.getAttribute("POSITION").getCount();case 1:return e.getIndices()?e.getIndices().getCount()/2:e.getAttribute("POSITION").getCount()/2;case 2:return e.getAttribute("POSITION").getCount();case 3:return e.getAttribute("POSITION").getCount()-1;case 4:return e.getIndices()?e.getIndices().getCount()/3:e.getAttribute("POSITION").getCount()/3;case 5:case 6:return e.getAttribute("POSITION").getCount()-2;default:throw new Error("Unexpected mode: "+e.getMode())}}(e)});let c=0;Array.from(a).forEach(e=>c+=e.getArray().byteLength);const g=e.listPrimitives().map(e=>D[e.getMode()]);return{name:e.getName(),mode:Array.from(new Set(g)),primitives:e.listPrimitives().length,glPrimitives:n,vertices:r,indexed:e.listPrimitives().length===o,components:Array.from(s).sort().map(e=>e.replace("Array","")),attributes:Array.from(i).sort(),instances:t,size:c}})}}function G(e){return{properties:e.getRoot().listMaterials().map(t=>{const n=t.listParents().filter(e=>"Root"!==e.propertyType).length,r=new Set(t.listExtensions()),o=e.getGraph().getLinks().filter(e=>{const n=e.getChild(),o=e.getParent();return n instanceof i&&o===t||!!(n instanceof i&&o instanceof a&&r.has(o))}).map(e=>e.getName());return{name:t.getName(),instances:n,textures:o,alphaMode:t.getAlphaMode(),doubleSided:t.getDoubleSided()}})}}function k(e){return{properties:e.getRoot().listTextures().map(t=>{const n=t.listParents().filter(e=>"Root"!==e.propertyType).length,r=e.getGraph().getLinks().filter(e=>e.getChild()===t).map(e=>e.getName()).filter(e=>"texture"!==e);let o,s;return"image/png"===t.getMimeType()?(o=c.getSizePNG(t.getImage()),s=4):"image/jpeg"===t.getMimeType()&&(o=c.getSizeJPEG(t.getImage()),s=3),{name:t.getName(),uri:t.getURI(),slots:Array.from(new Set(r)),instances:n,mimeType:t.getMimeType(),resolution:o?o.join("x"):"",size:t.getImage().byteLength,memSize:o?o[0]*o[1]*s:null}})}}function U(e){return{properties:e.getRoot().listAnimations().map(e=>{let t=Infinity,n=-Infinity;e.listSamplers().forEach(e=>{t=Math.min(t,e.getInput().getMin([])[0]),n=Math.max(n,e.getInput().getMax([])[0])});let r=0;const o=new Set;return e.listSamplers().forEach(e=>{o.add(e.getInput()),o.add(e.getOutput())}),Array.from(o).forEach(e=>{r+=e.getArray().byteLength}),{name:e.getName(),channels:e.listChannels().length,samplers:e.listSamplers().length,duration:Math.round(1e3*(n-t))/1e3,size:r}})}}const D=["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"];function H(e){for(let t=0;t<e.length;t++)e[t].toFixed&&(e[t]=Number(e[t].toFixed(5)));return e}export{y as ao,S as bounds,T as center,b as colorspace,R as dedup,F as inspect,O as metalRough,P as partition,$ as sequence};
//# sourceMappingURL=lib.modern.js.map
